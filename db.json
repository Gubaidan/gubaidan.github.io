{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"source/archive/debug.log","path":"archive/debug.log","modified":1,"renderable":0},{"_id":"source/assets/PostImg/bf1.jpg","path":"assets/PostImg/bf1.jpg","modified":1,"renderable":0},{"_id":"source/assets/PostImg/bf2.jpg","path":"assets/PostImg/bf2.jpg","modified":1,"renderable":0},{"_id":"source/assets/PostImg/command.png","path":"assets/PostImg/command.png","modified":1,"renderable":0},{"_id":"source/assets/PostImg/kmp-accept.png","path":"assets/PostImg/kmp-accept.png","modified":1,"renderable":0},{"_id":"source/assets/PostImg/login.png","path":"assets/PostImg/login.png","modified":1,"renderable":0},{"_id":"source/assets/PostImg/nginx.png","path":"assets/PostImg/nginx.png","modified":1,"renderable":0},{"_id":"source/assets/PostImg/servlet.png","path":"assets/PostImg/servlet.png","modified":1,"renderable":0},{"_id":"source/assets/PostImg/subsets.png","path":"assets/PostImg/subsets.png","modified":1,"renderable":0},{"_id":"source/assets/img/empty.png","path":"assets/img/empty.png","modified":1,"renderable":0},{"_id":"source/assets/img/favicon_bak.ico","path":"assets/img/favicon_bak.ico","modified":1,"renderable":0},{"_id":"source/assets/img/preloader.gif","path":"assets/img/preloader.gif","modified":1,"renderable":0},{"_id":"source/assets/blogimg/border1px.jpg","path":"assets/blogimg/border1px.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogimg/aj.jpg","path":"assets/blogimg/aj.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogimg/browser-history.jpg","path":"assets/blogimg/browser-history.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogimg/browser-history2.jpg","path":"assets/blogimg/browser-history2.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogimg/bys0.jpg","path":"assets/blogimg/bys0.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogimg/chord2.png","path":"assets/blogimg/chord2.png","modified":1,"renderable":0},{"_id":"source/assets/blogimg/css_hack.jpg","path":"assets/blogimg/css_hack.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogimg/diary-1.jpg","path":"assets/blogimg/diary-1.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogimg/diary-13.jpg","path":"assets/blogimg/diary-13.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogimg/diary-2.jpg","path":"assets/blogimg/diary-2.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogimg/diary-3.jpg","path":"assets/blogimg/diary-3.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogimg/diary-4.jpg","path":"assets/blogimg/diary-4.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogimg/diary-5.jpg","path":"assets/blogimg/diary-5.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogimg/diary-6.jpg","path":"assets/blogimg/diary-6.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogimg/dragon.jpg","path":"assets/blogimg/dragon.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogimg/gulangyu.jpg","path":"assets/blogimg/gulangyu.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogimg/imp_search.jpg","path":"assets/blogimg/imp_search.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogimg/immersion.png","path":"assets/blogimg/immersion.png","modified":1,"renderable":0},{"_id":"source/assets/blogimg/instagram1.jpg","path":"assets/blogimg/instagram1.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogimg/instagram2.jpg","path":"assets/blogimg/instagram2.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogimg/jiugongge1.jpg","path":"assets/blogimg/jiugongge1.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogimg/jiugongge10.jpg","path":"assets/blogimg/jiugongge10.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogimg/jiugongge2.jpg","path":"assets/blogimg/jiugongge2.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogimg/jiugongge3.jpg","path":"assets/blogimg/jiugongge3.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogimg/jiugongge4.jpg","path":"assets/blogimg/jiugongge4.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogimg/jiugongge5.jpg","path":"assets/blogimg/jiugongge5.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogimg/jiugongge6.jpg","path":"assets/blogimg/jiugongge6.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogimg/jiugongge7.jpg","path":"assets/blogimg/jiugongge7.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogimg/jiugongge8.jpg","path":"assets/blogimg/jiugongge8.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogimg/localstorage1.png","path":"assets/blogimg/localstorage1.png","modified":1,"renderable":0},{"_id":"source/assets/blogimg/localstorage2.png","path":"assets/blogimg/localstorage2.png","modified":1,"renderable":0},{"_id":"source/assets/blogimg/localstorage3.png","path":"assets/blogimg/localstorage3.png","modified":1,"renderable":0},{"_id":"source/assets/blogimg/localstorage4.png","path":"assets/blogimg/localstorage4.png","modified":1,"renderable":0},{"_id":"source/assets/blogimg/nginx1.jpg","path":"assets/blogimg/nginx1.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogimg/nginx0.jpg","path":"assets/blogimg/nginx0.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogimg/nginx2.jpg","path":"assets/blogimg/nginx2.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogimg/safety_001.jpg","path":"assets/blogimg/safety_001.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogimg/safety_002.jpg","path":"assets/blogimg/safety_002.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogimg/reduce-http.jpg","path":"assets/blogimg/reduce-http.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogimg/safety_005.jpg","path":"assets/blogimg/safety_005.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogimg/up1_tips.jpg","path":"assets/blogimg/up1_tips.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogimg/volunteer2.jpg","path":"assets/blogimg/volunteer2.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogimg/volunteer3.jpg","path":"assets/blogimg/volunteer3.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogimg/web_worker2.png","path":"assets/blogimg/web_worker2.png","modified":1,"renderable":0},{"_id":"source/assets/blogimg/web_worker1.png","path":"assets/blogimg/web_worker1.png","modified":1,"renderable":0},{"_id":"source/assets/blogimg/xbsj-3.jpg","path":"assets/blogimg/xbsj-3.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogimg/xbsj-1.jpg","path":"assets/blogimg/xbsj-1.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogimg/xmas_ico2.jpg","path":"assets/blogimg/xmas_ico2.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogimg/xmas_ico1.jpg","path":"assets/blogimg/xmas_ico1.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogimg/xmas_ico3.jpg","path":"assets/blogimg/xmas_ico3.jpg","modified":1,"renderable":0},{"_id":"themes/Anisina/source/css/blog-style.css","path":"css/blog-style.css","modified":1,"renderable":1},{"_id":"themes/Anisina/source/css/syntax.styl","path":"css/syntax.styl","modified":1,"renderable":1},{"_id":"themes/Anisina/source/css/font-awesome.css","path":"css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.eot","path":"fonts/glyphicons-halflings-regular.eot","modified":1,"renderable":1},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.ttf","path":"fonts/glyphicons-halflings-regular.ttf","modified":1,"renderable":1},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.woff","path":"fonts/glyphicons-halflings-regular.woff","modified":1,"renderable":1},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.woff2","path":"fonts/glyphicons-halflings-regular.woff2","modified":1,"renderable":1},{"_id":"themes/Anisina/source/js/blog.js","path":"js/blog.js","modified":1,"renderable":1},{"_id":"themes/Anisina/source/js/bootstrap.min.js","path":"js/bootstrap.min.js","modified":1,"renderable":1},{"_id":"themes/Anisina/source/js/jquery.tagcloud.js","path":"js/jquery.tagcloud.js","modified":1,"renderable":1},{"_id":"themes/Anisina/source/js/jump.js","path":"js/jump.js","modified":1,"renderable":1},{"_id":"themes/Anisina/source/js/totop.js","path":"js/totop.js","modified":1,"renderable":1},{"_id":"source/assets/PostImg/ResourceClassDependence.png","path":"assets/PostImg/ResourceClassDependence.png","modified":1,"renderable":0},{"_id":"source/assets/PostImg/git-prosessor.png","path":"assets/PostImg/git-prosessor.png","modified":1,"renderable":0},{"_id":"source/assets/PostImg/securitityManagement.png","path":"assets/PostImg/securitityManagement.png","modified":1,"renderable":0},{"_id":"source/assets/img/favicon.ico","path":"assets/img/favicon.ico","modified":1,"renderable":0},{"_id":"source/assets/img/log.JPG","path":"assets/img/log.JPG","modified":1,"renderable":0},{"_id":"source/assets/blogimg/changbaishan-1.jpg","path":"assets/blogimg/changbaishan-1.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogimg/changbaishan-2.jpg","path":"assets/blogimg/changbaishan-2.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogimg/chord1.jpg","path":"assets/blogimg/chord1.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogimg/ckxt3.jpg","path":"assets/blogimg/ckxt3.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogimg/css3_anm.jpg","path":"assets/blogimg/css3_anm.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogimg/diary-14.jpg","path":"assets/blogimg/diary-14.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogimg/diary-16.jpg","path":"assets/blogimg/diary-16.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogimg/diary-17.jpg","path":"assets/blogimg/diary-17.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogimg/diary-18.jpg","path":"assets/blogimg/diary-18.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogimg/diary-20.jpg","path":"assets/blogimg/diary-20.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogimg/diary-21.jpg","path":"assets/blogimg/diary-21.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogimg/diary-29.jpg","path":"assets/blogimg/diary-29.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogimg/diary-7.jpg","path":"assets/blogimg/diary-7.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogimg/jiugongge9.jpg","path":"assets/blogimg/jiugongge9.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogimg/litten.png","path":"assets/blogimg/litten.png","modified":1,"renderable":0},{"_id":"source/assets/blogimg/mediator1.jpg","path":"assets/blogimg/mediator1.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogimg/rabbit.jpg","path":"assets/blogimg/rabbit.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogimg/volunteer1.jpg","path":"assets/blogimg/volunteer1.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogimg/xbsj-2.jpg","path":"assets/blogimg/xbsj-2.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogimg/xmas_ico0.jpg","path":"assets/blogimg/xmas_ico0.jpg","modified":1,"renderable":0},{"_id":"themes/Anisina/source/css/bootstrap.min.css","path":"css/bootstrap.min.css","modified":1,"renderable":1},{"_id":"themes/Anisina/source/fonts/fontawesome-webfont.woff2","path":"fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/Anisina/source/fonts/fontawesome-webfont.woff","path":"fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.svg","path":"fonts/glyphicons-halflings-regular.svg","modified":1,"renderable":1},{"_id":"themes/Anisina/source/js/jquery.min.js","path":"js/jquery.min.js","modified":1,"renderable":1},{"_id":"source/assets/PostImg/D2338CFF-0768-4E86-AAAA-9E8305FE381F.png","path":"assets/PostImg/D2338CFF-0768-4E86-AAAA-9E8305FE381F.png","modified":1,"renderable":0},{"_id":"source/assets/blogimg/ckxt1.jpg","path":"assets/blogimg/ckxt1.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogimg/ckxt2.jpg","path":"assets/blogimg/ckxt2.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogimg/ckxt4.jpg","path":"assets/blogimg/ckxt4.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogimg/diary-24.jpg","path":"assets/blogimg/diary-24.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogimg/diary-27.jpg","path":"assets/blogimg/diary-27.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogimg/lazyload.jpg","path":"assets/blogimg/lazyload.jpg","modified":1,"renderable":0},{"_id":"themes/Anisina/source/fonts/fontawesome-webfont.ttf","path":"fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"source/assets/PostImg/BeanFactoryDependence.png","path":"assets/PostImg/BeanFactoryDependence.png","modified":1,"renderable":0},{"_id":"source/assets/PostImg/Beanfactory.png","path":"assets/PostImg/Beanfactory.png","modified":1,"renderable":0},{"_id":"source/assets/PostImg/applicationContext.png","path":"assets/PostImg/applicationContext.png","modified":1,"renderable":0},{"_id":"source/assets/PostImg/process.png","path":"assets/PostImg/process.png","modified":1,"renderable":0},{"_id":"source/assets/PostImg/shiro-frame.png","path":"assets/PostImg/shiro-frame.png","modified":1,"renderable":0},{"_id":"source/assets/blogimg/ckxt0.jpg","path":"assets/blogimg/ckxt0.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogimg/diary-10.jpg","path":"assets/blogimg/diary-10.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogimg/diary-12.jpg","path":"assets/blogimg/diary-12.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogimg/diary-19.jpg","path":"assets/blogimg/diary-19.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogimg/diary-26.jpg","path":"assets/blogimg/diary-26.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogimg/myReader0.jpg","path":"assets/blogimg/myReader0.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogimg/safety_004.jpg","path":"assets/blogimg/safety_004.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogimg/diary-11.jpg","path":"assets/blogimg/diary-11.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogimg/diary-23.jpg","path":"assets/blogimg/diary-23.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogimg/safety_003.jpg","path":"assets/blogimg/safety_003.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogimg/diary-28.jpg","path":"assets/blogimg/diary-28.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogimg/localstorage5.png","path":"assets/blogimg/localstorage5.png","modified":1,"renderable":0},{"_id":"themes/Anisina/source/js/jquery.js","path":"js/jquery.js","modified":1,"renderable":1},{"_id":"source/assets/blogimg/lijiang.jpg","path":"assets/blogimg/lijiang.jpg","modified":1,"renderable":0},{"_id":"source/assets/PostImg/loader.png","path":"assets/PostImg/loader.png","modified":1,"renderable":0},{"_id":"source/assets/blogimg/BLbaFJDAJ1i.jpg","path":"assets/blogimg/BLbaFJDAJ1i.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogimg/diary-15.jpg","path":"assets/blogimg/diary-15.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogimg/diary-25.jpg","path":"assets/blogimg/diary-25.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogimg/diary-22.jpg","path":"assets/blogimg/diary-22.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogimg/diary-9.jpg","path":"assets/blogimg/diary-9.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogimg/fengshui5.png","path":"assets/blogimg/fengshui5.png","modified":1,"renderable":0},{"_id":"source/assets/PostImg/lake.jpg","path":"assets/PostImg/lake.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogimg/fengshui4.png","path":"assets/blogimg/fengshui4.png","modified":1,"renderable":0},{"_id":"source/assets/blogimg/fengshui3.png","path":"assets/blogimg/fengshui3.png","modified":1,"renderable":0},{"_id":"source/assets/blogimg/bys2.jpg","path":"assets/blogimg/bys2.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogimg/fengshui2.png","path":"assets/blogimg/fengshui2.png","modified":1,"renderable":0},{"_id":"source/assets/blogimg/bys3.jpg","path":"assets/blogimg/bys3.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogimg/bys1.jpg","path":"assets/blogimg/bys1.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogimg/fengshui6.png","path":"assets/blogimg/fengshui6.png","modified":1,"renderable":0},{"_id":"source/assets/blogimg/fengshui0.png","path":"assets/blogimg/fengshui0.png","modified":1,"renderable":0},{"_id":"source/assets/blogimg/water.jpg","path":"assets/blogimg/water.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogimg/fengshui1.png","path":"assets/blogimg/fengshui1.png","modified":1,"renderable":0},{"_id":"source/assets/PostImg/dp.jpg","path":"assets/PostImg/dp.jpg","modified":1,"renderable":0},{"_id":"source/assets/PostImg/gs.png","path":"assets/PostImg/gs.png","modified":1,"renderable":0},{"_id":"source/assets/PostImg/aTdxuh3q4b8.png","path":"assets/PostImg/aTdxuh3q4b8.png","modified":1,"renderable":0}],"Cache":[{"_id":"source/CNAME","hash":"d3e3c9ea71291f16e5543a7c435c8bcefc5647d2","modified":1529571000493},{"_id":"source/.DS_Store","hash":"abc835fa795005eca59c4487da44b16ad285a014","modified":1557060133404},{"_id":"themes/Anisina/.DS_Store","hash":"764adc13b9405bb14fb6674efa75b93348fac340","modified":1557056907527},{"_id":"themes/Anisina/_config.yml","hash":"06bccfc42b143659f59ea78938f00c217ac5574d","modified":1499966658000},{"_id":"themes/Anisina/package.json","hash":"12541fbf56f785e4f5d486a55b4939f3033f625b","modified":1499966658000},{"_id":"source/archive/debug.log","hash":"f7248cfd25761b048e7920248f10a732f557dd58","modified":1529571000510},{"_id":"source/archive/index.md","hash":"088acc3d9712fb85644adb8a2d8815c239a3e05a","modified":1529571000510},{"_id":"source/_posts/.DS_Store","hash":"f71ba119c6be74830be48e854bfa7a1c0eba583a","modified":1531034744683},{"_id":"source/_posts/1-partten.markdown","hash":"7620f370e8c86a160607da0bc6732e90fb4df457","modified":1532239492301},{"_id":"source/_posts/2017-05-31-boolmFilter.markdown","hash":"4c0a5cbedce9b0f69daf63c0533a1661461c15fc","modified":1557059190483},{"_id":"source/_posts/2017-06-03-git.markdown","hash":"47d3df65006ea2b78065a14461494df525faeaec","modified":1557059245171},{"_id":"source/_posts/2017-06-04-sh.markdown","hash":"3f8da696a79d98ce7f468940a35b182d224935da","modified":1557059318827},{"_id":"source/_posts/2017-08-22-thin-border.markdown","hash":"f41147e7c87510552739cb1373cb503920aeccd1","modified":1557059398040},{"_id":"source/_posts/2017-09-03-kmp.markdown","hash":"b0faa54ef4ca0abca65b2e39e7b6cba21d030a46","modified":1557059463453},{"_id":"source/_posts/2017-11-06-refresh.markdown","hash":"91ced68c298dea4d1b6bcb4e8eb9c400e4de58cf","modified":1557059620941},{"_id":"source/_posts/2017-11-13-transmanager.markdown","hash":"6a8512645966ca8f14a0432a7bfd2f9b4625d1ed","modified":1531553926746},{"_id":"source/_posts/2017-11-2-spring-resouce.markdown","hash":"5fa29ef31daa8568cd95caf36363606659d1e727","modified":1557059524154},{"_id":"source/_posts/2017-11-20-DispatcherServlet.markdown","hash":"d31e6a009b9eae848830ea5896923f3cc8935f4f","modified":1557059679755},{"_id":"source/_posts/2017-11-21-DispatcherServlet-after.markdown","hash":"8a607ac73211b5d6502965bca3872efdbaa52788","modified":1557059724858},{"_id":"source/_posts/2017-11-27-web-launch.markdown","hash":"4552f16feb6fe21afc66e7af19a1835885061751","modified":1532178857535},{"_id":"source/_posts/2017-11-3-applicationContext（上）.markdown","hash":"5d278eb03243dc2de38a426e33bb1f3c315e5d04","modified":1557059576551},{"_id":"source/_posts/2017-11-9-spring-aop.markdown","hash":"b888423fba79d1e55d25782221004b088c301e76","modified":1531553920982},{"_id":"source/_posts/2018-02-23-GS.markdown","hash":"1c5c7946cb4a34d06f89c40037afd54697f962f3","modified":1557059759989},{"_id":"source/_posts/2018-03-02-DP.markdown","hash":"8ca9a7681c19c843086e664f31c8be2720934eef","modified":1529571000494},{"_id":"source/_posts/2018-03-03-navicat-utf8.markdown","hash":"9029f65531b37fd3795e2ed4927eebfda3a95800","modified":1531553706186},{"_id":"source/_posts/2018-03-23-Shiro.mrkdown.md","hash":"ed7d764eb8e63bcc5a1385ea10907998d2413db8","modified":1557060146518},{"_id":"source/_posts/2018-04-22-ORA00903.markdown","hash":"00029d3d5d4e6e2a20338d3991a47fa2032b7917","modified":1530685305136},{"_id":"source/_posts/about-pjax.markdown","hash":"a39156994c801229d4c792a7462369b0395a709f","modified":1530687305946},{"_id":"source/_posts/changbaishan.markdown","hash":"b2c03eab3213c86d842cd8fdcf92fb8c3202e4f3","modified":1531053846602},{"_id":"source/_posts/diary-2016-0731-0806.markdown","hash":"209c5faac6286f6d6e06e8e8fddbed4fb8c142df","modified":1529571000497},{"_id":"source/_posts/diary-2016-0814-0820.markdown","hash":"21e1d19be2782e6e92e6dbae74f51f095823481a","modified":1531553987545},{"_id":"source/_posts/diary-2016-0904-0910.markdown","hash":"13e62230f8c2ada94fdd60e26c494814a6296ff5","modified":1531053791463},{"_id":"source/_posts/diary-2016-1023-1029.markdown","hash":"11a7d587b0a8fc0224cf94f6a2233370977f420d","modified":1529571000498},{"_id":"source/_posts/folder-to-tree.markdown","hash":"4dc838c735e8a34216fbc7b63e1249e13847013d","modified":1557059888007},{"_id":"source/_posts/hello-world.markdown","hash":"0c0aa49202ffc2a7b9a02ce0fb375fc0f69e0acc","modified":1530687194343},{"_id":"source/_posts/img-lazy-load.markdown","hash":"fc3dc0345fdc2362659f4afa1819abffc8aed56c","modified":1530687202463},{"_id":"source/_posts/theme-update1-dot-0.markdown","hash":"3ad351c0645fd87cbb3b2e2345c408c04a27022a","modified":1532236806349},{"_id":"source/_posts/prevent-spiders.markdown","hash":"3eb07d26891d4229d44fdcf17dc25a0db3e019ea","modified":1557059958903},{"_id":"source/assets/.DS_Store","hash":"ed41dec805b70b5565cbf524faea54f97a664583","modified":1557058105349},{"_id":"source/tags/index.md","hash":"a42eed138c94895fb55a3f4fed28a18a297b93cb","modified":1529571000649},{"_id":"themes/Anisina/Screenshots/mobile-index.jpeg","hash":"cd75f77f5d865d42182e2233e354eeba9f114d98","modified":1499966658000},{"_id":"themes/Anisina/languages_to_be_added/de.yml","hash":"424a9c1e6ab69334d7873f6574da02ca960aa572","modified":1499966658000},{"_id":"themes/Anisina/languages_to_be_added/default.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1499966658000},{"_id":"themes/Anisina/languages_to_be_added/en.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1499966658000},{"_id":"themes/Anisina/languages_to_be_added/es.yml","hash":"cb4eeca0ed3768a77e0cd216300f2b2549628b1b","modified":1499966658000},{"_id":"themes/Anisina/languages_to_be_added/no.yml","hash":"8ca475a3b4f8efe6603030f0013aae39668230e1","modified":1499966658000},{"_id":"themes/Anisina/languages_to_be_added/pl.yml","hash":"de7eb5850ae65ba7638e907c805fea90617a988c","modified":1499966658000},{"_id":"themes/Anisina/languages_to_be_added/ru.yml","hash":"42df7afeb7a35dc46d272b7f4fb880a9d9ebcaa5","modified":1499966658000},{"_id":"themes/Anisina/languages_to_be_added/zh-CN.yml","hash":"7bfcb0b8e97d7e5edcfca8ab26d55d9da2573c1c","modified":1499966658000},{"_id":"themes/Anisina/languages_to_be_added/zh-TW.yml","hash":"9acac6cc4f8002c3fa53ff69fb8cf66c915bd016","modified":1499966658000},{"_id":"themes/Anisina/layout/.DS_Store","hash":"f60423538e7d115abf8c86b365e85ad35b418b25","modified":1499966658000},{"_id":"themes/Anisina/layout/404.ejs","hash":"1fe05722bd1b32bbe0ae4e3e880866f935e0ae11","modified":1499966658000},{"_id":"themes/Anisina/layout/about.ejs","hash":"d409109a84aa5c032e1a230c973a91b293765176","modified":1499966658000},{"_id":"themes/Anisina/layout/archive.ejs","hash":"7c27826a89ab0b67cd2c6603d8478afbf736a29a","modified":1557049451301},{"_id":"themes/Anisina/layout/index.ejs","hash":"a94ac678f6b24a46824d45ec058b0ab2105a92c9","modified":1499966658000},{"_id":"themes/Anisina/layout/layout.ejs","hash":"b728827bf3ec55baf96a882032397e6c74c65f34","modified":1499966658000},{"_id":"themes/Anisina/layout/page.ejs","hash":"1eced57d2f0d5a74bf6a555bee2534b0ac109c6b","modified":1531295086498},{"_id":"themes/Anisina/layout/poetry.ejs","hash":"6c955d419050825e13d39c780d45aceafbf6552d","modified":1499966658000},{"_id":"themes/Anisina/layout/post.ejs","hash":"9427ac91b2bc36c339b528d9a569c038f0b18efa","modified":1499966658000},{"_id":"themes/Anisina/layout/tags.ejs","hash":"ff363455eeddfd389ecf6c5ab090408e1d2ef4e6","modified":1499966658000},{"_id":"themes/Anisina/layout/works.ejs","hash":"1df954e54098cc4845295836374abed870789dcd","modified":1499966658000},{"_id":"themes/Anisina/source/.DS_Store","hash":"eeeb8c23b4953b984a89138863fd190bc0aa0b87","modified":1557053055608},{"_id":"source/assets/PostImg/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1557058008302},{"_id":"source/assets/PostImg/bf1.jpg","hash":"d2d64080817d6e58e58392325a8e2194c4a7ac5c","modified":1557054326768},{"_id":"source/assets/PostImg/bf2.jpg","hash":"3f5c6eab84f3a18a1525d33427f227f2fa0beb11","modified":1557054326729},{"_id":"source/assets/PostImg/command.png","hash":"c1d39a21c6da08faf88326b73d91a19e82f5ce93","modified":1557054326783},{"_id":"source/assets/PostImg/kmp-accept.png","hash":"14081c5cdea66139849bc5a39542ec0f243a36cc","modified":1557054326816},{"_id":"source/assets/PostImg/login.png","hash":"b78b6313f870683621eb7e0a288bf686a4e6e756","modified":1557054327277},{"_id":"source/assets/PostImg/nginx.png","hash":"14c0726bca9e74bf9f6fa3057669a8fd5ddb3c56","modified":1557054326748},{"_id":"source/assets/PostImg/servlet.png","hash":"f2f8fd847e03fdd132b127db0517a6467a3693b9","modified":1557054327073},{"_id":"source/assets/PostImg/subsets.png","hash":"f76f5bca03459cdb9e3acd3859a6ecd03d724806","modified":1557054327541},{"_id":"source/assets/img/empty.png","hash":"e88177c88f6b7219a3474da7d210965a6dbb57d7","modified":1557054499695},{"_id":"source/assets/img/favicon_bak.ico","hash":"e478d190d9eb2a31693be933fffc3bea44fb1101","modified":1557054499724},{"_id":"source/assets/img/preloader.gif","hash":"ce90ce8d769d5be6093230626ad80a79429c9483","modified":1557054499672},{"_id":"source/assets/video/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1529571000648},{"_id":"source/assets/blogimg/border1px.jpg","hash":"0420ec461cca4d562d28ecb52c673e20ed5b5efd","modified":1557054430288},{"_id":"source/assets/blogimg/aj.jpg","hash":"1957183690793c141551d8462816747f2535c2e1","modified":1557054430279},{"_id":"source/assets/blogimg/browser-history.jpg","hash":"4807eae10a650298165de74cabd663db4fdc80a9","modified":1557054430288},{"_id":"source/assets/blogimg/browser-history2.jpg","hash":"ba8e28e5a92f5ef0b0dd7680855c86a6d08ed89a","modified":1557054430294},{"_id":"source/assets/blogimg/bys0.jpg","hash":"13189f11c0a47bebe902f847b25498121905ea06","modified":1557054430305},{"_id":"source/assets/blogimg/chord2.png","hash":"887d75066aed0dea17a7106c5ea7f85db14fee81","modified":1557054430456},{"_id":"source/assets/blogimg/css_hack.jpg","hash":"81ce16f00b892f9c41d454b49f486fe1a499b574","modified":1557054431038},{"_id":"source/assets/blogimg/diary-1.jpg","hash":"ad3f1c6b63c81ba4e23f3a46cf52289886b0fea0","modified":1557054431009},{"_id":"source/assets/blogimg/diary-13.jpg","hash":"85e645a65087ec987cdd460cce5bfb3b95bc2590","modified":1557054431139},{"_id":"source/assets/blogimg/diary-2.jpg","hash":"bf82fd31abdcfabc230198b71ae46caed3782d16","modified":1557054431420},{"_id":"source/assets/blogimg/diary-3.jpg","hash":"59cfeba08025ab249fffa22e201ebd837670e0f7","modified":1557054431878},{"_id":"source/assets/blogimg/diary-4.jpg","hash":"be3e7f055c4ce413ba7cd5564c2476215ff97e7e","modified":1557054431946},{"_id":"source/assets/blogimg/diary-5.jpg","hash":"69d9333f424a0c6e4752c083dcea0766dc6ca455","modified":1557054431900},{"_id":"source/assets/blogimg/diary-6.jpg","hash":"0a5c34b97bd2d9d4f8bce542d9ee6150b673a885","modified":1557054431860},{"_id":"source/assets/blogimg/dragon.jpg","hash":"f23d5c0a111a774a2bb402f358a845731f1c2b2c","modified":1557054432092},{"_id":"source/assets/blogimg/gulangyu.jpg","hash":"e4419560e7e4d45dfa55a9862c7442016eab3915","modified":1557054432403},{"_id":"source/assets/blogimg/imp_search.jpg","hash":"885b254486a8d2baf15577d7943122306945f972","modified":1557054432483},{"_id":"source/assets/blogimg/immersion.png","hash":"8f667f84dd26d9d5677532c39c9eb69ccdf4a278","modified":1557054432284},{"_id":"source/assets/blogimg/instagram1.jpg","hash":"84cbf6fe4c2fe8b6c856418cd2975fd598a65281","modified":1557054432552},{"_id":"source/assets/blogimg/instagram2.jpg","hash":"a4cb929961c12b111666ae1ea1230d6482cb56bc","modified":1557054432404},{"_id":"source/assets/blogimg/jiugongge1.jpg","hash":"9223ad15733d4071b2559ef6ec6ebbcbeee9e4ee","modified":1557054432601},{"_id":"source/assets/blogimg/jiugongge10.jpg","hash":"d1f6330f64b8577aeed73f904a43768c233c3cd9","modified":1557054432602},{"_id":"source/assets/blogimg/jiugongge2.jpg","hash":"1fd6e7947cfc6ab7f751c2442aa4bc1306bd6499","modified":1557054432709},{"_id":"source/assets/blogimg/jiugongge3.jpg","hash":"e2537012c5c7df607f1974cc798b413b8486e18e","modified":1557054432740},{"_id":"source/assets/blogimg/jiugongge4.jpg","hash":"1bbcea320ded17f83b876f7b64d26451b0a63915","modified":1557054432768},{"_id":"source/assets/blogimg/jiugongge5.jpg","hash":"4a13f660a004a8b36f5e04dfa6337db1573fe3e5","modified":1557054432800},{"_id":"source/assets/blogimg/jiugongge6.jpg","hash":"5b77909b5d28b6bbe2ce8117599effb5f96ddf8d","modified":1557054432846},{"_id":"source/assets/blogimg/jiugongge7.jpg","hash":"6eab8000e513dbd5615b9eea16fe839f8c63af7a","modified":1557054432896},{"_id":"source/assets/blogimg/jiugongge8.jpg","hash":"e68e17cc2893f73f363e9135c3be1a8764304faf","modified":1557054432950},{"_id":"source/assets/blogimg/localstorage1.png","hash":"1ccebaa16ab3c88fa62d91bf0dd9a8747c43aba3","modified":1557054432957},{"_id":"source/assets/blogimg/localstorage2.png","hash":"b09e34bab94c87d03bb72790b96bab2d1e20dbe1","modified":1557054433103},{"_id":"source/assets/blogimg/localstorage3.png","hash":"b3e701d8203abcaeeb115019e2f35ee30be25f44","modified":1557054433106},{"_id":"source/assets/blogimg/localstorage4.png","hash":"bda10b14461d556f15b70326dc87320501bf646a","modified":1557054433426},{"_id":"source/assets/blogimg/nginx1.jpg","hash":"7acada8f9e0c8ddf9177d83f3c726c42e9e8ed7f","modified":1557054433111},{"_id":"source/assets/blogimg/nginx0.jpg","hash":"b119e75f9634059bc249b15663d38a36f5247a83","modified":1557054433159},{"_id":"source/assets/blogimg/nginx2.jpg","hash":"a9bdbb38876347527dd254bbe5fc9293b95681a4","modified":1557054433202},{"_id":"source/assets/blogimg/safety_001.jpg","hash":"2c46d121b9d48dec3887d1a6152b5be8f36ffa5a","modified":1557054433201},{"_id":"source/assets/blogimg/safety_002.jpg","hash":"8bae8fcf815e3d2e981110da29cba056d09b1624","modified":1557054433380},{"_id":"source/assets/blogimg/reduce-http.jpg","hash":"eef2280cbfa634052055dbe392b17255c1100c33","modified":1557054433370},{"_id":"source/assets/blogimg/safety_005.jpg","hash":"9805b83cd5d58a8c7e44436f137342fc1b4907d5","modified":1557054433315},{"_id":"source/assets/blogimg/up1_tips.jpg","hash":"5aa22d5040255d2894c2d82d9c9795a2e5220cb8","modified":1557054433338},{"_id":"source/assets/blogimg/volunteer2.jpg","hash":"f0d7c69f093ac586e1392dbd6cd9d1db3bf65bbe","modified":1557054433572},{"_id":"source/assets/blogimg/volunteer3.jpg","hash":"747348c19264c6bd3845fa422fbc06b8ee7a44b0","modified":1557054433483},{"_id":"source/assets/blogimg/web_worker2.png","hash":"2fe31641f091009b5c44dab5bca3630d1eeece0c","modified":1557054433463},{"_id":"source/assets/blogimg/web_worker1.png","hash":"edadfa118fc8ccc234f4a5366ad091792d5bc1ae","modified":1557054433433},{"_id":"source/assets/blogimg/xbsj-3.jpg","hash":"21934f07d4f82c57ba29256b0d4babd354b46459","modified":1557054433667},{"_id":"source/assets/blogimg/xbsj-1.jpg","hash":"fa21d27fdf95692354056d012ebe8a47bf326190","modified":1557054433690},{"_id":"source/assets/blogimg/xmas_ico2.jpg","hash":"5b1b9cd97308aeddcb5d5e1c78b0c5ab7a4fe270","modified":1557054433650},{"_id":"source/assets/blogimg/xmas_ico1.jpg","hash":"ce1d328d7dee1f306b7679479508c9b7e7c606f6","modified":1557054433632},{"_id":"source/assets/blogimg/xmas_ico3.jpg","hash":"cb1a1bdaa0b2ebf6379a8877c6911a239348b088","modified":1557054433767},{"_id":"themes/Anisina/Screenshots/Anisina.png","hash":"146dd991f55a827a514259e20a51de1e9b07a13d","modified":1499966658000},{"_id":"themes/Anisina/layout/_partial/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1529577124342},{"_id":"themes/Anisina/layout/_partial/footer.ejs","hash":"b088304db2bab4d794df059107bbbd7c7936509d","modified":1531296389969},{"_id":"themes/Anisina/layout/_partial/head.ejs","hash":"5c7805e1a31db4ccd04001c7c484126f8c8a90e1","modified":1529577337964},{"_id":"themes/Anisina/layout/_partial/nav.ejs","hash":"3baa41d595e951efa1db34dd1789c6f8d3b094da","modified":1499966658000},{"_id":"themes/Anisina/layout/_partial/pagination.ejs","hash":"557d6bb069a1d48af49ae912994653f44b32a570","modified":1499966658000},{"_id":"themes/Anisina/source/css/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1529577792069},{"_id":"themes/Anisina/source/css/blog-style.css","hash":"80ab5a3bf6c7be3959fbd6a4e3aceb28a3041ac8","modified":1531042559185},{"_id":"themes/Anisina/source/css/syntax.styl","hash":"921a2130d08915b04a7bf877a155beb0df2cdb7a","modified":1531127902042},{"_id":"themes/Anisina/source/css/font-awesome.css","hash":"7cd5a3384333f95c3d37d9488ad82cd6c4b03761","modified":1529577056074},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1499966658000},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1499966658000},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1499966658000},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1499966658000},{"_id":"themes/Anisina/source/js/blog.js","hash":"0f805c744ef8a48c0abdd9d204cfc19ee6cafc14","modified":1499966658000},{"_id":"themes/Anisina/source/js/bootstrap.min.js","hash":"b3f2ef9f985e7906c9360756b73cd64bf7733647","modified":1499966658000},{"_id":"themes/Anisina/source/js/jquery.tagcloud.js","hash":"4e5fd0b07f3bd935f2e603710447e039e3677211","modified":1499966658000},{"_id":"themes/Anisina/source/js/jump.js","hash":"3cf20d1111904152c7c7e65966276e26b2694d3f","modified":1401958406000},{"_id":"themes/Anisina/source/js/totop.js","hash":"11ede60fccb7c763d6973f80efc78b47c0843746","modified":1499966658000},{"_id":"source/assets/PostImg/ResourceClassDependence.png","hash":"97c018d3ab66c5b6d1536dad056210ceba423558","modified":1557054326879},{"_id":"source/assets/PostImg/git-prosessor.png","hash":"1f0f075778c52dbac12e0f697ad11c3a8a24664b","modified":1557054326926},{"_id":"source/assets/PostImg/securitityManagement.png","hash":"842842712d748bd61797a117ae11cea157218691","modified":1557054327478},{"_id":"source/assets/img/favicon.ico","hash":"af11ae17796fd64ed7e53e67b66692271a4a2953","modified":1557054499819},{"_id":"source/assets/img/log.JPG","hash":"1e22cbb6baa77a2b1c941c0f3ed63fc87a27e641","modified":1557054499967},{"_id":"source/assets/blogimg/changbaishan-1.jpg","hash":"71a8568f83545cf816b0d662bb689b5998a5a581","modified":1557054430333},{"_id":"source/assets/blogimg/changbaishan-2.jpg","hash":"b3d0eb9dba76c45da47f7985f1a2c08b0897a149","modified":1557054430726},{"_id":"source/assets/blogimg/chord1.jpg","hash":"3887fd1d6019503f29baefc378c2cef287705ba8","modified":1557054430859},{"_id":"source/assets/blogimg/ckxt3.jpg","hash":"5cc1b96e85d3d2a8364232fbf85795e4ababe5a6","modified":1557054430901},{"_id":"source/assets/blogimg/css3_anm.jpg","hash":"ed6904c8b7855b00cc88bc57494ad927421e5798","modified":1557054431040},{"_id":"source/assets/blogimg/diary-14.jpg","hash":"4127ee85a5951d75b3ba03e3504a5f8db785ed2a","modified":1557054431316},{"_id":"source/assets/blogimg/diary-16.jpg","hash":"7e52d933d1679058b38910844825e6097d21b3dd","modified":1557054431362},{"_id":"source/assets/blogimg/diary-17.jpg","hash":"4f667f115198a3e392426f2b8842dae14acd3931","modified":1557054431379},{"_id":"source/assets/blogimg/diary-18.jpg","hash":"e8e9f7e7e336e81416af225e26870b56509b9d68","modified":1557054431472},{"_id":"source/assets/blogimg/diary-20.jpg","hash":"160c4e39753702d3ed7328fbffd1fc4c1c1ce006","modified":1557054431460},{"_id":"source/assets/blogimg/diary-21.jpg","hash":"d4096dd08cfd09b48546d6fbfcbd8607573cd522","modified":1557054431674},{"_id":"source/assets/blogimg/diary-29.jpg","hash":"7ca620813d6bdf72b302ce5816df086858cd05e8","modified":1557054431839},{"_id":"source/assets/blogimg/diary-7.jpg","hash":"e36f66b9e8143e48fc1ca4e808ea34fdc2f8270a","modified":1557054432063},{"_id":"source/assets/blogimg/jiugongge9.jpg","hash":"ee834968caa2e1a0ed85b0bde1416617117714ee","modified":1557054432938},{"_id":"source/assets/blogimg/litten.png","hash":"d85c922df98da282ee26db34d32ae89193a6ba06","modified":1557054433005},{"_id":"source/assets/blogimg/mediator1.jpg","hash":"f896c5e53f28463fc05c84d4a576842704a578db","modified":1557054433197},{"_id":"source/assets/blogimg/rabbit.jpg","hash":"ee9595de19d67776c9e423acd5b032ade9be93ef","modified":1557054433274},{"_id":"source/assets/blogimg/volunteer1.jpg","hash":"81ff551fa2b5004f59b03de5e052c64f142f5524","modified":1557054433423},{"_id":"source/assets/blogimg/xbsj-2.jpg","hash":"9f3aceb47643ed9dce5135de03535461afee85e0","modified":1557054433613},{"_id":"source/assets/blogimg/xmas_ico0.jpg","hash":"17dcd786c61d1c69a603a5c7a3ca003ca36a102d","modified":1557054433610},{"_id":"themes/Anisina/Screenshots/poetry-show.png","hash":"f5fdcd25026a87a0aafeebb1f19cdb3c0a81a666","modified":1499966658000},{"_id":"themes/Anisina/source/css/bootstrap.min.css","hash":"c5db932e115ff97af7b4512b947cde3ba2964db8","modified":1499966658000},{"_id":"themes/Anisina/source/fonts/fontawesome-webfont.woff2","hash":"574ea2698c03ae9477db2ea3baf460ee32f1a7ea","modified":1529558470253},{"_id":"themes/Anisina/source/fonts/fontawesome-webfont.woff","hash":"507970402e328b2baeb05bde73bf9ded4e2c3a2d","modified":1529558470252},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.svg","hash":"de51a8494180a6db074af2dee2383f0a363c5b08","modified":1499966658000},{"_id":"themes/Anisina/source/js/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1499966658000},{"_id":"source/assets/PostImg/D2338CFF-0768-4E86-AAAA-9E8305FE381F.png","hash":"210d48d51ce00f696f8c0bb49ad4d4b3a8fc16d8","modified":1557054329231},{"_id":"source/assets/blogimg/ckxt1.jpg","hash":"a184ba933c5757d9dc200b3c056759387242d1cf","modified":1557054431056},{"_id":"source/assets/blogimg/ckxt2.jpg","hash":"f52cfe91b2918bc7d48bcf8dd10f68ea780d29c0","modified":1557054430911},{"_id":"source/assets/blogimg/ckxt4.jpg","hash":"ca93f86e826eaaabe375a5b9d0bf4ad79762f558","modified":1557054430972},{"_id":"source/assets/blogimg/diary-24.jpg","hash":"e2068a598e24992c4792d9b75635f1e0b030b3f4","modified":1557054431618},{"_id":"source/assets/blogimg/diary-27.jpg","hash":"97459800961c48438677de6f247e47f6871f6bb1","modified":1557054431667},{"_id":"source/assets/blogimg/lazyload.jpg","hash":"9e4d4a8b609f0018f4474e849f55eb291ac57d21","modified":1557054433013},{"_id":"themes/Anisina/source/fonts/fontawesome-webfont.ttf","hash":"27cf1f2ec59aece6938c7bb2feb0e287ea778ff9","modified":1529558470251},{"_id":"source/assets/PostImg/BeanFactoryDependence.png","hash":"1aa282a4a7810415426dbbcb7f647d2c2cbb82dd","modified":1557054327191},{"_id":"source/assets/PostImg/Beanfactory.png","hash":"b190b065520c65eff3eef64af5963ed780b43cb8","modified":1557054327056},{"_id":"source/assets/PostImg/applicationContext.png","hash":"06c606cd63cf91bf84ae5041ce2ef70ed4a1857e","modified":1557054327225},{"_id":"source/assets/PostImg/process.png","hash":"544c3974654bd12b8fe1f81f05988b58f5d2bbb4","modified":1557054327016},{"_id":"source/assets/PostImg/shiro-frame.png","hash":"a375c77b6b688503e9b621cfea9be42333f6a5ba","modified":1557054327447},{"_id":"source/assets/blogimg/ckxt0.jpg","hash":"980ebd08b10b0f3b9bf2603dc38d45842cc50d15","modified":1557054430910},{"_id":"source/assets/blogimg/diary-10.jpg","hash":"c9d3517e34d639ad8f8569fc2a72df3d3644729a","modified":1557054431343},{"_id":"source/assets/blogimg/diary-12.jpg","hash":"07fc644f25dac38cb0f1e3bbab9335e628eddf49","modified":1557054431355},{"_id":"source/assets/blogimg/diary-19.jpg","hash":"927758533c4fd742d9f346e3247df23b40848efd","modified":1557054431542},{"_id":"source/assets/blogimg/diary-26.jpg","hash":"adb7b6e3dabacb774a633ae355990d4edf5256d7","modified":1557054431943},{"_id":"source/assets/blogimg/myReader0.jpg","hash":"f1cdd882e84071beee90615e33a98ee84681477b","modified":1557054433348},{"_id":"source/assets/blogimg/safety_004.jpg","hash":"21e015d9445aa594163d5c5ad2cdfbd2d40f234f","modified":1557054433570},{"_id":"source/assets/blogimg/diary-11.jpg","hash":"39d11fbf11c374b6a0699f00b01e042de21bcdfa","modified":1557054431219},{"_id":"source/assets/blogimg/diary-23.jpg","hash":"8b4a185323948d7b98c2a81303fce7fcddd9117c","modified":1557054431855},{"_id":"source/assets/blogimg/safety_003.jpg","hash":"0e611b4b46b6cd60d1a19302cd9035a1a6fb79f6","modified":1557054433617},{"_id":"source/assets/blogimg/diary-28.jpg","hash":"e17e4c88dbbbcbc27886d90a461fc177465885e5","modified":1557054431988},{"_id":"source/assets/blogimg/localstorage5.png","hash":"a688dd7741f74ad1ed16d355457deed9549ec64b","modified":1557054433241},{"_id":"themes/Anisina/Screenshots/mobile-post.jpeg","hash":"2081cdff23a9a8c185a48d9aabcc9dc8e77833ec","modified":1499966658000},{"_id":"themes/Anisina/source/js/jquery.js","hash":"1852661bd11a09ca9b9cb63d1aa6ff390fffaf4e","modified":1499966658000},{"_id":"source/assets/blogimg/lijiang.jpg","hash":"e3d95a8e89a5eef018869daa41b9320441a562e6","modified":1557054433106},{"_id":"themes/Anisina/Screenshots/pc-index.png","hash":"b04094dac75cb656b4244c1dfaf246168a0f8926","modified":1499966658000},{"_id":"source/assets/PostImg/loader.png","hash":"20c308a0262d9efad859d4cbc4ebb0fe2272881d","modified":1557054327179},{"_id":"source/assets/blogimg/BLbaFJDAJ1i.jpg","hash":"c4640041449416b0f21ca706d81c3a836748af7a","modified":1557054430466},{"_id":"source/assets/blogimg/diary-15.jpg","hash":"e9483844bb3c320ab1cf831b022a170d707bc708","modified":1557054431415},{"_id":"source/assets/blogimg/diary-25.jpg","hash":"2a905535d7f4819fff5ecdb63498d8ada762f375","modified":1557054431910},{"_id":"source/assets/blogimg/diary-22.jpg","hash":"a75a472e5c4d8217a3b0a839f978aa5bcc608b78","modified":1557054431807},{"_id":"source/assets/blogimg/diary-9.jpg","hash":"ac6c31bf0ccd4c491e63da6cd198644bda0113f3","modified":1557054432256},{"_id":"source/assets/blogimg/fengshui5.png","hash":"d1a74d626c2ad82f69c17a0dfe17ecf9d760533d","modified":1557054432352},{"_id":"source/assets/PostImg/lake.jpg","hash":"168014a4072c1ba629c19e91b00c7b9d3bc4856d","modified":1557054327068},{"_id":"source/assets/blogimg/fengshui4.png","hash":"e6feb889fff70bb5069f6a5cd543d4fd33d997c4","modified":1557054432891},{"_id":"themes/Anisina/Screenshots/pc-post.png","hash":"cde56c0797b6ff8dd555fb1f8c3f9b21bceaa3be","modified":1499966658000},{"_id":"source/assets/blogimg/fengshui3.png","hash":"dcbf20bd64082b6f1470f3d94c13f5b4d7816fc0","modified":1557054432750},{"_id":"source/assets/blogimg/bys2.jpg","hash":"1f4b1ba179f9f6e85a803e84539d1bd81138183e","modified":1557054431021},{"_id":"source/assets/blogimg/fengshui2.png","hash":"402c18c57c3b3c4381ef39c6053a0790754593b7","modified":1557054432233},{"_id":"source/assets/blogimg/bys3.jpg","hash":"d0edc2212081b8b6f781dac949965b642d428d89","modified":1557054430709},{"_id":"source/assets/blogimg/bys1.jpg","hash":"9806346ffb672dd870133f7b5813ff98153dfb3b","modified":1557054430780},{"_id":"source/assets/blogimg/fengshui6.png","hash":"c98dca4022a941ade6858041a6fc002734874fe7","modified":1557054432845},{"_id":"source/assets/blogimg/fengshui0.png","hash":"df61a30e4eededd65eb6fd8143ef56640cb3f60d","modified":1557054432950},{"_id":"source/assets/blogimg/water.jpg","hash":"aa98b7ce435408ba57a22de44457ad5b5d587569","modified":1557054433873},{"_id":"source/assets/blogimg/fengshui1.png","hash":"277a61dc6364793438f1cc3645a9e4bca29c9361","modified":1557054433198},{"_id":"source/assets/PostImg/dp.jpg","hash":"4640c81affb302b1aadaaff9f2e268ae3c388ad1","modified":1557054328111},{"_id":"source/assets/PostImg/gs.png","hash":"028b1997bf7f52d45d52736f3f1e50aba41d80ee","modified":1557054327741},{"_id":"source/assets/PostImg/aTdxuh3q4b8.png","hash":"e03005168fb55d33397ce839979cffe822297ed7","modified":1557054330850}],"Category":[],"Data":[],"Page":[{"title":"archive","date":"2018-05-22T06:49:15.000Z","layout":"archive","_content":"","source":"archive/index.md","raw":"---\ntitle: archive\ndate: 2018-05-22 14:49:15\nlayout: archive\n---\n","updated":"2018-06-21T08:50:00.510Z","path":"archive/index.html","comments":1,"_id":"cjvayvwes0000m46a6gyyyshr","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2018-05-23T04:37:37.000Z","layout":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2018-05-23 12:37:37\nlayout: tags\n---\n","updated":"2018-06-21T08:50:00.649Z","path":"tags/index.html","comments":1,"_id":"cjvayvwf20002m46agxc7rqoy","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"layout":"post","title":"别说话，摇头","date":"2017-06-02T22:00:00.000Z","author":"Gubaidan","header-img":"/Header/lake.jpg","cdn":"header-on","_content":"\n# People hearing without listening\n\n> <iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=986476&auto=1&height=66\"></iframe>\n\n\n\n<img style=\"width:90%;\" src=\"http://p9n2j0ewi.bkt.clouddn.com/Header/qWPKK3oh794.png\"/>\n\n\n\n","source":"_posts/1-partten.markdown","raw":"---\nlayout: post\ntitle: \"别说话，摇头\"\ndate: 2017-06-03 06:00\nauthor: \"Gubaidan\"\nheader-img: \"/Header/lake.jpg\"\ncdn: 'header-on'\ntags:\n\t- Life\n---\n\n# People hearing without listening\n\n> <iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=986476&auto=1&height=66\"></iframe>\n\n\n\n<img style=\"width:90%;\" src=\"http://p9n2j0ewi.bkt.clouddn.com/Header/qWPKK3oh794.png\"/>\n\n\n\n","slug":"1-partten","published":1,"updated":"2018-07-22T06:04:52.301Z","comments":1,"photos":[],"link":"","_id":"cjvayvwez0001m46ajk5cbox5","content":"<h1 id=\"People-hearing-without-listening\"><a href=\"#People-hearing-without-listening\" class=\"headerlink\" title=\"People hearing without listening\"></a>People hearing without listening</h1><blockquote>\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"86\" src=\"//music.163.com/outchain/player?type=2&id=986476&auto=1&height=66\"></iframe>\n</blockquote>\n<p><img style=\"width:90%;\" src=\"http://p9n2j0ewi.bkt.clouddn.com/Header/qWPKK3oh794.png\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"People-hearing-without-listening\"><a href=\"#People-hearing-without-listening\" class=\"headerlink\" title=\"People hearing without listening\"></a>People hearing without listening</h1><blockquote>\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"86\" src=\"//music.163.com/outchain/player?type=2&id=986476&auto=1&height=66\"></iframe>\n</blockquote>\n<p><img style=\"width:90%;\" src=\"http://p9n2j0ewi.bkt.clouddn.com/Header/qWPKK3oh794.png\"></p>\n"},{"layout":"post","title":"团队开发 - git整理","date":"2017-06-02T22:00:00.000Z","author":"Gubaidan","header-img":"","cdn":"header-on","_content":"### git常见名词整理\n\n\n* Repository：仓库，用于存储项目文件，分为远程和本地仓库，一般将本地仓库代码上传到远程仓库，以便多人合作和代码保存。\n\n* Branch：分支，一个git仓库可以有多个分支，每个分支代表一个工作流程，最后可以合并也可以舍弃，一般默认为master主分支。\n\n* Remote：远程仓库，在git命令行，远程仓库默认名称origin\n\n* 工作区（Working Directory）：是由我们直接控制和编辑代码的地方，也就是我们的编辑环境\n\n* 暂存区Stage）：当我们git add之后，文件就会存放到这里，等待提交。当然这里的数据是可以撤回的。\n\n* 版本库（commit History）：存放已经提交的数据，push操作就是将这里的数据上传到远程仓库，版本库的存在为git添加很多灵活性，在之后的操作中如果想回滚到之前的commit可以在这里根据记录回滚。\n* orogin：默认远程仓库名\n\n### git基本操作：\n\n![git流程](http://epoch-night.oss-cn-hangzhou.aliyuncs.com/PostImg/git-prosessor.png)\n\n#### 一、 git init \n\n```shell\ngit init  //在当前目录初始化一个空的本地仓库\n\ngit init name //在当前目录下新建一个名称为name的文件夹并初始化name这个文件夹为git本地仓库\n\ngit clone url //url 远程仓库地址\n```\n\n#### 二、git add\n\n```shell\ngit add file1 file2 ...   //添加一个或多个文件到暂存区,可以是目录\n\ngit add .  或者 git add --all  //添加当前目录下所有文件到暂存区\n\ngit remote add origin git@github.com:xxxx/xxxx.git //当前git仓库连接到远程仓库\n```\n\n#### 三、git rm\n\n\n```shell\ngit rm file // 把一个文件从暂存区和工作区删除\n\ngit rm * // 当前目录下所有文件从暂存区和工作区删除\n\ngit rm -r dir // 把一个文件夹从暂存区和工作区删除\n\ngit rm --cached file //把一个文件从暂存区删除，但不从工作区删除，只是不希望被版本控制\n\ngit remote rm [name]  //删除远程仓库\n\ngit branch -d [name]  //删除分支\n\ngit push origin :[name] //删除远程为name的分支\n\ngit mv original-name rename //重命名 并放入暂存区\n```\n\n#### 四、git commit\n\n```shell\ngit commit -m \"message\" //提交更改或文件到版本库\n\ngit commit file1 file2 .. -m \"message\" //提交指定文件\n\ngit commit -a  //提交工作区自上次commit之后的变化，直接到仓库区\n\ngit commit --amend -m \"message\" // 如果代码没有任何新变化，则用来改写上一次commit的提交信息\n```\n\n#### 五、git branch\n\n```shell\ngit branch //查看本地所有分支\n\ngit branch -a // 查看本地所有分支及其 远程所有分支\n\ngit branch branch-name //创建分支\n\ngit checkout branch-name //切换分支\n\ngit branch -m name1 name2 //分支改名\n```\n\n\n​\t\n#### 六、git push\n```shell\n所有的修改想要提交到远程仓库必须push，否则修改不生效\n\ngit push origin branch-name //推送更新到远程分支，默认远程主分支 master\n\ngit push origin :branch-name //删除远程分支\n\ngit push -u origin master //加了这个参数后 以后可以直接使用 git push 简化操作 \n```\n\n#### 七、杂项\n\n\n```shell\ngit status //所有变更的文件\n\ngit log //查看当前分支所有历史版本\n\ngit log --stat // commit历史 显示每次提交的所有更改\n\ngit log -S keyword //搜素历史\n\ngit diff //暂存区和工作区差异\n\ngit diff --cached filename //显示暂存区的当前文件和上一次commit差异\n\ngit checkout file  //恢复暂存区文件到工作区\n\ngit checkout [commit] [file] //恢复commit文件到暂存区和工作区\n\ngit reset --hard // 重置暂存区，工作区，回滚到上一次提交\n```\n\n\n​\t\n\n​\t\n\n\n\n\n​\t\n\n\n\n​\t\n\n\n\n\n\n> 参考：[Git 常用命令大全](https://blog.csdn.net/halaoda/article/details/78661334)\n\n","source":"_posts/2017-06-03-git.markdown","raw":"---\nlayout: post\ntitle: \"团队开发 - git整理\"\ndate: 2017-06-03 06:00\nauthor: \"Gubaidan\"\nheader-img: \"\"\ncdn: 'header-on'\ntags:\n\t- git\n---\n### git常见名词整理\n\n\n* Repository：仓库，用于存储项目文件，分为远程和本地仓库，一般将本地仓库代码上传到远程仓库，以便多人合作和代码保存。\n\n* Branch：分支，一个git仓库可以有多个分支，每个分支代表一个工作流程，最后可以合并也可以舍弃，一般默认为master主分支。\n\n* Remote：远程仓库，在git命令行，远程仓库默认名称origin\n\n* 工作区（Working Directory）：是由我们直接控制和编辑代码的地方，也就是我们的编辑环境\n\n* 暂存区Stage）：当我们git add之后，文件就会存放到这里，等待提交。当然这里的数据是可以撤回的。\n\n* 版本库（commit History）：存放已经提交的数据，push操作就是将这里的数据上传到远程仓库，版本库的存在为git添加很多灵活性，在之后的操作中如果想回滚到之前的commit可以在这里根据记录回滚。\n* orogin：默认远程仓库名\n\n### git基本操作：\n\n![git流程](http://epoch-night.oss-cn-hangzhou.aliyuncs.com/PostImg/git-prosessor.png)\n\n#### 一、 git init \n\n```shell\ngit init  //在当前目录初始化一个空的本地仓库\n\ngit init name //在当前目录下新建一个名称为name的文件夹并初始化name这个文件夹为git本地仓库\n\ngit clone url //url 远程仓库地址\n```\n\n#### 二、git add\n\n```shell\ngit add file1 file2 ...   //添加一个或多个文件到暂存区,可以是目录\n\ngit add .  或者 git add --all  //添加当前目录下所有文件到暂存区\n\ngit remote add origin git@github.com:xxxx/xxxx.git //当前git仓库连接到远程仓库\n```\n\n#### 三、git rm\n\n\n```shell\ngit rm file // 把一个文件从暂存区和工作区删除\n\ngit rm * // 当前目录下所有文件从暂存区和工作区删除\n\ngit rm -r dir // 把一个文件夹从暂存区和工作区删除\n\ngit rm --cached file //把一个文件从暂存区删除，但不从工作区删除，只是不希望被版本控制\n\ngit remote rm [name]  //删除远程仓库\n\ngit branch -d [name]  //删除分支\n\ngit push origin :[name] //删除远程为name的分支\n\ngit mv original-name rename //重命名 并放入暂存区\n```\n\n#### 四、git commit\n\n```shell\ngit commit -m \"message\" //提交更改或文件到版本库\n\ngit commit file1 file2 .. -m \"message\" //提交指定文件\n\ngit commit -a  //提交工作区自上次commit之后的变化，直接到仓库区\n\ngit commit --amend -m \"message\" // 如果代码没有任何新变化，则用来改写上一次commit的提交信息\n```\n\n#### 五、git branch\n\n```shell\ngit branch //查看本地所有分支\n\ngit branch -a // 查看本地所有分支及其 远程所有分支\n\ngit branch branch-name //创建分支\n\ngit checkout branch-name //切换分支\n\ngit branch -m name1 name2 //分支改名\n```\n\n\n​\t\n#### 六、git push\n```shell\n所有的修改想要提交到远程仓库必须push，否则修改不生效\n\ngit push origin branch-name //推送更新到远程分支，默认远程主分支 master\n\ngit push origin :branch-name //删除远程分支\n\ngit push -u origin master //加了这个参数后 以后可以直接使用 git push 简化操作 \n```\n\n#### 七、杂项\n\n\n```shell\ngit status //所有变更的文件\n\ngit log //查看当前分支所有历史版本\n\ngit log --stat // commit历史 显示每次提交的所有更改\n\ngit log -S keyword //搜素历史\n\ngit diff //暂存区和工作区差异\n\ngit diff --cached filename //显示暂存区的当前文件和上一次commit差异\n\ngit checkout file  //恢复暂存区文件到工作区\n\ngit checkout [commit] [file] //恢复commit文件到暂存区和工作区\n\ngit reset --hard // 重置暂存区，工作区，回滚到上一次提交\n```\n\n\n​\t\n\n​\t\n\n\n\n\n​\t\n\n\n\n​\t\n\n\n\n\n\n> 参考：[Git 常用命令大全](https://blog.csdn.net/halaoda/article/details/78661334)\n\n","slug":"2017-06-03-git","published":1,"updated":"2019-05-05T12:27:25.171Z","comments":1,"photos":[],"link":"","_id":"cjvayvwf30003m46a8dvi8c2e","content":"<h3 id=\"git常见名词整理\"><a href=\"#git常见名词整理\" class=\"headerlink\" title=\"git常见名词整理\"></a>git常见名词整理</h3><ul>\n<li><p>Repository：仓库，用于存储项目文件，分为远程和本地仓库，一般将本地仓库代码上传到远程仓库，以便多人合作和代码保存。</p>\n</li>\n<li><p>Branch：分支，一个git仓库可以有多个分支，每个分支代表一个工作流程，最后可以合并也可以舍弃，一般默认为master主分支。</p>\n</li>\n<li><p>Remote：远程仓库，在git命令行，远程仓库默认名称origin</p>\n</li>\n<li><p>工作区（Working Directory）：是由我们直接控制和编辑代码的地方，也就是我们的编辑环境</p>\n</li>\n<li><p>暂存区Stage）：当我们git add之后，文件就会存放到这里，等待提交。当然这里的数据是可以撤回的。</p>\n</li>\n<li><p>版本库（commit History）：存放已经提交的数据，push操作就是将这里的数据上传到远程仓库，版本库的存在为git添加很多灵活性，在之后的操作中如果想回滚到之前的commit可以在这里根据记录回滚。</p>\n</li>\n<li>orogin：默认远程仓库名</li>\n</ul>\n<h3 id=\"git基本操作：\"><a href=\"#git基本操作：\" class=\"headerlink\" title=\"git基本操作：\"></a>git基本操作：</h3><p><img src=\"http://epoch-night.oss-cn-hangzhou.aliyuncs.com/PostImg/git-prosessor.png\" alt=\"git流程\"></p>\n<h4 id=\"一、-git-init\"><a href=\"#一、-git-init\" class=\"headerlink\" title=\"一、 git init\"></a>一、 git init</h4><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">git init  //在当前目录初始化一个空的本地仓库</span><br><span class=\"line\"></span><br><span class=\"line\">git init name //在当前目录下新建一个名称为name的文件夹并初始化name这个文件夹为git本地仓库</span><br><span class=\"line\"></span><br><span class=\"line\">git clone url //url 远程仓库地址</span><br></pre></td></tr></table></figure>\n<h4 id=\"二、git-add\"><a href=\"#二、git-add\" class=\"headerlink\" title=\"二、git add\"></a>二、git add</h4><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">git add file1 file2 ...   //添加一个或多个文件到暂存区,可以是目录</span><br><span class=\"line\"></span><br><span class=\"line\">git add .  或者 git add --all  //添加当前目录下所有文件到暂存区</span><br><span class=\"line\"></span><br><span class=\"line\">git remote add origin git@github.com:xxxx/xxxx.git //当前git仓库连接到远程仓库</span><br></pre></td></tr></table></figure>\n<h4 id=\"三、git-rm\"><a href=\"#三、git-rm\" class=\"headerlink\" title=\"三、git rm\"></a>三、git rm</h4><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">git rm file // 把一个文件从暂存区和工作区删除</span><br><span class=\"line\"></span><br><span class=\"line\">git rm * // 当前目录下所有文件从暂存区和工作区删除</span><br><span class=\"line\"></span><br><span class=\"line\">git rm -r dir // 把一个文件夹从暂存区和工作区删除</span><br><span class=\"line\"></span><br><span class=\"line\">git rm --cached file //把一个文件从暂存区删除，但不从工作区删除，只是不希望被版本控制</span><br><span class=\"line\"></span><br><span class=\"line\">git remote rm [name]  //删除远程仓库</span><br><span class=\"line\"></span><br><span class=\"line\">git branch -d [name]  //删除分支</span><br><span class=\"line\"></span><br><span class=\"line\">git push origin :[name] //删除远程为name的分支</span><br><span class=\"line\"></span><br><span class=\"line\">git mv original-name rename //重命名 并放入暂存区</span><br></pre></td></tr></table></figure>\n<h4 id=\"四、git-commit\"><a href=\"#四、git-commit\" class=\"headerlink\" title=\"四、git commit\"></a>四、git commit</h4><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">git commit -m \"message\" //提交更改或文件到版本库</span><br><span class=\"line\"></span><br><span class=\"line\">git commit file1 file2 .. -m \"message\" //提交指定文件</span><br><span class=\"line\"></span><br><span class=\"line\">git commit -a  //提交工作区自上次commit之后的变化，直接到仓库区</span><br><span class=\"line\"></span><br><span class=\"line\">git commit --amend -m \"message\" // 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span><br></pre></td></tr></table></figure>\n<h4 id=\"五、git-branch\"><a href=\"#五、git-branch\" class=\"headerlink\" title=\"五、git branch\"></a>五、git branch</h4><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">git branch //查看本地所有分支</span><br><span class=\"line\"></span><br><span class=\"line\">git branch -a // 查看本地所有分支及其 远程所有分支</span><br><span class=\"line\"></span><br><span class=\"line\">git branch branch-name //创建分支</span><br><span class=\"line\"></span><br><span class=\"line\">git checkout branch-name //切换分支</span><br><span class=\"line\"></span><br><span class=\"line\">git branch -m name1 name2 //分支改名</span><br></pre></td></tr></table></figure>\n<p>​    </p>\n<h4 id=\"六、git-push\"><a href=\"#六、git-push\" class=\"headerlink\" title=\"六、git push\"></a>六、git push</h4><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">所有的修改想要提交到远程仓库必须push，否则修改不生效</span><br><span class=\"line\"></span><br><span class=\"line\">git push origin branch-name //推送更新到远程分支，默认远程主分支 master</span><br><span class=\"line\"></span><br><span class=\"line\">git push origin :branch-name //删除远程分支</span><br><span class=\"line\"></span><br><span class=\"line\">git push -u origin master //加了这个参数后 以后可以直接使用 git push 简化操作</span><br></pre></td></tr></table></figure>\n<h4 id=\"七、杂项\"><a href=\"#七、杂项\" class=\"headerlink\" title=\"七、杂项\"></a>七、杂项</h4><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">git status //所有变更的文件</span><br><span class=\"line\"></span><br><span class=\"line\">git log //查看当前分支所有历史版本</span><br><span class=\"line\"></span><br><span class=\"line\">git log --stat // commit历史 显示每次提交的所有更改</span><br><span class=\"line\"></span><br><span class=\"line\">git log -S keyword //搜素历史</span><br><span class=\"line\"></span><br><span class=\"line\">git diff //暂存区和工作区差异</span><br><span class=\"line\"></span><br><span class=\"line\">git diff --cached filename //显示暂存区的当前文件和上一次commit差异</span><br><span class=\"line\"></span><br><span class=\"line\">git checkout file  //恢复暂存区文件到工作区</span><br><span class=\"line\"></span><br><span class=\"line\">git checkout [commit] [file] //恢复commit文件到暂存区和工作区</span><br><span class=\"line\"></span><br><span class=\"line\">git reset --hard // 重置暂存区，工作区，回滚到上一次提交</span><br></pre></td></tr></table></figure>\n<p>​    </p>\n<p>​    </p>\n<p>​    </p>\n<p>​    </p>\n<blockquote>\n<p>参考：<a href=\"https://blog.csdn.net/halaoda/article/details/78661334\" target=\"_blank\" rel=\"noopener\">Git 常用命令大全</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"git常见名词整理\"><a href=\"#git常见名词整理\" class=\"headerlink\" title=\"git常见名词整理\"></a>git常见名词整理</h3><ul>\n<li><p>Repository：仓库，用于存储项目文件，分为远程和本地仓库，一般将本地仓库代码上传到远程仓库，以便多人合作和代码保存。</p>\n</li>\n<li><p>Branch：分支，一个git仓库可以有多个分支，每个分支代表一个工作流程，最后可以合并也可以舍弃，一般默认为master主分支。</p>\n</li>\n<li><p>Remote：远程仓库，在git命令行，远程仓库默认名称origin</p>\n</li>\n<li><p>工作区（Working Directory）：是由我们直接控制和编辑代码的地方，也就是我们的编辑环境</p>\n</li>\n<li><p>暂存区Stage）：当我们git add之后，文件就会存放到这里，等待提交。当然这里的数据是可以撤回的。</p>\n</li>\n<li><p>版本库（commit History）：存放已经提交的数据，push操作就是将这里的数据上传到远程仓库，版本库的存在为git添加很多灵活性，在之后的操作中如果想回滚到之前的commit可以在这里根据记录回滚。</p>\n</li>\n<li>orogin：默认远程仓库名</li>\n</ul>\n<h3 id=\"git基本操作：\"><a href=\"#git基本操作：\" class=\"headerlink\" title=\"git基本操作：\"></a>git基本操作：</h3><p><img src=\"http://epoch-night.oss-cn-hangzhou.aliyuncs.com/PostImg/git-prosessor.png\" alt=\"git流程\"></p>\n<h4 id=\"一、-git-init\"><a href=\"#一、-git-init\" class=\"headerlink\" title=\"一、 git init\"></a>一、 git init</h4><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">git init  //在当前目录初始化一个空的本地仓库</span><br><span class=\"line\"></span><br><span class=\"line\">git init name //在当前目录下新建一个名称为name的文件夹并初始化name这个文件夹为git本地仓库</span><br><span class=\"line\"></span><br><span class=\"line\">git clone url //url 远程仓库地址</span><br></pre></td></tr></table></figure>\n<h4 id=\"二、git-add\"><a href=\"#二、git-add\" class=\"headerlink\" title=\"二、git add\"></a>二、git add</h4><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">git add file1 file2 ...   //添加一个或多个文件到暂存区,可以是目录</span><br><span class=\"line\"></span><br><span class=\"line\">git add .  或者 git add --all  //添加当前目录下所有文件到暂存区</span><br><span class=\"line\"></span><br><span class=\"line\">git remote add origin git@github.com:xxxx/xxxx.git //当前git仓库连接到远程仓库</span><br></pre></td></tr></table></figure>\n<h4 id=\"三、git-rm\"><a href=\"#三、git-rm\" class=\"headerlink\" title=\"三、git rm\"></a>三、git rm</h4><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">git rm file // 把一个文件从暂存区和工作区删除</span><br><span class=\"line\"></span><br><span class=\"line\">git rm * // 当前目录下所有文件从暂存区和工作区删除</span><br><span class=\"line\"></span><br><span class=\"line\">git rm -r dir // 把一个文件夹从暂存区和工作区删除</span><br><span class=\"line\"></span><br><span class=\"line\">git rm --cached file //把一个文件从暂存区删除，但不从工作区删除，只是不希望被版本控制</span><br><span class=\"line\"></span><br><span class=\"line\">git remote rm [name]  //删除远程仓库</span><br><span class=\"line\"></span><br><span class=\"line\">git branch -d [name]  //删除分支</span><br><span class=\"line\"></span><br><span class=\"line\">git push origin :[name] //删除远程为name的分支</span><br><span class=\"line\"></span><br><span class=\"line\">git mv original-name rename //重命名 并放入暂存区</span><br></pre></td></tr></table></figure>\n<h4 id=\"四、git-commit\"><a href=\"#四、git-commit\" class=\"headerlink\" title=\"四、git commit\"></a>四、git commit</h4><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">git commit -m \"message\" //提交更改或文件到版本库</span><br><span class=\"line\"></span><br><span class=\"line\">git commit file1 file2 .. -m \"message\" //提交指定文件</span><br><span class=\"line\"></span><br><span class=\"line\">git commit -a  //提交工作区自上次commit之后的变化，直接到仓库区</span><br><span class=\"line\"></span><br><span class=\"line\">git commit --amend -m \"message\" // 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span><br></pre></td></tr></table></figure>\n<h4 id=\"五、git-branch\"><a href=\"#五、git-branch\" class=\"headerlink\" title=\"五、git branch\"></a>五、git branch</h4><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">git branch //查看本地所有分支</span><br><span class=\"line\"></span><br><span class=\"line\">git branch -a // 查看本地所有分支及其 远程所有分支</span><br><span class=\"line\"></span><br><span class=\"line\">git branch branch-name //创建分支</span><br><span class=\"line\"></span><br><span class=\"line\">git checkout branch-name //切换分支</span><br><span class=\"line\"></span><br><span class=\"line\">git branch -m name1 name2 //分支改名</span><br></pre></td></tr></table></figure>\n<p>​    </p>\n<h4 id=\"六、git-push\"><a href=\"#六、git-push\" class=\"headerlink\" title=\"六、git push\"></a>六、git push</h4><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">所有的修改想要提交到远程仓库必须push，否则修改不生效</span><br><span class=\"line\"></span><br><span class=\"line\">git push origin branch-name //推送更新到远程分支，默认远程主分支 master</span><br><span class=\"line\"></span><br><span class=\"line\">git push origin :branch-name //删除远程分支</span><br><span class=\"line\"></span><br><span class=\"line\">git push -u origin master //加了这个参数后 以后可以直接使用 git push 简化操作</span><br></pre></td></tr></table></figure>\n<h4 id=\"七、杂项\"><a href=\"#七、杂项\" class=\"headerlink\" title=\"七、杂项\"></a>七、杂项</h4><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">git status //所有变更的文件</span><br><span class=\"line\"></span><br><span class=\"line\">git log //查看当前分支所有历史版本</span><br><span class=\"line\"></span><br><span class=\"line\">git log --stat // commit历史 显示每次提交的所有更改</span><br><span class=\"line\"></span><br><span class=\"line\">git log -S keyword //搜素历史</span><br><span class=\"line\"></span><br><span class=\"line\">git diff //暂存区和工作区差异</span><br><span class=\"line\"></span><br><span class=\"line\">git diff --cached filename //显示暂存区的当前文件和上一次commit差异</span><br><span class=\"line\"></span><br><span class=\"line\">git checkout file  //恢复暂存区文件到工作区</span><br><span class=\"line\"></span><br><span class=\"line\">git checkout [commit] [file] //恢复commit文件到暂存区和工作区</span><br><span class=\"line\"></span><br><span class=\"line\">git reset --hard // 重置暂存区，工作区，回滚到上一次提交</span><br></pre></td></tr></table></figure>\n<p>​    </p>\n<p>​    </p>\n<p>​    </p>\n<p>​    </p>\n<blockquote>\n<p>参考：<a href=\"https://blog.csdn.net/halaoda/article/details/78661334\" target=\"_blank\" rel=\"noopener\">Git 常用命令大全</a></p>\n</blockquote>\n"},{"layout":"post","title":"编写mac、Linux下 .sh启动脚本","date":"2017-06-04T14:06:00.000Z","author":"Gubaidan","header-img":"/Header/lake.jpg","cdn":"header-on","_content":"# 背景\n\n因为电脑中装了很多非图形化应用程序，例如nginx，zoonkeeper、ActivityMQ等，每次都忘了这些应用装在了哪里，就算记得在那个目录下还是要cd 到指定目录启动，所以写了几个脚本用于启动这些服务。\n\n1. 在任意文件夹下新建 .sh 文件，然后赋予文件执行权限和读写权限，为了方便暂时给予777权限，如：\n\n   ```sh\n   touch nginx.sh\n   sudo chmod 777 nginx.sh\n   ```\n\n2. 找到nginx服务所在目录，pwd命令获得全路径\n\n   ```sh\n   MacBook-Gu:bin gubaidan$ pwd\n   /usr/local/Cellar/nginx/1.13.12/bin    //全路径\n   MacBook-Gu:bin gubaidan$ \n   ```\n\n3. vim nginx.sh编写脚本\n\n   ```sh\n   #! /bin/bash \n   while true; do\n     echo  \" ------------------------------- \"\n     echo  \"            \"\n     echo  \"1.Start Nginx\"      //开启服务\n     echo  \"2.Stop Nginx\"\t\t//停止服务\n     echo  \"3.Check Conf\"\t\t//查看配置\n     echo  \"4.Nginx Reload\"\t//重启\n     echo  \"5.Nginx Status\"\t//查看状态\n     echo  \"6.Quit\"\t\t\t//退出\n     echo  -n \"Choice Option:\"   \n     read tag                //读取输入\n   \n     if [[ $tag = \"1\" ]]; then\n       cd /usr/local/Cellar/nginx/1.13.12/bin\n       echo 'xxxx'|sudo -S nginx    \t//管道免密操作 xxxx为sudo密码\n     fi\n   \n     if [[ $tag = \"2\" ]]; then\n        cd /usr/local/Cellar/nginx/1.13.12/bin\n        echo 'xxxx'|sudo -S nginx -s stop\n     fi\n   \n     if [[ $tag = \"3\" ]]; then\n        cd /usr/local/Cellar/nginx/1.13.12/bin\n        echo 'xxxx'|sudo nginx -t\n     fi\n   \n     if [[ $tag = \"4\" ]]; then\n        cd /usr/local/Cellar/nginx/1.13.12/bin\n        echo 'xxxx'|sudo nginx -s reload\n     fi\n   \n     if [[ $tag = \"5\" ]]; then\n        ps -ef | grep nginx\n     fi\n   \n     if [[ $tag = \"6\" ]]; then\n        break;\n     fi\n   \n     echo  \"            \"\n     echo  \"Nginx Deal Success\"\n     echo  \"            \"\n   \n   \n   done\n   ```\n\n4. 运行\n\n   ```\n   ./nginx.sh          //在nginx.sh目录下运行\n   ```\n\n5. 效果\n\n   ![sh](http://epoch-night.oss-cn-hangzhou.aliyuncs.com/PostImg/nginx.png)\n\n6. mac可以把.sh文件后缀改为.command，这样双击就可以直接运行。\n\n   ![command](http://epoch-night.oss-cn-hangzhou.aliyuncs.com/PostImg/command.png)","source":"_posts/2017-06-04-sh.markdown","raw":"---\nlayout: post\ntitle: \"编写mac、Linux下 .sh启动脚本\"\ndate: 2017-06-04 22:06\nauthor: \"Gubaidan\"\nheader-img: \"/Header/lake.jpg\"\ncdn: 'header-on'\ntags:\n\t- shell\n---\n# 背景\n\n因为电脑中装了很多非图形化应用程序，例如nginx，zoonkeeper、ActivityMQ等，每次都忘了这些应用装在了哪里，就算记得在那个目录下还是要cd 到指定目录启动，所以写了几个脚本用于启动这些服务。\n\n1. 在任意文件夹下新建 .sh 文件，然后赋予文件执行权限和读写权限，为了方便暂时给予777权限，如：\n\n   ```sh\n   touch nginx.sh\n   sudo chmod 777 nginx.sh\n   ```\n\n2. 找到nginx服务所在目录，pwd命令获得全路径\n\n   ```sh\n   MacBook-Gu:bin gubaidan$ pwd\n   /usr/local/Cellar/nginx/1.13.12/bin    //全路径\n   MacBook-Gu:bin gubaidan$ \n   ```\n\n3. vim nginx.sh编写脚本\n\n   ```sh\n   #! /bin/bash \n   while true; do\n     echo  \" ------------------------------- \"\n     echo  \"            \"\n     echo  \"1.Start Nginx\"      //开启服务\n     echo  \"2.Stop Nginx\"\t\t//停止服务\n     echo  \"3.Check Conf\"\t\t//查看配置\n     echo  \"4.Nginx Reload\"\t//重启\n     echo  \"5.Nginx Status\"\t//查看状态\n     echo  \"6.Quit\"\t\t\t//退出\n     echo  -n \"Choice Option:\"   \n     read tag                //读取输入\n   \n     if [[ $tag = \"1\" ]]; then\n       cd /usr/local/Cellar/nginx/1.13.12/bin\n       echo 'xxxx'|sudo -S nginx    \t//管道免密操作 xxxx为sudo密码\n     fi\n   \n     if [[ $tag = \"2\" ]]; then\n        cd /usr/local/Cellar/nginx/1.13.12/bin\n        echo 'xxxx'|sudo -S nginx -s stop\n     fi\n   \n     if [[ $tag = \"3\" ]]; then\n        cd /usr/local/Cellar/nginx/1.13.12/bin\n        echo 'xxxx'|sudo nginx -t\n     fi\n   \n     if [[ $tag = \"4\" ]]; then\n        cd /usr/local/Cellar/nginx/1.13.12/bin\n        echo 'xxxx'|sudo nginx -s reload\n     fi\n   \n     if [[ $tag = \"5\" ]]; then\n        ps -ef | grep nginx\n     fi\n   \n     if [[ $tag = \"6\" ]]; then\n        break;\n     fi\n   \n     echo  \"            \"\n     echo  \"Nginx Deal Success\"\n     echo  \"            \"\n   \n   \n   done\n   ```\n\n4. 运行\n\n   ```\n   ./nginx.sh          //在nginx.sh目录下运行\n   ```\n\n5. 效果\n\n   ![sh](http://epoch-night.oss-cn-hangzhou.aliyuncs.com/PostImg/nginx.png)\n\n6. mac可以把.sh文件后缀改为.command，这样双击就可以直接运行。\n\n   ![command](http://epoch-night.oss-cn-hangzhou.aliyuncs.com/PostImg/command.png)","slug":"2017-06-04-sh","published":1,"updated":"2019-05-05T12:28:38.827Z","comments":1,"photos":[],"link":"","_id":"cjvayvwf60005m46aaeibyhr3","content":"<h1 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h1><p>因为电脑中装了很多非图形化应用程序，例如nginx，zoonkeeper、ActivityMQ等，每次都忘了这些应用装在了哪里，就算记得在那个目录下还是要cd 到指定目录启动，所以写了几个脚本用于启动这些服务。</p>\n<ol>\n<li><p>在任意文件夹下新建 .sh 文件，然后赋予文件执行权限和读写权限，为了方便暂时给予777权限，如：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">touch nginx.sh</span><br><span class=\"line\">sudo chmod 777 nginx.sh</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>找到nginx服务所在目录，pwd命令获得全路径</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">MacBook-Gu:bin gubaidan$ <span class=\"built_in\">pwd</span></span><br><span class=\"line\">/usr/<span class=\"built_in\">local</span>/Cellar/nginx/1.13.12/bin    //全路径</span><br><span class=\"line\">MacBook-Gu:bin gubaidan$</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>vim nginx.sh编写脚本</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#! /bin/bash </span></span><br><span class=\"line\"><span class=\"keyword\">while</span> <span class=\"literal\">true</span>; <span class=\"keyword\">do</span></span><br><span class=\"line\">  <span class=\"built_in\">echo</span>  <span class=\"string\">\" ------------------------------- \"</span></span><br><span class=\"line\">  <span class=\"built_in\">echo</span>  <span class=\"string\">\"            \"</span></span><br><span class=\"line\">  <span class=\"built_in\">echo</span>  <span class=\"string\">\"1.Start Nginx\"</span>      //开启服务</span><br><span class=\"line\">  <span class=\"built_in\">echo</span>  <span class=\"string\">\"2.Stop Nginx\"</span>\t\t//停止服务</span><br><span class=\"line\">  <span class=\"built_in\">echo</span>  <span class=\"string\">\"3.Check Conf\"</span>\t\t//查看配置</span><br><span class=\"line\">  <span class=\"built_in\">echo</span>  <span class=\"string\">\"4.Nginx Reload\"</span>\t//重启</span><br><span class=\"line\">  <span class=\"built_in\">echo</span>  <span class=\"string\">\"5.Nginx Status\"</span>\t//查看状态</span><br><span class=\"line\">  <span class=\"built_in\">echo</span>  <span class=\"string\">\"6.Quit\"</span>\t\t\t//退出</span><br><span class=\"line\">  <span class=\"built_in\">echo</span>  -n <span class=\"string\">\"Choice Option:\"</span>   </span><br><span class=\"line\">  <span class=\"built_in\">read</span> tag                //读取输入</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> [[ <span class=\"variable\">$tag</span> = <span class=\"string\">\"1\"</span> ]]; <span class=\"keyword\">then</span></span><br><span class=\"line\">    <span class=\"built_in\">cd</span> /usr/<span class=\"built_in\">local</span>/Cellar/nginx/1.13.12/bin</span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">'xxxx'</span>|sudo -S nginx    \t//管道免密操作 xxxx为sudo密码</span><br><span class=\"line\">  <span class=\"keyword\">fi</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> [[ <span class=\"variable\">$tag</span> = <span class=\"string\">\"2\"</span> ]]; <span class=\"keyword\">then</span></span><br><span class=\"line\">     <span class=\"built_in\">cd</span> /usr/<span class=\"built_in\">local</span>/Cellar/nginx/1.13.12/bin</span><br><span class=\"line\">     <span class=\"built_in\">echo</span> <span class=\"string\">'xxxx'</span>|sudo -S nginx -s stop</span><br><span class=\"line\">  <span class=\"keyword\">fi</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> [[ <span class=\"variable\">$tag</span> = <span class=\"string\">\"3\"</span> ]]; <span class=\"keyword\">then</span></span><br><span class=\"line\">     <span class=\"built_in\">cd</span> /usr/<span class=\"built_in\">local</span>/Cellar/nginx/1.13.12/bin</span><br><span class=\"line\">     <span class=\"built_in\">echo</span> <span class=\"string\">'xxxx'</span>|sudo nginx -t</span><br><span class=\"line\">  <span class=\"keyword\">fi</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> [[ <span class=\"variable\">$tag</span> = <span class=\"string\">\"4\"</span> ]]; <span class=\"keyword\">then</span></span><br><span class=\"line\">     <span class=\"built_in\">cd</span> /usr/<span class=\"built_in\">local</span>/Cellar/nginx/1.13.12/bin</span><br><span class=\"line\">     <span class=\"built_in\">echo</span> <span class=\"string\">'xxxx'</span>|sudo nginx -s reload</span><br><span class=\"line\">  <span class=\"keyword\">fi</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> [[ <span class=\"variable\">$tag</span> = <span class=\"string\">\"5\"</span> ]]; <span class=\"keyword\">then</span></span><br><span class=\"line\">     ps -ef | grep nginx</span><br><span class=\"line\">  <span class=\"keyword\">fi</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> [[ <span class=\"variable\">$tag</span> = <span class=\"string\">\"6\"</span> ]]; <span class=\"keyword\">then</span></span><br><span class=\"line\">     <span class=\"built_in\">break</span>;</span><br><span class=\"line\">  <span class=\"keyword\">fi</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">echo</span>  <span class=\"string\">\"            \"</span></span><br><span class=\"line\">  <span class=\"built_in\">echo</span>  <span class=\"string\">\"Nginx Deal Success\"</span></span><br><span class=\"line\">  <span class=\"built_in\">echo</span>  <span class=\"string\">\"            \"</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>运行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">./nginx.sh          //在nginx.sh目录下运行</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>效果</p>\n<p><img src=\"http://epoch-night.oss-cn-hangzhou.aliyuncs.com/PostImg/nginx.png\" alt=\"sh\"></p>\n</li>\n<li><p>mac可以把.sh文件后缀改为.command，这样双击就可以直接运行。</p>\n<p><img src=\"http://epoch-night.oss-cn-hangzhou.aliyuncs.com/PostImg/command.png\" alt=\"command\"></p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h1><p>因为电脑中装了很多非图形化应用程序，例如nginx，zoonkeeper、ActivityMQ等，每次都忘了这些应用装在了哪里，就算记得在那个目录下还是要cd 到指定目录启动，所以写了几个脚本用于启动这些服务。</p>\n<ol>\n<li><p>在任意文件夹下新建 .sh 文件，然后赋予文件执行权限和读写权限，为了方便暂时给予777权限，如：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">touch nginx.sh</span><br><span class=\"line\">sudo chmod 777 nginx.sh</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>找到nginx服务所在目录，pwd命令获得全路径</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">MacBook-Gu:bin gubaidan$ <span class=\"built_in\">pwd</span></span><br><span class=\"line\">/usr/<span class=\"built_in\">local</span>/Cellar/nginx/1.13.12/bin    //全路径</span><br><span class=\"line\">MacBook-Gu:bin gubaidan$</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>vim nginx.sh编写脚本</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#! /bin/bash </span></span><br><span class=\"line\"><span class=\"keyword\">while</span> <span class=\"literal\">true</span>; <span class=\"keyword\">do</span></span><br><span class=\"line\">  <span class=\"built_in\">echo</span>  <span class=\"string\">\" ------------------------------- \"</span></span><br><span class=\"line\">  <span class=\"built_in\">echo</span>  <span class=\"string\">\"            \"</span></span><br><span class=\"line\">  <span class=\"built_in\">echo</span>  <span class=\"string\">\"1.Start Nginx\"</span>      //开启服务</span><br><span class=\"line\">  <span class=\"built_in\">echo</span>  <span class=\"string\">\"2.Stop Nginx\"</span>\t\t//停止服务</span><br><span class=\"line\">  <span class=\"built_in\">echo</span>  <span class=\"string\">\"3.Check Conf\"</span>\t\t//查看配置</span><br><span class=\"line\">  <span class=\"built_in\">echo</span>  <span class=\"string\">\"4.Nginx Reload\"</span>\t//重启</span><br><span class=\"line\">  <span class=\"built_in\">echo</span>  <span class=\"string\">\"5.Nginx Status\"</span>\t//查看状态</span><br><span class=\"line\">  <span class=\"built_in\">echo</span>  <span class=\"string\">\"6.Quit\"</span>\t\t\t//退出</span><br><span class=\"line\">  <span class=\"built_in\">echo</span>  -n <span class=\"string\">\"Choice Option:\"</span>   </span><br><span class=\"line\">  <span class=\"built_in\">read</span> tag                //读取输入</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> [[ <span class=\"variable\">$tag</span> = <span class=\"string\">\"1\"</span> ]]; <span class=\"keyword\">then</span></span><br><span class=\"line\">    <span class=\"built_in\">cd</span> /usr/<span class=\"built_in\">local</span>/Cellar/nginx/1.13.12/bin</span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">'xxxx'</span>|sudo -S nginx    \t//管道免密操作 xxxx为sudo密码</span><br><span class=\"line\">  <span class=\"keyword\">fi</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> [[ <span class=\"variable\">$tag</span> = <span class=\"string\">\"2\"</span> ]]; <span class=\"keyword\">then</span></span><br><span class=\"line\">     <span class=\"built_in\">cd</span> /usr/<span class=\"built_in\">local</span>/Cellar/nginx/1.13.12/bin</span><br><span class=\"line\">     <span class=\"built_in\">echo</span> <span class=\"string\">'xxxx'</span>|sudo -S nginx -s stop</span><br><span class=\"line\">  <span class=\"keyword\">fi</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> [[ <span class=\"variable\">$tag</span> = <span class=\"string\">\"3\"</span> ]]; <span class=\"keyword\">then</span></span><br><span class=\"line\">     <span class=\"built_in\">cd</span> /usr/<span class=\"built_in\">local</span>/Cellar/nginx/1.13.12/bin</span><br><span class=\"line\">     <span class=\"built_in\">echo</span> <span class=\"string\">'xxxx'</span>|sudo nginx -t</span><br><span class=\"line\">  <span class=\"keyword\">fi</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> [[ <span class=\"variable\">$tag</span> = <span class=\"string\">\"4\"</span> ]]; <span class=\"keyword\">then</span></span><br><span class=\"line\">     <span class=\"built_in\">cd</span> /usr/<span class=\"built_in\">local</span>/Cellar/nginx/1.13.12/bin</span><br><span class=\"line\">     <span class=\"built_in\">echo</span> <span class=\"string\">'xxxx'</span>|sudo nginx -s reload</span><br><span class=\"line\">  <span class=\"keyword\">fi</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> [[ <span class=\"variable\">$tag</span> = <span class=\"string\">\"5\"</span> ]]; <span class=\"keyword\">then</span></span><br><span class=\"line\">     ps -ef | grep nginx</span><br><span class=\"line\">  <span class=\"keyword\">fi</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> [[ <span class=\"variable\">$tag</span> = <span class=\"string\">\"6\"</span> ]]; <span class=\"keyword\">then</span></span><br><span class=\"line\">     <span class=\"built_in\">break</span>;</span><br><span class=\"line\">  <span class=\"keyword\">fi</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">echo</span>  <span class=\"string\">\"            \"</span></span><br><span class=\"line\">  <span class=\"built_in\">echo</span>  <span class=\"string\">\"Nginx Deal Success\"</span></span><br><span class=\"line\">  <span class=\"built_in\">echo</span>  <span class=\"string\">\"            \"</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>运行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">./nginx.sh          //在nginx.sh目录下运行</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>效果</p>\n<p><img src=\"http://epoch-night.oss-cn-hangzhou.aliyuncs.com/PostImg/nginx.png\" alt=\"sh\"></p>\n</li>\n<li><p>mac可以把.sh文件后缀改为.command，这样双击就可以直接运行。</p>\n<p><img src=\"http://epoch-night.oss-cn-hangzhou.aliyuncs.com/PostImg/command.png\" alt=\"command\"></p>\n</li>\n</ol>\n"},{"layout":"post","title":"移动端html5 1px border的实现","date":"2017-08-22T12:11:00.000Z","author":"Gubaidan","header-img":"","cdn":"header-on","_content":"\n\n\n<!-- more -->\n### 一、真正的1px边框\n\n做完APP前端后大师兄就告诉我h5上的边框线太粗,把整站都给拉low了. 当时工期紧就没太在意1px粗细, 后面的版本针对这个问题做了些尝试, 这里总结下1px细线的处理方法，因为这已是最细的边框，电脑上清楚的显示，我已经设置了1px的border。\n\n于是为了寻找在移动端看起来像真正1px 的border，搜集一堆资料后还真找到了方案：\n\n- **父元素设置**：scale(0.5,0.5)                 \n- **子元素设置**：scale(2,2) 还原缩放，origin都是基于左上角（0,0）/left top\n\n这样父元素的border其实被缩放了，无疑更细。\n\n### 二、通用方案\n\n用一个css类去为block元素添加更细的border\n\n```css\ncss\n.border-1px{\n  position: relative;\n  &:before, &:after{\n    border-top: 1px solid #c8c7cc;\n    content: ' ';\n    display: block;\n    width: 100%;\n    position: absolute;\n    left: 0;\n  }\n  &:before{\n    top: 0;\n  }\n  &:after{\n    bottom: 0;\n  }\n}\n```\n\n适应移动设备：\n\n\n```css\ncss\n@media (-webkit-min-device-pixel-ratio:1.5), (min-device-pixel-ratio: 1.5){\n  .border-1px{\n    &::after, &::before{\n      -webkit-transform: scaleY(.7);\n      -webkit-transform-origin: 0 0;\n      transform: scaleY(.7);\n    }\n    &::after{\n      -webkit-transform-origin: left bottom;\n    }\n  }\n}\n\n@media (-webkit-min-device-pixel-ratio:2), (min-device-pixel-ratio: 2){\n  .border-1px{\n    &::after, &::before{\n      -webkit-transform: scaleY(.5);\n      transform: scaleY(.5);\n    }\n  }\n}\n```\n\n\n### 三、简易方案\n\n```css\ncss\n.line {position:relative;}\n.line:after {\n\twidth:200%;\n\theight:200%;\n\tposition:absolute;\n\ttop:0;\n\tleft:0;\n\tz-index:0;content:\"\";\n\t-webkit-transform:scale(0.5);\n\t-webkit-transform-origin:0 0;\n\ttransform:scale(0.5);\n\ttransform-origin:0 0;\n\tbox-sizing:border-box;\n}\n.list {\n\twidth:100%;\n\tmargin:auto;\n\tlist-style:none;\n\tpadding:5px 20px;\n}\n.list:after {\n\tborder:1px solid #ccc;\n\tborder-radius:10px;\n}\n.item {padding:0px;}\n.item:after {border-bottom:1px solid #ccc;}\n.item:last-child:after {display:none;}\n```\n\n如此调用\n\n```css\n<div class=\"item line\"></div>\n```\n\n这种方式适合某个元素下方需要有一条极细的border\n\n### 四、对比\n\n上图是原生1px，下图是解决后的效果                \n![与原生方案对比](http://epoch-night.oss-cn-hangzhou.aliyuncs.com/blogimg/border1px.jpg)  \n\n### 五、产生差别的原因\n\n> 为什么移动端css里面写了1px, 实际看起来比1px粗. 其实原因很好理解:这2个'px' 的含义是不一样的. 移动端 html 的 header 总会有一句\n\n\n```css\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no\">\n```\n\n\n> 这句话定义了本页面的 viewport 的宽度为设备宽度,初始缩放值和最大缩放值都为1,并禁止了用户缩放. viewport 通俗的讲是浏览器上可用来显示页面的区域, 这个区域是可能比屏幕大的。\n\n\n>手机存在一个能完美适配的理想viewport, 分辨率相差很大的手机的理想viewport的宽度可能是一样的, 这样做的目的是为了保证同样的css在不同屏幕下的显示效果是一致的, 上面的meta实际上是设置了ideal viewport的宽度.\n\n\n>以实际举例: iphone3 和 iphone4 的屏幕宽度分别是 320px, 640px, 但是它们的 ideal viewport 的宽度都是 320px, 设置了设备宽度后, 320px 宽的元素都能 100% 的填充满屏幕宽. 不同手机的 ideal viewpor t宽度是不一样的, 常见的有 320px, 360px, 384px. iphone 系列的这个值在 6 之前都是 320px, 控制 viewport 的好处就在于一套 css 可以适配多个机型.\n\n\n>因此, viewport 的设置和屏幕物理分辨率是按比例而不是相同的. 移动端 window 对象有个 devicePixelRatio 属性, 它表示设备物理像素和 css 像素的比例, 在 retina 屏的 iphone 手机上, 这个值为 2 或 3, css 里写的 1px 长度映射到物理像素上就有 2px 或 3px 那么长.\n\n\n\n","source":"_posts/2017-08-22-thin-border.markdown","raw":"---\nlayout: post\ntitle: \"移动端html5 1px border的实现\"\ndate: 2017-08-22 20:11\nauthor: \"Gubaidan\"\nheader-img: \"\"\ncdn: 'header-on'\ntags: \n  - css3 \n---\n\n\n\n<!-- more -->\n### 一、真正的1px边框\n\n做完APP前端后大师兄就告诉我h5上的边框线太粗,把整站都给拉low了. 当时工期紧就没太在意1px粗细, 后面的版本针对这个问题做了些尝试, 这里总结下1px细线的处理方法，因为这已是最细的边框，电脑上清楚的显示，我已经设置了1px的border。\n\n于是为了寻找在移动端看起来像真正1px 的border，搜集一堆资料后还真找到了方案：\n\n- **父元素设置**：scale(0.5,0.5)                 \n- **子元素设置**：scale(2,2) 还原缩放，origin都是基于左上角（0,0）/left top\n\n这样父元素的border其实被缩放了，无疑更细。\n\n### 二、通用方案\n\n用一个css类去为block元素添加更细的border\n\n```css\ncss\n.border-1px{\n  position: relative;\n  &:before, &:after{\n    border-top: 1px solid #c8c7cc;\n    content: ' ';\n    display: block;\n    width: 100%;\n    position: absolute;\n    left: 0;\n  }\n  &:before{\n    top: 0;\n  }\n  &:after{\n    bottom: 0;\n  }\n}\n```\n\n适应移动设备：\n\n\n```css\ncss\n@media (-webkit-min-device-pixel-ratio:1.5), (min-device-pixel-ratio: 1.5){\n  .border-1px{\n    &::after, &::before{\n      -webkit-transform: scaleY(.7);\n      -webkit-transform-origin: 0 0;\n      transform: scaleY(.7);\n    }\n    &::after{\n      -webkit-transform-origin: left bottom;\n    }\n  }\n}\n\n@media (-webkit-min-device-pixel-ratio:2), (min-device-pixel-ratio: 2){\n  .border-1px{\n    &::after, &::before{\n      -webkit-transform: scaleY(.5);\n      transform: scaleY(.5);\n    }\n  }\n}\n```\n\n\n### 三、简易方案\n\n```css\ncss\n.line {position:relative;}\n.line:after {\n\twidth:200%;\n\theight:200%;\n\tposition:absolute;\n\ttop:0;\n\tleft:0;\n\tz-index:0;content:\"\";\n\t-webkit-transform:scale(0.5);\n\t-webkit-transform-origin:0 0;\n\ttransform:scale(0.5);\n\ttransform-origin:0 0;\n\tbox-sizing:border-box;\n}\n.list {\n\twidth:100%;\n\tmargin:auto;\n\tlist-style:none;\n\tpadding:5px 20px;\n}\n.list:after {\n\tborder:1px solid #ccc;\n\tborder-radius:10px;\n}\n.item {padding:0px;}\n.item:after {border-bottom:1px solid #ccc;}\n.item:last-child:after {display:none;}\n```\n\n如此调用\n\n```css\n<div class=\"item line\"></div>\n```\n\n这种方式适合某个元素下方需要有一条极细的border\n\n### 四、对比\n\n上图是原生1px，下图是解决后的效果                \n![与原生方案对比](http://epoch-night.oss-cn-hangzhou.aliyuncs.com/blogimg/border1px.jpg)  \n\n### 五、产生差别的原因\n\n> 为什么移动端css里面写了1px, 实际看起来比1px粗. 其实原因很好理解:这2个'px' 的含义是不一样的. 移动端 html 的 header 总会有一句\n\n\n```css\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no\">\n```\n\n\n> 这句话定义了本页面的 viewport 的宽度为设备宽度,初始缩放值和最大缩放值都为1,并禁止了用户缩放. viewport 通俗的讲是浏览器上可用来显示页面的区域, 这个区域是可能比屏幕大的。\n\n\n>手机存在一个能完美适配的理想viewport, 分辨率相差很大的手机的理想viewport的宽度可能是一样的, 这样做的目的是为了保证同样的css在不同屏幕下的显示效果是一致的, 上面的meta实际上是设置了ideal viewport的宽度.\n\n\n>以实际举例: iphone3 和 iphone4 的屏幕宽度分别是 320px, 640px, 但是它们的 ideal viewport 的宽度都是 320px, 设置了设备宽度后, 320px 宽的元素都能 100% 的填充满屏幕宽. 不同手机的 ideal viewpor t宽度是不一样的, 常见的有 320px, 360px, 384px. iphone 系列的这个值在 6 之前都是 320px, 控制 viewport 的好处就在于一套 css 可以适配多个机型.\n\n\n>因此, viewport 的设置和屏幕物理分辨率是按比例而不是相同的. 移动端 window 对象有个 devicePixelRatio 属性, 它表示设备物理像素和 css 像素的比例, 在 retina 屏的 iphone 手机上, 这个值为 2 或 3, css 里写的 1px 长度映射到物理像素上就有 2px 或 3px 那么长.\n\n\n\n","slug":"2017-08-22-thin-border","published":1,"updated":"2019-05-05T12:29:58.040Z","comments":1,"photos":[],"link":"","_id":"cjvayvwf80006m46avlsaa34p","content":"<a id=\"more\"></a>\n<h3 id=\"一、真正的1px边框\"><a href=\"#一、真正的1px边框\" class=\"headerlink\" title=\"一、真正的1px边框\"></a>一、真正的1px边框</h3><p>做完APP前端后大师兄就告诉我h5上的边框线太粗,把整站都给拉low了. 当时工期紧就没太在意1px粗细, 后面的版本针对这个问题做了些尝试, 这里总结下1px细线的处理方法，因为这已是最细的边框，电脑上清楚的显示，我已经设置了1px的border。</p>\n<p>于是为了寻找在移动端看起来像真正1px 的border，搜集一堆资料后还真找到了方案：</p>\n<ul>\n<li><strong>父元素设置</strong>：scale(0.5,0.5)                 </li>\n<li><strong>子元素设置</strong>：scale(2,2) 还原缩放，origin都是基于左上角（0,0）/left top</li>\n</ul>\n<p>这样父元素的border其实被缩放了，无疑更细。</p>\n<h3 id=\"二、通用方案\"><a href=\"#二、通用方案\" class=\"headerlink\" title=\"二、通用方案\"></a>二、通用方案</h3><p>用一个css类去为block元素添加更细的border</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">css</span></span><br><span class=\"line\"><span class=\"selector-class\">.border-1px</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: relative;</span><br><span class=\"line\">  &amp;:before, &amp;:after&#123;</span><br><span class=\"line\">    <span class=\"selector-tag\">border-top</span>: 1<span class=\"selector-tag\">px</span> <span class=\"selector-tag\">solid</span> <span class=\"selector-id\">#c8c7cc</span>;</span><br><span class=\"line\">    content: ' ';</span><br><span class=\"line\">    <span class=\"selector-tag\">display</span>: <span class=\"selector-tag\">block</span>;</span><br><span class=\"line\">    <span class=\"selector-tag\">width</span>: 100%;</span><br><span class=\"line\">    <span class=\"selector-tag\">position</span>: <span class=\"selector-tag\">absolute</span>;</span><br><span class=\"line\">    <span class=\"selector-tag\">left</span>: 0;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  &amp;<span class=\"selector-pseudo\">:before</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">top</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  &amp;<span class=\"selector-pseudo\">:after</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">bottom</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>适应移动设备：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">css</span></span><br><span class=\"line\">@<span class=\"keyword\">media</span> (-webkit-min-device-pixel-ratio:<span class=\"number\">1.5</span>), (min-device-pixel-ratio: <span class=\"number\">1.5</span>)&#123;</span><br><span class=\"line\">  <span class=\"selector-class\">.border-1px</span>&#123;</span><br><span class=\"line\">    &amp;::after, &amp;::before&#123;</span><br><span class=\"line\">      <span class=\"selector-tag\">-webkit-transform</span>: <span class=\"selector-tag\">scaleY</span>(<span class=\"selector-class\">.7</span>);</span><br><span class=\"line\">      <span class=\"selector-tag\">-webkit-transform-origin</span>: 0 0;</span><br><span class=\"line\">      <span class=\"selector-tag\">transform</span>: <span class=\"selector-tag\">scaleY</span>(<span class=\"selector-class\">.7</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &amp;<span class=\"selector-pseudo\">::after</span>&#123;</span><br><span class=\"line\">      <span class=\"attribute\">-webkit-transform-origin</span>: left bottom;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@<span class=\"keyword\">media</span> (-webkit-min-device-pixel-ratio:<span class=\"number\">2</span>), (min-device-pixel-ratio: <span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">  <span class=\"selector-class\">.border-1px</span>&#123;</span><br><span class=\"line\">    &amp;::after, &amp;::before&#123;</span><br><span class=\"line\">      <span class=\"selector-tag\">-webkit-transform</span>: <span class=\"selector-tag\">scaleY</span>(<span class=\"selector-class\">.5</span>);</span><br><span class=\"line\">      <span class=\"selector-tag\">transform</span>: <span class=\"selector-tag\">scaleY</span>(<span class=\"selector-class\">.5</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"三、简易方案\"><a href=\"#三、简易方案\" class=\"headerlink\" title=\"三、简易方案\"></a>三、简易方案</h3><figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">css</span></span><br><span class=\"line\"><span class=\"selector-class\">.line</span> &#123;<span class=\"attribute\">position</span>:relative;&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.line</span><span class=\"selector-pseudo\">:after</span> &#123;</span><br><span class=\"line\">\t<span class=\"attribute\">width</span>:<span class=\"number\">200%</span>;</span><br><span class=\"line\">\t<span class=\"attribute\">height</span>:<span class=\"number\">200%</span>;</span><br><span class=\"line\">\t<span class=\"attribute\">position</span>:absolute;</span><br><span class=\"line\">\t<span class=\"attribute\">top</span>:<span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"attribute\">left</span>:<span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"attribute\">z-index</span>:<span class=\"number\">0</span>;<span class=\"attribute\">content</span>:<span class=\"string\">\"\"</span>;</span><br><span class=\"line\">\t<span class=\"attribute\">-webkit-transform</span>:<span class=\"built_in\">scale</span>(0.5);</span><br><span class=\"line\">\t<span class=\"attribute\">-webkit-transform-origin</span>:<span class=\"number\">0</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"attribute\">transform</span>:<span class=\"built_in\">scale</span>(0.5);</span><br><span class=\"line\">\t<span class=\"attribute\">transform-origin</span>:<span class=\"number\">0</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"attribute\">box-sizing</span>:border-box;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.list</span> &#123;</span><br><span class=\"line\">\t<span class=\"attribute\">width</span>:<span class=\"number\">100%</span>;</span><br><span class=\"line\">\t<span class=\"attribute\">margin</span>:auto;</span><br><span class=\"line\">\t<span class=\"attribute\">list-style</span>:none;</span><br><span class=\"line\">\t<span class=\"attribute\">padding</span>:<span class=\"number\">5px</span> <span class=\"number\">20px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.list</span><span class=\"selector-pseudo\">:after</span> &#123;</span><br><span class=\"line\">\t<span class=\"attribute\">border</span>:<span class=\"number\">1px</span> solid <span class=\"number\">#ccc</span>;</span><br><span class=\"line\">\t<span class=\"attribute\">border-radius</span>:<span class=\"number\">10px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.item</span> &#123;<span class=\"attribute\">padding</span>:<span class=\"number\">0px</span>;&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.item</span><span class=\"selector-pseudo\">:after</span> &#123;<span class=\"attribute\">border-bottom</span>:<span class=\"number\">1px</span> solid <span class=\"number\">#ccc</span>;&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.item</span><span class=\"selector-pseudo\">:last-child</span><span class=\"selector-pseudo\">:after</span> &#123;<span class=\"attribute\">display</span>:none;&#125;</span><br></pre></td></tr></table></figure>\n<p>如此调用</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div class=\"item line\"&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<p>这种方式适合某个元素下方需要有一条极细的border</p>\n<h3 id=\"四、对比\"><a href=\"#四、对比\" class=\"headerlink\" title=\"四、对比\"></a>四、对比</h3><p>上图是原生1px，下图是解决后的效果<br><img src=\"http://epoch-night.oss-cn-hangzhou.aliyuncs.com/blogimg/border1px.jpg\" alt=\"与原生方案对比\">  </p>\n<h3 id=\"五、产生差别的原因\"><a href=\"#五、产生差别的原因\" class=\"headerlink\" title=\"五、产生差别的原因\"></a>五、产生差别的原因</h3><blockquote>\n<p>为什么移动端css里面写了1px, 实际看起来比1px粗. 其实原因很好理解:这2个’px’ 的含义是不一样的. 移动端 html 的 header 总会有一句</p>\n</blockquote>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no\"&gt;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>这句话定义了本页面的 viewport 的宽度为设备宽度,初始缩放值和最大缩放值都为1,并禁止了用户缩放. viewport 通俗的讲是浏览器上可用来显示页面的区域, 这个区域是可能比屏幕大的。</p>\n</blockquote>\n<blockquote>\n<p>手机存在一个能完美适配的理想viewport, 分辨率相差很大的手机的理想viewport的宽度可能是一样的, 这样做的目的是为了保证同样的css在不同屏幕下的显示效果是一致的, 上面的meta实际上是设置了ideal viewport的宽度.</p>\n</blockquote>\n<blockquote>\n<p>以实际举例: iphone3 和 iphone4 的屏幕宽度分别是 320px, 640px, 但是它们的 ideal viewport 的宽度都是 320px, 设置了设备宽度后, 320px 宽的元素都能 100% 的填充满屏幕宽. 不同手机的 ideal viewpor t宽度是不一样的, 常见的有 320px, 360px, 384px. iphone 系列的这个值在 6 之前都是 320px, 控制 viewport 的好处就在于一套 css 可以适配多个机型.</p>\n</blockquote>\n<blockquote>\n<p>因此, viewport 的设置和屏幕物理分辨率是按比例而不是相同的. 移动端 window 对象有个 devicePixelRatio 属性, 它表示设备物理像素和 css 像素的比例, 在 retina 屏的 iphone 手机上, 这个值为 2 或 3, css 里写的 1px 长度映射到物理像素上就有 2px 或 3px 那么长.</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"一、真正的1px边框\"><a href=\"#一、真正的1px边框\" class=\"headerlink\" title=\"一、真正的1px边框\"></a>一、真正的1px边框</h3><p>做完APP前端后大师兄就告诉我h5上的边框线太粗,把整站都给拉low了. 当时工期紧就没太在意1px粗细, 后面的版本针对这个问题做了些尝试, 这里总结下1px细线的处理方法，因为这已是最细的边框，电脑上清楚的显示，我已经设置了1px的border。</p>\n<p>于是为了寻找在移动端看起来像真正1px 的border，搜集一堆资料后还真找到了方案：</p>\n<ul>\n<li><strong>父元素设置</strong>：scale(0.5,0.5)                 </li>\n<li><strong>子元素设置</strong>：scale(2,2) 还原缩放，origin都是基于左上角（0,0）/left top</li>\n</ul>\n<p>这样父元素的border其实被缩放了，无疑更细。</p>\n<h3 id=\"二、通用方案\"><a href=\"#二、通用方案\" class=\"headerlink\" title=\"二、通用方案\"></a>二、通用方案</h3><p>用一个css类去为block元素添加更细的border</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">css</span></span><br><span class=\"line\"><span class=\"selector-class\">.border-1px</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: relative;</span><br><span class=\"line\">  &amp;:before, &amp;:after&#123;</span><br><span class=\"line\">    <span class=\"selector-tag\">border-top</span>: 1<span class=\"selector-tag\">px</span> <span class=\"selector-tag\">solid</span> <span class=\"selector-id\">#c8c7cc</span>;</span><br><span class=\"line\">    content: ' ';</span><br><span class=\"line\">    <span class=\"selector-tag\">display</span>: <span class=\"selector-tag\">block</span>;</span><br><span class=\"line\">    <span class=\"selector-tag\">width</span>: 100%;</span><br><span class=\"line\">    <span class=\"selector-tag\">position</span>: <span class=\"selector-tag\">absolute</span>;</span><br><span class=\"line\">    <span class=\"selector-tag\">left</span>: 0;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  &amp;<span class=\"selector-pseudo\">:before</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">top</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  &amp;<span class=\"selector-pseudo\">:after</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">bottom</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>适应移动设备：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">css</span></span><br><span class=\"line\">@<span class=\"keyword\">media</span> (-webkit-min-device-pixel-ratio:<span class=\"number\">1.5</span>), (min-device-pixel-ratio: <span class=\"number\">1.5</span>)&#123;</span><br><span class=\"line\">  <span class=\"selector-class\">.border-1px</span>&#123;</span><br><span class=\"line\">    &amp;::after, &amp;::before&#123;</span><br><span class=\"line\">      <span class=\"selector-tag\">-webkit-transform</span>: <span class=\"selector-tag\">scaleY</span>(<span class=\"selector-class\">.7</span>);</span><br><span class=\"line\">      <span class=\"selector-tag\">-webkit-transform-origin</span>: 0 0;</span><br><span class=\"line\">      <span class=\"selector-tag\">transform</span>: <span class=\"selector-tag\">scaleY</span>(<span class=\"selector-class\">.7</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &amp;<span class=\"selector-pseudo\">::after</span>&#123;</span><br><span class=\"line\">      <span class=\"attribute\">-webkit-transform-origin</span>: left bottom;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@<span class=\"keyword\">media</span> (-webkit-min-device-pixel-ratio:<span class=\"number\">2</span>), (min-device-pixel-ratio: <span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">  <span class=\"selector-class\">.border-1px</span>&#123;</span><br><span class=\"line\">    &amp;::after, &amp;::before&#123;</span><br><span class=\"line\">      <span class=\"selector-tag\">-webkit-transform</span>: <span class=\"selector-tag\">scaleY</span>(<span class=\"selector-class\">.5</span>);</span><br><span class=\"line\">      <span class=\"selector-tag\">transform</span>: <span class=\"selector-tag\">scaleY</span>(<span class=\"selector-class\">.5</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"三、简易方案\"><a href=\"#三、简易方案\" class=\"headerlink\" title=\"三、简易方案\"></a>三、简易方案</h3><figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">css</span></span><br><span class=\"line\"><span class=\"selector-class\">.line</span> &#123;<span class=\"attribute\">position</span>:relative;&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.line</span><span class=\"selector-pseudo\">:after</span> &#123;</span><br><span class=\"line\">\t<span class=\"attribute\">width</span>:<span class=\"number\">200%</span>;</span><br><span class=\"line\">\t<span class=\"attribute\">height</span>:<span class=\"number\">200%</span>;</span><br><span class=\"line\">\t<span class=\"attribute\">position</span>:absolute;</span><br><span class=\"line\">\t<span class=\"attribute\">top</span>:<span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"attribute\">left</span>:<span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"attribute\">z-index</span>:<span class=\"number\">0</span>;<span class=\"attribute\">content</span>:<span class=\"string\">\"\"</span>;</span><br><span class=\"line\">\t<span class=\"attribute\">-webkit-transform</span>:<span class=\"built_in\">scale</span>(0.5);</span><br><span class=\"line\">\t<span class=\"attribute\">-webkit-transform-origin</span>:<span class=\"number\">0</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"attribute\">transform</span>:<span class=\"built_in\">scale</span>(0.5);</span><br><span class=\"line\">\t<span class=\"attribute\">transform-origin</span>:<span class=\"number\">0</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"attribute\">box-sizing</span>:border-box;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.list</span> &#123;</span><br><span class=\"line\">\t<span class=\"attribute\">width</span>:<span class=\"number\">100%</span>;</span><br><span class=\"line\">\t<span class=\"attribute\">margin</span>:auto;</span><br><span class=\"line\">\t<span class=\"attribute\">list-style</span>:none;</span><br><span class=\"line\">\t<span class=\"attribute\">padding</span>:<span class=\"number\">5px</span> <span class=\"number\">20px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.list</span><span class=\"selector-pseudo\">:after</span> &#123;</span><br><span class=\"line\">\t<span class=\"attribute\">border</span>:<span class=\"number\">1px</span> solid <span class=\"number\">#ccc</span>;</span><br><span class=\"line\">\t<span class=\"attribute\">border-radius</span>:<span class=\"number\">10px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.item</span> &#123;<span class=\"attribute\">padding</span>:<span class=\"number\">0px</span>;&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.item</span><span class=\"selector-pseudo\">:after</span> &#123;<span class=\"attribute\">border-bottom</span>:<span class=\"number\">1px</span> solid <span class=\"number\">#ccc</span>;&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.item</span><span class=\"selector-pseudo\">:last-child</span><span class=\"selector-pseudo\">:after</span> &#123;<span class=\"attribute\">display</span>:none;&#125;</span><br></pre></td></tr></table></figure>\n<p>如此调用</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;div class=\"item line\"&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<p>这种方式适合某个元素下方需要有一条极细的border</p>\n<h3 id=\"四、对比\"><a href=\"#四、对比\" class=\"headerlink\" title=\"四、对比\"></a>四、对比</h3><p>上图是原生1px，下图是解决后的效果<br><img src=\"http://epoch-night.oss-cn-hangzhou.aliyuncs.com/blogimg/border1px.jpg\" alt=\"与原生方案对比\">  </p>\n<h3 id=\"五、产生差别的原因\"><a href=\"#五、产生差别的原因\" class=\"headerlink\" title=\"五、产生差别的原因\"></a>五、产生差别的原因</h3><blockquote>\n<p>为什么移动端css里面写了1px, 实际看起来比1px粗. 其实原因很好理解:这2个’px’ 的含义是不一样的. 移动端 html 的 header 总会有一句</p>\n</blockquote>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no\"&gt;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>这句话定义了本页面的 viewport 的宽度为设备宽度,初始缩放值和最大缩放值都为1,并禁止了用户缩放. viewport 通俗的讲是浏览器上可用来显示页面的区域, 这个区域是可能比屏幕大的。</p>\n</blockquote>\n<blockquote>\n<p>手机存在一个能完美适配的理想viewport, 分辨率相差很大的手机的理想viewport的宽度可能是一样的, 这样做的目的是为了保证同样的css在不同屏幕下的显示效果是一致的, 上面的meta实际上是设置了ideal viewport的宽度.</p>\n</blockquote>\n<blockquote>\n<p>以实际举例: iphone3 和 iphone4 的屏幕宽度分别是 320px, 640px, 但是它们的 ideal viewport 的宽度都是 320px, 设置了设备宽度后, 320px 宽的元素都能 100% 的填充满屏幕宽. 不同手机的 ideal viewpor t宽度是不一样的, 常见的有 320px, 360px, 384px. iphone 系列的这个值在 6 之前都是 320px, 控制 viewport 的好处就在于一套 css 可以适配多个机型.</p>\n</blockquote>\n<blockquote>\n<p>因此, viewport 的设置和屏幕物理分辨率是按比例而不是相同的. 移动端 window 对象有个 devicePixelRatio 属性, 它表示设备物理像素和 css 像素的比例, 在 retina 屏的 iphone 手机上, 这个值为 2 或 3, css 里写的 1px 长度映射到物理像素上就有 2px 或 3px 那么长.</p>\n</blockquote>"},{"layout":"post","title":"Spring | 资源加载的方式","date":"2017-11-02T05:20:00.000Z","author":"Gubaidan","header-img":"/Header/RbM63-XsLUY.png","cdn":"header-on","_content":"\n# Spring资源加载\n\n---\n\n\n\n![Resource接口依赖](http://epoch-night.oss-cn-hangzhou.aliyuncs.com/PostImg/ResourceClassDependence.png)\n\n为了访问访问不同的资源类型，必须使用不同的Resource实现类，这个是比较麻烦的，Spring提供了Resource这个强大的资源加载机制，不但能识别ftp、http、classpath等前缀的资源，还支持ant风格带通配符的资源地址。\n\n### 资源地址表达式\n\n以下是Spring支持的资源通配符前缀：\n\n|  地址前缀  |             示例              |                        对应的资源类型                        |\n| :--------: | :---------------------------: | :----------------------------------------------------------: |\n| classpath: |      classpath:log4j.xml      | 从类路径中夹在资源，classpath：和classpath：/是等价，都是相对于类的跟路径，资源问见可以在标准的文件系统中，也可以在jar或者zip的类包中。 |\n|   file:    |    file:/config/log4j.xml     | 使用urlResource从文件系统目录中装载资源，也可以采用绝对路金和地址 |\n|  http://   | http://www.xxxx.com/log4j.xml |              使用urlResource从web服务器装载资源              |\n|   ftp://   | ftp://www.xxxx/com/log4j.xml  |             使用urlResource从从ftp服务器装载资源             |\n|  没有前缀  |   com.xxxxx.xxxx.log4j.xml    |    根据ApplicationContext的具体实现采用对应类型的resource    |\n\n其中，和classpath： 对应的是classpath:* 前缀，假设有多个jar包或文件系统的路径都拥有一个相同的报名如（com.xxx），classpath： 只会在第一个包中查找，而classpath*则会在所有包前缀中查找资源文件。\n\n这对于分模块打包的应用非常有用，假设一个名为smart的应用共分为3个模块，一个模块对应一个配置文件，分别是m1.xml , m2.xml , m3.xml ,都放到com.xxx目录下，每个模块单独打成jar包，使用classpath：只会加载第一个模块的配置文件，而使用classpath*则会加载所有配置文件。\n\nAnt风格的资源地址支持三种匹配符。\n\n- ？： 匹配文件名中的一个字符\n\n- *：匹配文件名中任意字符。\n\n- ** ：匹配多层路径。\n\n  \n\n下面是几个Ant风格的资源路径的示例：\n\n- classpath:com.xx?x.log4j.xxml：匹配com.xxex.log4j.xml等\n\n- file:/users/xxxxx/*.xml：匹配文件系统中以xml为后缀的所有资源文件。\n\n- classpath:com.**.xml 匹配com路径下所有xml文件\n\n- classpath:com/**/aaa/*.xml 匹配com不同路径下所有xml文件\n\n  \n\n### 资源加载器\n\nSpring定义了一套资源加载的接口，并提供了实现：\n\n![loader](http://epoch-night.oss-cn-hangzhou.aliyuncs.com/PostImg/loader.png)\n\n```java\nimport org.junit.jupiter.api.Test;\nimport org.springframework.core.io.Resource;\nimport org.springframework.core.io.support.PathMatchingResourcePatternResolver;\nimport org.springframework.core.io.support.ResourcePatternResolver;\n\nimport java.io.IOException;\n\nimport static org.hibernate.validator.internal.util.Contracts.assertNotNull;\n\npublic class ResourceLoaderText {\n    @Test\n    private void getResource() throws IOException {\n        ResourcePatternResolver resourcePatternResolver = new PathMatchingResourcePatternResolver();\n\n        //加载所有com.smart 下。xml结尾的文件\n        Resource resource[] = resourcePatternResolver.getResources(\"classpath*: com.smart.**/*.properties\");\n\n        assertNotNull(resource);\n        for(Resource item: resource){\n            System.out.println(item.getDescription());\n        }\n    }\n\n}\n```\n\n\n\n### 注意\n\n用Resource操作文件时，如果文件在项目发布时会打包到jar包，那么不能使用Resource.getFile()方法，否则会抛出FileNotFound异常，但可以使用Resource.getInputStream()读取。\n\n>参考：《Spring技术内幕》、《精通Spring 4.x 企业应用开发实战》","source":"_posts/2017-11-2-spring-resouce.markdown","raw":"---\nlayout: post\ntitle: \"Spring | 资源加载的方式\"\ndate: 2017-11-02 13:20\nauthor: \"Gubaidan\"\nheader-img: \"/Header/RbM63-XsLUY.png\"\ncdn: 'header-on'\ntags:\n\t- Spring\n---\n\n# Spring资源加载\n\n---\n\n\n\n![Resource接口依赖](http://epoch-night.oss-cn-hangzhou.aliyuncs.com/PostImg/ResourceClassDependence.png)\n\n为了访问访问不同的资源类型，必须使用不同的Resource实现类，这个是比较麻烦的，Spring提供了Resource这个强大的资源加载机制，不但能识别ftp、http、classpath等前缀的资源，还支持ant风格带通配符的资源地址。\n\n### 资源地址表达式\n\n以下是Spring支持的资源通配符前缀：\n\n|  地址前缀  |             示例              |                        对应的资源类型                        |\n| :--------: | :---------------------------: | :----------------------------------------------------------: |\n| classpath: |      classpath:log4j.xml      | 从类路径中夹在资源，classpath：和classpath：/是等价，都是相对于类的跟路径，资源问见可以在标准的文件系统中，也可以在jar或者zip的类包中。 |\n|   file:    |    file:/config/log4j.xml     | 使用urlResource从文件系统目录中装载资源，也可以采用绝对路金和地址 |\n|  http://   | http://www.xxxx.com/log4j.xml |              使用urlResource从web服务器装载资源              |\n|   ftp://   | ftp://www.xxxx/com/log4j.xml  |             使用urlResource从从ftp服务器装载资源             |\n|  没有前缀  |   com.xxxxx.xxxx.log4j.xml    |    根据ApplicationContext的具体实现采用对应类型的resource    |\n\n其中，和classpath： 对应的是classpath:* 前缀，假设有多个jar包或文件系统的路径都拥有一个相同的报名如（com.xxx），classpath： 只会在第一个包中查找，而classpath*则会在所有包前缀中查找资源文件。\n\n这对于分模块打包的应用非常有用，假设一个名为smart的应用共分为3个模块，一个模块对应一个配置文件，分别是m1.xml , m2.xml , m3.xml ,都放到com.xxx目录下，每个模块单独打成jar包，使用classpath：只会加载第一个模块的配置文件，而使用classpath*则会加载所有配置文件。\n\nAnt风格的资源地址支持三种匹配符。\n\n- ？： 匹配文件名中的一个字符\n\n- *：匹配文件名中任意字符。\n\n- ** ：匹配多层路径。\n\n  \n\n下面是几个Ant风格的资源路径的示例：\n\n- classpath:com.xx?x.log4j.xxml：匹配com.xxex.log4j.xml等\n\n- file:/users/xxxxx/*.xml：匹配文件系统中以xml为后缀的所有资源文件。\n\n- classpath:com.**.xml 匹配com路径下所有xml文件\n\n- classpath:com/**/aaa/*.xml 匹配com不同路径下所有xml文件\n\n  \n\n### 资源加载器\n\nSpring定义了一套资源加载的接口，并提供了实现：\n\n![loader](http://epoch-night.oss-cn-hangzhou.aliyuncs.com/PostImg/loader.png)\n\n```java\nimport org.junit.jupiter.api.Test;\nimport org.springframework.core.io.Resource;\nimport org.springframework.core.io.support.PathMatchingResourcePatternResolver;\nimport org.springframework.core.io.support.ResourcePatternResolver;\n\nimport java.io.IOException;\n\nimport static org.hibernate.validator.internal.util.Contracts.assertNotNull;\n\npublic class ResourceLoaderText {\n    @Test\n    private void getResource() throws IOException {\n        ResourcePatternResolver resourcePatternResolver = new PathMatchingResourcePatternResolver();\n\n        //加载所有com.smart 下。xml结尾的文件\n        Resource resource[] = resourcePatternResolver.getResources(\"classpath*: com.smart.**/*.properties\");\n\n        assertNotNull(resource);\n        for(Resource item: resource){\n            System.out.println(item.getDescription());\n        }\n    }\n\n}\n```\n\n\n\n### 注意\n\n用Resource操作文件时，如果文件在项目发布时会打包到jar包，那么不能使用Resource.getFile()方法，否则会抛出FileNotFound异常，但可以使用Resource.getInputStream()读取。\n\n>参考：《Spring技术内幕》、《精通Spring 4.x 企业应用开发实战》","slug":"2017-11-2-spring-resouce","published":1,"updated":"2019-05-05T12:32:04.154Z","comments":1,"photos":[],"link":"","_id":"cjvayvwf90007m46addg4g06t","content":"<h1 id=\"Spring资源加载\"><a href=\"#Spring资源加载\" class=\"headerlink\" title=\"Spring资源加载\"></a>Spring资源加载</h1><hr>\n<p><img src=\"http://epoch-night.oss-cn-hangzhou.aliyuncs.com/PostImg/ResourceClassDependence.png\" alt=\"Resource接口依赖\"></p>\n<p>为了访问访问不同的资源类型，必须使用不同的Resource实现类，这个是比较麻烦的，Spring提供了Resource这个强大的资源加载机制，不但能识别ftp、http、classpath等前缀的资源，还支持ant风格带通配符的资源地址。</p>\n<h3 id=\"资源地址表达式\"><a href=\"#资源地址表达式\" class=\"headerlink\" title=\"资源地址表达式\"></a>资源地址表达式</h3><p>以下是Spring支持的资源通配符前缀：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">地址前缀</th>\n<th style=\"text-align:center\">示例</th>\n<th style=\"text-align:center\">对应的资源类型</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">classpath:</td>\n<td style=\"text-align:center\">classpath:log4j.xml</td>\n<td style=\"text-align:center\">从类路径中夹在资源，classpath：和classpath：/是等价，都是相对于类的跟路径，资源问见可以在标准的文件系统中，也可以在jar或者zip的类包中。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">file:</td>\n<td style=\"text-align:center\">file:/config/log4j.xml</td>\n<td style=\"text-align:center\">使用urlResource从文件系统目录中装载资源，也可以采用绝对路金和地址</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">http://</td>\n<td style=\"text-align:center\"><a href=\"http://www.xxxx.com/log4j.xml\" target=\"_blank\" rel=\"noopener\">http://www.xxxx.com/log4j.xml</a></td>\n<td style=\"text-align:center\">使用urlResource从web服务器装载资源</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">ftp://</td>\n<td style=\"text-align:center\"><a href=\"ftp://www.xxxx/com/log4j.xml\" target=\"_blank\" rel=\"noopener\">ftp://www.xxxx/com/log4j.xml</a></td>\n<td style=\"text-align:center\">使用urlResource从从ftp服务器装载资源</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">没有前缀</td>\n<td style=\"text-align:center\">com.xxxxx.xxxx.log4j.xml</td>\n<td style=\"text-align:center\">根据ApplicationContext的具体实现采用对应类型的resource</td>\n</tr>\n</tbody>\n</table>\n<p>其中，和classpath： 对应的是classpath:<em> 前缀，假设有多个jar包或文件系统的路径都拥有一个相同的报名如（com.xxx），classpath： 只会在第一个包中查找，而classpath</em>则会在所有包前缀中查找资源文件。</p>\n<p>这对于分模块打包的应用非常有用，假设一个名为smart的应用共分为3个模块，一个模块对应一个配置文件，分别是m1.xml , m2.xml , m3.xml ,都放到com.xxx目录下，每个模块单独打成jar包，使用classpath：只会加载第一个模块的配置文件，而使用classpath*则会加载所有配置文件。</p>\n<p>Ant风格的资源地址支持三种匹配符。</p>\n<ul>\n<li><p>？： 匹配文件名中的一个字符</p>\n</li>\n<li><p>*：匹配文件名中任意字符。</p>\n</li>\n<li><p>** ：匹配多层路径。</p>\n</li>\n</ul>\n<p>下面是几个Ant风格的资源路径的示例：</p>\n<ul>\n<li><p>classpath:com.xx?x.log4j.xxml：匹配com.xxex.log4j.xml等</p>\n</li>\n<li><p>file:/users/xxxxx/*.xml：匹配文件系统中以xml为后缀的所有资源文件。</p>\n</li>\n<li><p>classpath:com.**.xml 匹配com路径下所有xml文件</p>\n</li>\n<li><p>classpath:com/*<em>/aaa/</em>.xml 匹配com不同路径下所有xml文件</p>\n</li>\n</ul>\n<h3 id=\"资源加载器\"><a href=\"#资源加载器\" class=\"headerlink\" title=\"资源加载器\"></a>资源加载器</h3><p>Spring定义了一套资源加载的接口，并提供了实现：</p>\n<p><img src=\"http://epoch-night.oss-cn-hangzhou.aliyuncs.com/PostImg/loader.png\" alt=\"loader\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.junit.jupiter.api.Test;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.core.io.Resource;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.core.io.support.PathMatchingResourcePatternResolver;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.core.io.support.ResourcePatternResolver;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"keyword\">static</span> org.hibernate.validator.internal.util.Contracts.assertNotNull;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ResourceLoaderText</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">getResource</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        ResourcePatternResolver resourcePatternResolver = <span class=\"keyword\">new</span> PathMatchingResourcePatternResolver();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//加载所有com.smart 下。xml结尾的文件</span></span><br><span class=\"line\">        Resource resource[] = resourcePatternResolver.getResources(<span class=\"string\">\"classpath*: com.smart.**/*.properties\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        assertNotNull(resource);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(Resource item: resource)&#123;</span><br><span class=\"line\">            System.out.println(item.getDescription());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h3><p>用Resource操作文件时，如果文件在项目发布时会打包到jar包，那么不能使用Resource.getFile()方法，否则会抛出FileNotFound异常，但可以使用Resource.getInputStream()读取。</p>\n<blockquote>\n<p>参考：《Spring技术内幕》、《精通Spring 4.x 企业应用开发实战》</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Spring资源加载\"><a href=\"#Spring资源加载\" class=\"headerlink\" title=\"Spring资源加载\"></a>Spring资源加载</h1><hr>\n<p><img src=\"http://epoch-night.oss-cn-hangzhou.aliyuncs.com/PostImg/ResourceClassDependence.png\" alt=\"Resource接口依赖\"></p>\n<p>为了访问访问不同的资源类型，必须使用不同的Resource实现类，这个是比较麻烦的，Spring提供了Resource这个强大的资源加载机制，不但能识别ftp、http、classpath等前缀的资源，还支持ant风格带通配符的资源地址。</p>\n<h3 id=\"资源地址表达式\"><a href=\"#资源地址表达式\" class=\"headerlink\" title=\"资源地址表达式\"></a>资源地址表达式</h3><p>以下是Spring支持的资源通配符前缀：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">地址前缀</th>\n<th style=\"text-align:center\">示例</th>\n<th style=\"text-align:center\">对应的资源类型</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">classpath:</td>\n<td style=\"text-align:center\">classpath:log4j.xml</td>\n<td style=\"text-align:center\">从类路径中夹在资源，classpath：和classpath：/是等价，都是相对于类的跟路径，资源问见可以在标准的文件系统中，也可以在jar或者zip的类包中。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">file:</td>\n<td style=\"text-align:center\">file:/config/log4j.xml</td>\n<td style=\"text-align:center\">使用urlResource从文件系统目录中装载资源，也可以采用绝对路金和地址</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">http://</td>\n<td style=\"text-align:center\"><a href=\"http://www.xxxx.com/log4j.xml\" target=\"_blank\" rel=\"noopener\">http://www.xxxx.com/log4j.xml</a></td>\n<td style=\"text-align:center\">使用urlResource从web服务器装载资源</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">ftp://</td>\n<td style=\"text-align:center\"><a href=\"ftp://www.xxxx/com/log4j.xml\" target=\"_blank\" rel=\"noopener\">ftp://www.xxxx/com/log4j.xml</a></td>\n<td style=\"text-align:center\">使用urlResource从从ftp服务器装载资源</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">没有前缀</td>\n<td style=\"text-align:center\">com.xxxxx.xxxx.log4j.xml</td>\n<td style=\"text-align:center\">根据ApplicationContext的具体实现采用对应类型的resource</td>\n</tr>\n</tbody>\n</table>\n<p>其中，和classpath： 对应的是classpath:<em> 前缀，假设有多个jar包或文件系统的路径都拥有一个相同的报名如（com.xxx），classpath： 只会在第一个包中查找，而classpath</em>则会在所有包前缀中查找资源文件。</p>\n<p>这对于分模块打包的应用非常有用，假设一个名为smart的应用共分为3个模块，一个模块对应一个配置文件，分别是m1.xml , m2.xml , m3.xml ,都放到com.xxx目录下，每个模块单独打成jar包，使用classpath：只会加载第一个模块的配置文件，而使用classpath*则会加载所有配置文件。</p>\n<p>Ant风格的资源地址支持三种匹配符。</p>\n<ul>\n<li><p>？： 匹配文件名中的一个字符</p>\n</li>\n<li><p>*：匹配文件名中任意字符。</p>\n</li>\n<li><p>** ：匹配多层路径。</p>\n</li>\n</ul>\n<p>下面是几个Ant风格的资源路径的示例：</p>\n<ul>\n<li><p>classpath:com.xx?x.log4j.xxml：匹配com.xxex.log4j.xml等</p>\n</li>\n<li><p>file:/users/xxxxx/*.xml：匹配文件系统中以xml为后缀的所有资源文件。</p>\n</li>\n<li><p>classpath:com.**.xml 匹配com路径下所有xml文件</p>\n</li>\n<li><p>classpath:com/*<em>/aaa/</em>.xml 匹配com不同路径下所有xml文件</p>\n</li>\n</ul>\n<h3 id=\"资源加载器\"><a href=\"#资源加载器\" class=\"headerlink\" title=\"资源加载器\"></a>资源加载器</h3><p>Spring定义了一套资源加载的接口，并提供了实现：</p>\n<p><img src=\"http://epoch-night.oss-cn-hangzhou.aliyuncs.com/PostImg/loader.png\" alt=\"loader\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.junit.jupiter.api.Test;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.core.io.Resource;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.core.io.support.PathMatchingResourcePatternResolver;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.core.io.support.ResourcePatternResolver;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"keyword\">static</span> org.hibernate.validator.internal.util.Contracts.assertNotNull;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ResourceLoaderText</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">getResource</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        ResourcePatternResolver resourcePatternResolver = <span class=\"keyword\">new</span> PathMatchingResourcePatternResolver();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//加载所有com.smart 下。xml结尾的文件</span></span><br><span class=\"line\">        Resource resource[] = resourcePatternResolver.getResources(<span class=\"string\">\"classpath*: com.smart.**/*.properties\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        assertNotNull(resource);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(Resource item: resource)&#123;</span><br><span class=\"line\">            System.out.println(item.getDescription());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h3><p>用Resource操作文件时，如果文件在项目发布时会打包到jar包，那么不能使用Resource.getFile()方法，否则会抛出FileNotFound异常，但可以使用Resource.getInputStream()读取。</p>\n<blockquote>\n<p>参考：《Spring技术内幕》、《精通Spring 4.x 企业应用开发实战》</p>\n</blockquote>\n"},{"layout":"post","title":"如何写出一个动态规划","date":"2018-03-01T22:00:00.000Z","author":"Gubaidan","header-img":"/Header/dp.jpg","cdn":"header-on","_content":"### 动态规划一般流程\n\n说到动态规划我是拒绝的，一般来说都很恶心。。。\n\n\nDP的核心是将一个问题分解成为若干个子问题，解决一个动态规划大体分为三步：暴力搜索、查找冗余、消除冗余\n\n分解子问题需要注意的点：\n\n* 具有相同的子问题：必须保证我们分割成的子问题也能按照相同的方法分割成更小的自问题， 并这些自问题的最终分割情况是可以解决的\n\n* 满足最优子结构：就是一个决策的子决策也是最优的\n\n* 无后效性：这是DP中最重要的一点， 他要求每个子问题的决策不能对后面其他未解决的问题产影响， 如果产生就无法保证决策的最优性， 这就是无后效性。往往需要我们找到一个合适的状态。（非常重要）\n\n### Fibnacci数列\n\n在学习动态规划之前我根本不认为fibnacci数列是个动态规划题\n\nfibnacci数列: 1 1 2 3 5 8 13 ... 当n大于2时，第n项等于前两项之和。\n\n所以递推公式为fn(n) = f(n-1)+(fn-2)\n\n#### 1) 写出暴力递归（自顶向下）\n\n```java\n     private static long fib(int n){\n        if (n <= 2) return 1;\n        return fib(n - 1) + fib(n - 2);\n    }\n\n    public static void main(String[] args) {\n        long start = System.currentTimeMillis();\n        long i = fib(10000);\n        long end = System.currentTimeMillis() - start;\n        System.out.println(\"time:\"+end + \"ms,\" + i);\n    }\n```\n\n\n时间复杂度：O(2^n)\n\n\n第一次：我将 n 设置了1000000直接爆栈\n\n第二次执行：n = 10000 ，时间很长我等不住了，强制退出\n\n第三次执行 n = 1000 ,依然很长时间，强制退出\n\n第四次执行 n = 50,运行结果：time:34397ms,12586269025\n\n只有前50项结果已经到达了13位数，所以暴力递归花费的时间是非常长的\n\n#### 2) 找出冗余\n\n冗余分析：分解为当前问题为 fn(n) = f(n-1)+(fn-2)后，每一次计算子问题f(n)（如递推式中的f(n - 1)）,都会重新计算n-1之前的子问题，导致重复计算。以n=10为例，要求得f(10)，需要求得f(9)和f(8)。同样，要求得f(9)，要先求得f(8)和f(7)\n\n```\n                f(10)\n              /        \\\n            f(9)         f(8)\n           /     \\       /    \\\n        (8)     f(7)  f(7)   f(6)\n       /   \\     /   \\ \n     f(7)  f(6)  f(6) f(5)\n```\n\n  \t\n\n\n\n#### 3) 消除冗余（计划搜索）\n\n在每算过一个子问题之后，将结果记录，在下一个子问题需要需要计算同一个子问题时，直接将结果return\n\n代码如下：\n\n```java\nprivate static long[] res; // 声明一个全局数组，存储计算过的子项\n\n    private static long fib(int n){\n        if (n <= 2) return 1;\n        if(res[n] > 0){\n            return res[n];\n        }\n        res[n] =  fib(n - 1) + fib(n - 2);\n        return res[n];\n    }\n\n    public static void main(String[] args) {\n        long start = System.currentTimeMillis();\n        int n = 50;\n        res = new long[n+1];\n        for(int i = 0; i < n;i++){  //初始化数组\n            res[i] = -1;\n        }\n        long r = fib(n);\n        long end = System.currentTimeMillis() - start;\n        System.out.println(\"time:\"+end + \"ms,\" + r);\n    }\n```\n\n同样求解 n= 50 ,运行结果：time:0ms,12586269025\n\n求解 n = 1000 ,运行结果：time:0ms,817770325994397771\n\n在经过消除冗余后，时间复杂度O(n)\n\n#### 4) 转换为递推式（自底向上）\n\n```java\n        public static void main(String[] args) {\n        long start = System.currentTimeMillis();\n        int n = 50;\n        long[] res = new long[n];\n        res[0] = 1;\n        res[1] = 1;\n        for(int i = 2; i < n;i++){\n            res[i] = res[i - 1] + res[i - 2];\n        }\n\n        long end = System.currentTimeMillis() - start;\n        System.out.println(\"time:\"+end + \"ms,\" + res[n -1]);\n    }\n```\n\n### House Robber(Leet code 198)\n\n\n>\tYou are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.\n\n> Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.\n\n问题大意：\n\n你是一名专业的强盗，计划抢劫沿街的房屋。每间房屋都藏有一定数量的金钱，如果在同一晚上有两间相邻的房屋被闯入，它将自动与警方联系。\n给出一份代表每个房屋的金额的非负整数列表，确定你可以在没有提醒警方的情况下抢劫的最高金额。\n\n问题分析：假设在抢劫第n家店时会有两种决策\n\n* 抢这家店，但是就不能抢下一家，抢到的金额加上当前这家店的金额，表达式 \n\n* 不抢这家店，则直接跳过，抢劫金额不变\n\n由于问题为抢劫金额最高，所以递归表达式为：\n\n```java\nf(n) = Max(f(n- 2) + value, f(n - 1))\n```\n\n#### 1) 暴力递归（自顶向下）\n\n```java\nprivate static int solve(int idx, int[] nums) {\n    if (idx < 0) return 0;\n    return Math.max(nums[idx] + solve(idx - 2, nums),solve(idx -1 ,nums));\n}\n\npublic static void main(String[] args) {\n    long start = System.currentTimeMillis();\n    int[] nums = new int[]{\n            1, 2, 3, 1, 2, 7, 9, 3, 1, 2, 9, 3, 7, 9,\n            7, 9, 3, 1, 2, 7, 9, 3, 12, 7, 9, 3, 7, 9,\n            12, 7, 9, 3, 1, 2, 7, 9, 3, 12, 7, 7, 9\n    };\n    int res = solve(nums.length - 1, nums);\n    long end = System.currentTimeMillis() - start;\n    System.out.println(\"time:\" + end + \"ms,\" + res);\n}\n```\n\n运行结果：time:1471ms,135\n\n时间复杂度：O(2^n)\n\n#### 2) 冗余分析\n\n和Fibnaicc数列类似，每次执行搜索时，依赖子项重复计算，开启一个数组保存计算过的结果\n\n#### 4）消除冗余（计划搜索）\n\n将计算过的子项保存\n\n```java\n    private static int[] result;\n\nprivate static int solve(int idx, int[] nums) {\n    if (idx < 0) return 0;\n    if (result[idx] >= 0) return result[idx];\n        result[idx] = Math.max(nums[idx] + solve(idx - 2, nums),\n            solve(idx - 1, nums));\n    return result[idx];\n}\n\npublic static void main(String[] args) {\n    long start = System.currentTimeMillis();\n    int[] nums = new int[]{\n            1, 2, 3, 1, 2, 7, 9, 3, 1, 2, 9, 3, 7, 9,\n            7, 9, 3, 1, 2, 7, 9, 3, 12, 7, 9, 3, 7, 9,\n            12, 7, 9, 3, 1, 2, 7, 9, 3, 12, 7, 7, 9\n    };\n    result = new int[nums.length];\n    for(int i = 0; i < nums.length; i++){\n        result[i] = -1;\n    }\n    int res = solve(nums.length - 1, nums);\n    long end = System.currentTimeMillis() - start;\n    System.out.println(\"time:\" + end + \"ms,\" + res);\n} \n```\n\n运行结果：time:0ms,135\n\n时间复杂度：O(n)\n\n#### 5）转换为递推式（自底向上）\n\n```java\n    public static void main(String[] args) {\n    long start = System.currentTimeMillis();\n    int[] nums = new int[]{\n            1, 2, 3, 1, 2, 7, 9, 3, 1, 2, 9, 3, 7, 9,\n            7, 9, 3, 1, 2, 7, 9, 3, 12, 7, 9, 3, 7, 9,\n            12, 7, 9, 3, 1, 2, 7, 9, 3, 12, 7, 7, 9\n    };\n    // a是上次的最大收益\n    int a = nums[0];\n    // b是当前的最大受益\n    int b = Math.max(nums[0], nums[1]);\n    for(int i = 2; i < nums.length; i++){\n        int tmp = b;\n        // 当前的最大收益是两种选择里较大的那个\n        b = Math.max(a + nums[i], b);\n        a = tmp;\n    }\n    long end = System.currentTimeMillis() - start;\n    System.out.println(\"time:\" + end + \"ms,\" + b);\n}\n```\n\n运行结果：time:0ms,135\n\n时间复杂度：O(n)\n\n​\t\n\n\n\n","source":"_posts/2018-03-02-DP.markdown","raw":"---\nlayout: post\ntitle: \"如何写出一个动态规划\"\ndate: 2018-03-02 06:00\nauthor: \"Gubaidan\"\nheader-img: \"/Header/dp.jpg\"\ncdn: 'header-on'\ntags:\n\t- 算法\n---\n### 动态规划一般流程\n\n说到动态规划我是拒绝的，一般来说都很恶心。。。\n\n\nDP的核心是将一个问题分解成为若干个子问题，解决一个动态规划大体分为三步：暴力搜索、查找冗余、消除冗余\n\n分解子问题需要注意的点：\n\n* 具有相同的子问题：必须保证我们分割成的子问题也能按照相同的方法分割成更小的自问题， 并这些自问题的最终分割情况是可以解决的\n\n* 满足最优子结构：就是一个决策的子决策也是最优的\n\n* 无后效性：这是DP中最重要的一点， 他要求每个子问题的决策不能对后面其他未解决的问题产影响， 如果产生就无法保证决策的最优性， 这就是无后效性。往往需要我们找到一个合适的状态。（非常重要）\n\n### Fibnacci数列\n\n在学习动态规划之前我根本不认为fibnacci数列是个动态规划题\n\nfibnacci数列: 1 1 2 3 5 8 13 ... 当n大于2时，第n项等于前两项之和。\n\n所以递推公式为fn(n) = f(n-1)+(fn-2)\n\n#### 1) 写出暴力递归（自顶向下）\n\n```java\n     private static long fib(int n){\n        if (n <= 2) return 1;\n        return fib(n - 1) + fib(n - 2);\n    }\n\n    public static void main(String[] args) {\n        long start = System.currentTimeMillis();\n        long i = fib(10000);\n        long end = System.currentTimeMillis() - start;\n        System.out.println(\"time:\"+end + \"ms,\" + i);\n    }\n```\n\n\n时间复杂度：O(2^n)\n\n\n第一次：我将 n 设置了1000000直接爆栈\n\n第二次执行：n = 10000 ，时间很长我等不住了，强制退出\n\n第三次执行 n = 1000 ,依然很长时间，强制退出\n\n第四次执行 n = 50,运行结果：time:34397ms,12586269025\n\n只有前50项结果已经到达了13位数，所以暴力递归花费的时间是非常长的\n\n#### 2) 找出冗余\n\n冗余分析：分解为当前问题为 fn(n) = f(n-1)+(fn-2)后，每一次计算子问题f(n)（如递推式中的f(n - 1)）,都会重新计算n-1之前的子问题，导致重复计算。以n=10为例，要求得f(10)，需要求得f(9)和f(8)。同样，要求得f(9)，要先求得f(8)和f(7)\n\n```\n                f(10)\n              /        \\\n            f(9)         f(8)\n           /     \\       /    \\\n        (8)     f(7)  f(7)   f(6)\n       /   \\     /   \\ \n     f(7)  f(6)  f(6) f(5)\n```\n\n  \t\n\n\n\n#### 3) 消除冗余（计划搜索）\n\n在每算过一个子问题之后，将结果记录，在下一个子问题需要需要计算同一个子问题时，直接将结果return\n\n代码如下：\n\n```java\nprivate static long[] res; // 声明一个全局数组，存储计算过的子项\n\n    private static long fib(int n){\n        if (n <= 2) return 1;\n        if(res[n] > 0){\n            return res[n];\n        }\n        res[n] =  fib(n - 1) + fib(n - 2);\n        return res[n];\n    }\n\n    public static void main(String[] args) {\n        long start = System.currentTimeMillis();\n        int n = 50;\n        res = new long[n+1];\n        for(int i = 0; i < n;i++){  //初始化数组\n            res[i] = -1;\n        }\n        long r = fib(n);\n        long end = System.currentTimeMillis() - start;\n        System.out.println(\"time:\"+end + \"ms,\" + r);\n    }\n```\n\n同样求解 n= 50 ,运行结果：time:0ms,12586269025\n\n求解 n = 1000 ,运行结果：time:0ms,817770325994397771\n\n在经过消除冗余后，时间复杂度O(n)\n\n#### 4) 转换为递推式（自底向上）\n\n```java\n        public static void main(String[] args) {\n        long start = System.currentTimeMillis();\n        int n = 50;\n        long[] res = new long[n];\n        res[0] = 1;\n        res[1] = 1;\n        for(int i = 2; i < n;i++){\n            res[i] = res[i - 1] + res[i - 2];\n        }\n\n        long end = System.currentTimeMillis() - start;\n        System.out.println(\"time:\"+end + \"ms,\" + res[n -1]);\n    }\n```\n\n### House Robber(Leet code 198)\n\n\n>\tYou are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.\n\n> Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.\n\n问题大意：\n\n你是一名专业的强盗，计划抢劫沿街的房屋。每间房屋都藏有一定数量的金钱，如果在同一晚上有两间相邻的房屋被闯入，它将自动与警方联系。\n给出一份代表每个房屋的金额的非负整数列表，确定你可以在没有提醒警方的情况下抢劫的最高金额。\n\n问题分析：假设在抢劫第n家店时会有两种决策\n\n* 抢这家店，但是就不能抢下一家，抢到的金额加上当前这家店的金额，表达式 \n\n* 不抢这家店，则直接跳过，抢劫金额不变\n\n由于问题为抢劫金额最高，所以递归表达式为：\n\n```java\nf(n) = Max(f(n- 2) + value, f(n - 1))\n```\n\n#### 1) 暴力递归（自顶向下）\n\n```java\nprivate static int solve(int idx, int[] nums) {\n    if (idx < 0) return 0;\n    return Math.max(nums[idx] + solve(idx - 2, nums),solve(idx -1 ,nums));\n}\n\npublic static void main(String[] args) {\n    long start = System.currentTimeMillis();\n    int[] nums = new int[]{\n            1, 2, 3, 1, 2, 7, 9, 3, 1, 2, 9, 3, 7, 9,\n            7, 9, 3, 1, 2, 7, 9, 3, 12, 7, 9, 3, 7, 9,\n            12, 7, 9, 3, 1, 2, 7, 9, 3, 12, 7, 7, 9\n    };\n    int res = solve(nums.length - 1, nums);\n    long end = System.currentTimeMillis() - start;\n    System.out.println(\"time:\" + end + \"ms,\" + res);\n}\n```\n\n运行结果：time:1471ms,135\n\n时间复杂度：O(2^n)\n\n#### 2) 冗余分析\n\n和Fibnaicc数列类似，每次执行搜索时，依赖子项重复计算，开启一个数组保存计算过的结果\n\n#### 4）消除冗余（计划搜索）\n\n将计算过的子项保存\n\n```java\n    private static int[] result;\n\nprivate static int solve(int idx, int[] nums) {\n    if (idx < 0) return 0;\n    if (result[idx] >= 0) return result[idx];\n        result[idx] = Math.max(nums[idx] + solve(idx - 2, nums),\n            solve(idx - 1, nums));\n    return result[idx];\n}\n\npublic static void main(String[] args) {\n    long start = System.currentTimeMillis();\n    int[] nums = new int[]{\n            1, 2, 3, 1, 2, 7, 9, 3, 1, 2, 9, 3, 7, 9,\n            7, 9, 3, 1, 2, 7, 9, 3, 12, 7, 9, 3, 7, 9,\n            12, 7, 9, 3, 1, 2, 7, 9, 3, 12, 7, 7, 9\n    };\n    result = new int[nums.length];\n    for(int i = 0; i < nums.length; i++){\n        result[i] = -1;\n    }\n    int res = solve(nums.length - 1, nums);\n    long end = System.currentTimeMillis() - start;\n    System.out.println(\"time:\" + end + \"ms,\" + res);\n} \n```\n\n运行结果：time:0ms,135\n\n时间复杂度：O(n)\n\n#### 5）转换为递推式（自底向上）\n\n```java\n    public static void main(String[] args) {\n    long start = System.currentTimeMillis();\n    int[] nums = new int[]{\n            1, 2, 3, 1, 2, 7, 9, 3, 1, 2, 9, 3, 7, 9,\n            7, 9, 3, 1, 2, 7, 9, 3, 12, 7, 9, 3, 7, 9,\n            12, 7, 9, 3, 1, 2, 7, 9, 3, 12, 7, 7, 9\n    };\n    // a是上次的最大收益\n    int a = nums[0];\n    // b是当前的最大受益\n    int b = Math.max(nums[0], nums[1]);\n    for(int i = 2; i < nums.length; i++){\n        int tmp = b;\n        // 当前的最大收益是两种选择里较大的那个\n        b = Math.max(a + nums[i], b);\n        a = tmp;\n    }\n    long end = System.currentTimeMillis() - start;\n    System.out.println(\"time:\" + end + \"ms,\" + b);\n}\n```\n\n运行结果：time:0ms,135\n\n时间复杂度：O(n)\n\n​\t\n\n\n\n","slug":"2018-03-02-DP","published":1,"updated":"2018-06-21T08:50:00.494Z","comments":1,"photos":[],"link":"","_id":"cjvayvwfb000am46agyjew6rd","content":"<h3 id=\"动态规划一般流程\"><a href=\"#动态规划一般流程\" class=\"headerlink\" title=\"动态规划一般流程\"></a>动态规划一般流程</h3><p>说到动态规划我是拒绝的，一般来说都很恶心。。。</p>\n<p>DP的核心是将一个问题分解成为若干个子问题，解决一个动态规划大体分为三步：暴力搜索、查找冗余、消除冗余</p>\n<p>分解子问题需要注意的点：</p>\n<ul>\n<li><p>具有相同的子问题：必须保证我们分割成的子问题也能按照相同的方法分割成更小的自问题， 并这些自问题的最终分割情况是可以解决的</p>\n</li>\n<li><p>满足最优子结构：就是一个决策的子决策也是最优的</p>\n</li>\n<li><p>无后效性：这是DP中最重要的一点， 他要求每个子问题的决策不能对后面其他未解决的问题产影响， 如果产生就无法保证决策的最优性， 这就是无后效性。往往需要我们找到一个合适的状态。（非常重要）</p>\n</li>\n</ul>\n<h3 id=\"Fibnacci数列\"><a href=\"#Fibnacci数列\" class=\"headerlink\" title=\"Fibnacci数列\"></a>Fibnacci数列</h3><p>在学习动态规划之前我根本不认为fibnacci数列是个动态规划题</p>\n<p>fibnacci数列: 1 1 2 3 5 8 13 … 当n大于2时，第n项等于前两项之和。</p>\n<p>所以递推公式为fn(n) = f(n-1)+(fn-2)</p>\n<h4 id=\"1-写出暴力递归（自顶向下）\"><a href=\"#1-写出暴力递归（自顶向下）\" class=\"headerlink\" title=\"1) 写出暴力递归（自顶向下）\"></a>1) 写出暴力递归（自顶向下）</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">long</span> <span class=\"title\">fib</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">2</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fib(n - <span class=\"number\">1</span>) + fib(n - <span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> start = System.currentTimeMillis();</span><br><span class=\"line\">    <span class=\"keyword\">long</span> i = fib(<span class=\"number\">10000</span>);</span><br><span class=\"line\">    <span class=\"keyword\">long</span> end = System.currentTimeMillis() - start;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"time:\"</span>+end + <span class=\"string\">\"ms,\"</span> + i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>时间复杂度：O(2^n)</p>\n<p>第一次：我将 n 设置了1000000直接爆栈</p>\n<p>第二次执行：n = 10000 ，时间很长我等不住了，强制退出</p>\n<p>第三次执行 n = 1000 ,依然很长时间，强制退出</p>\n<p>第四次执行 n = 50,运行结果：time:34397ms,12586269025</p>\n<p>只有前50项结果已经到达了13位数，所以暴力递归花费的时间是非常长的</p>\n<h4 id=\"2-找出冗余\"><a href=\"#2-找出冗余\" class=\"headerlink\" title=\"2) 找出冗余\"></a>2) 找出冗余</h4><p>冗余分析：分解为当前问题为 fn(n) = f(n-1)+(fn-2)后，每一次计算子问题f(n)（如递推式中的f(n - 1)）,都会重新计算n-1之前的子问题，导致重复计算。以n=10为例，要求得f(10)，需要求得f(9)和f(8)。同样，要求得f(9)，要先求得f(8)和f(7)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">           f(10)</span><br><span class=\"line\">         /        \\</span><br><span class=\"line\">       f(9)         f(8)</span><br><span class=\"line\">      /     \\       /    \\</span><br><span class=\"line\">   (8)     f(7)  f(7)   f(6)</span><br><span class=\"line\">  /   \\     /   \\ </span><br><span class=\"line\">f(7)  f(6)  f(6) f(5)</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-消除冗余（计划搜索）\"><a href=\"#3-消除冗余（计划搜索）\" class=\"headerlink\" title=\"3) 消除冗余（计划搜索）\"></a>3) 消除冗余（计划搜索）</h4><p>在每算过一个子问题之后，将结果记录，在下一个子问题需要需要计算同一个子问题时，直接将结果return</p>\n<p>代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">long</span>[] res; <span class=\"comment\">// 声明一个全局数组，存储计算过的子项</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">long</span> <span class=\"title\">fib</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">2</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(res[n] &gt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> res[n];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        res[n] =  fib(n - <span class=\"number\">1</span>) + fib(n - <span class=\"number\">2</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res[n];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> start = System.currentTimeMillis();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = <span class=\"number\">50</span>;</span><br><span class=\"line\">        res = <span class=\"keyword\">new</span> <span class=\"keyword\">long</span>[n+<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n;i++)&#123;  <span class=\"comment\">//初始化数组</span></span><br><span class=\"line\">            res[i] = -<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> r = fib(n);</span><br><span class=\"line\">        <span class=\"keyword\">long</span> end = System.currentTimeMillis() - start;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"time:\"</span>+end + <span class=\"string\">\"ms,\"</span> + r);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>同样求解 n= 50 ,运行结果：time:0ms,12586269025</p>\n<p>求解 n = 1000 ,运行结果：time:0ms,817770325994397771</p>\n<p>在经过消除冗余后，时间复杂度O(n)</p>\n<h4 id=\"4-转换为递推式（自底向上）\"><a href=\"#4-转换为递推式（自底向上）\" class=\"headerlink\" title=\"4) 转换为递推式（自底向上）\"></a>4) 转换为递推式（自底向上）</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> start = System.currentTimeMillis();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = <span class=\"number\">50</span>;</span><br><span class=\"line\">    <span class=\"keyword\">long</span>[] res = <span class=\"keyword\">new</span> <span class=\"keyword\">long</span>[n];</span><br><span class=\"line\">    res[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    res[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; i &lt; n;i++)&#123;</span><br><span class=\"line\">        res[i] = res[i - <span class=\"number\">1</span>] + res[i - <span class=\"number\">2</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">long</span> end = System.currentTimeMillis() - start;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"time:\"</span>+end + <span class=\"string\">\"ms,\"</span> + res[n -<span class=\"number\">1</span>]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"House-Robber-Leet-code-198\"><a href=\"#House-Robber-Leet-code-198\" class=\"headerlink\" title=\"House Robber(Leet code 198)\"></a>House Robber(Leet code 198)</h3><blockquote>\n<p>   You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.</p>\n</blockquote>\n<blockquote>\n<p>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.</p>\n</blockquote>\n<p>问题大意：</p>\n<p>你是一名专业的强盗，计划抢劫沿街的房屋。每间房屋都藏有一定数量的金钱，如果在同一晚上有两间相邻的房屋被闯入，它将自动与警方联系。<br>给出一份代表每个房屋的金额的非负整数列表，确定你可以在没有提醒警方的情况下抢劫的最高金额。</p>\n<p>问题分析：假设在抢劫第n家店时会有两种决策</p>\n<ul>\n<li><p>抢这家店，但是就不能抢下一家，抢到的金额加上当前这家店的金额，表达式 </p>\n</li>\n<li><p>不抢这家店，则直接跳过，抢劫金额不变</p>\n</li>\n</ul>\n<p>由于问题为抢劫金额最高，所以递归表达式为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">f(n) = Max(f(n- <span class=\"number\">2</span>) + value, f(n - <span class=\"number\">1</span>))</span><br></pre></td></tr></table></figure>\n<h4 id=\"1-暴力递归（自顶向下）\"><a href=\"#1-暴力递归（自顶向下）\" class=\"headerlink\" title=\"1) 暴力递归（自顶向下）\"></a>1) 暴力递归（自顶向下）</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">solve</span><span class=\"params\">(<span class=\"keyword\">int</span> idx, <span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (idx &lt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Math.max(nums[idx] + solve(idx - <span class=\"number\">2</span>, nums),solve(idx -<span class=\"number\">1</span> ,nums));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> start = System.currentTimeMillis();</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] nums = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;</span><br><span class=\"line\">            <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>, <span class=\"number\">3</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">9</span>, <span class=\"number\">3</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>,</span><br><span class=\"line\">            <span class=\"number\">7</span>, <span class=\"number\">9</span>, <span class=\"number\">3</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>, <span class=\"number\">3</span>, <span class=\"number\">12</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>, <span class=\"number\">3</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>,</span><br><span class=\"line\">            <span class=\"number\">12</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>, <span class=\"number\">3</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>, <span class=\"number\">3</span>, <span class=\"number\">12</span>, <span class=\"number\">7</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = solve(nums.length - <span class=\"number\">1</span>, nums);</span><br><span class=\"line\">    <span class=\"keyword\">long</span> end = System.currentTimeMillis() - start;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"time:\"</span> + end + <span class=\"string\">\"ms,\"</span> + res);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果：time:1471ms,135</p>\n<p>时间复杂度：O(2^n)</p>\n<h4 id=\"2-冗余分析\"><a href=\"#2-冗余分析\" class=\"headerlink\" title=\"2) 冗余分析\"></a>2) 冗余分析</h4><p>和Fibnaicc数列类似，每次执行搜索时，依赖子项重复计算，开启一个数组保存计算过的结果</p>\n<h4 id=\"4）消除冗余（计划搜索）\"><a href=\"#4）消除冗余（计划搜索）\" class=\"headerlink\" title=\"4）消除冗余（计划搜索）\"></a>4）消除冗余（计划搜索）</h4><p>将计算过的子项保存</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[] result;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">solve</span><span class=\"params\">(<span class=\"keyword\">int</span> idx, <span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (idx &lt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (result[idx] &gt;= <span class=\"number\">0</span>) <span class=\"keyword\">return</span> result[idx];</span><br><span class=\"line\">        result[idx] = Math.max(nums[idx] + solve(idx - <span class=\"number\">2</span>, nums),</span><br><span class=\"line\">            solve(idx - <span class=\"number\">1</span>, nums));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result[idx];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> start = System.currentTimeMillis();</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] nums = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;</span><br><span class=\"line\">            <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>, <span class=\"number\">3</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">9</span>, <span class=\"number\">3</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>,</span><br><span class=\"line\">            <span class=\"number\">7</span>, <span class=\"number\">9</span>, <span class=\"number\">3</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>, <span class=\"number\">3</span>, <span class=\"number\">12</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>, <span class=\"number\">3</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>,</span><br><span class=\"line\">            <span class=\"number\">12</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>, <span class=\"number\">3</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>, <span class=\"number\">3</span>, <span class=\"number\">12</span>, <span class=\"number\">7</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    result = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[nums.length];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class=\"line\">        result[i] = -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = solve(nums.length - <span class=\"number\">1</span>, nums);</span><br><span class=\"line\">    <span class=\"keyword\">long</span> end = System.currentTimeMillis() - start;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"time:\"</span> + end + <span class=\"string\">\"ms,\"</span> + res);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果：time:0ms,135</p>\n<p>时间复杂度：O(n)</p>\n<h4 id=\"5）转换为递推式（自底向上）\"><a href=\"#5）转换为递推式（自底向上）\" class=\"headerlink\" title=\"5）转换为递推式（自底向上）\"></a>5）转换为递推式（自底向上）</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> start = System.currentTimeMillis();</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] nums = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;</span><br><span class=\"line\">            <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>, <span class=\"number\">3</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">9</span>, <span class=\"number\">3</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>,</span><br><span class=\"line\">            <span class=\"number\">7</span>, <span class=\"number\">9</span>, <span class=\"number\">3</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>, <span class=\"number\">3</span>, <span class=\"number\">12</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>, <span class=\"number\">3</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>,</span><br><span class=\"line\">            <span class=\"number\">12</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>, <span class=\"number\">3</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>, <span class=\"number\">3</span>, <span class=\"number\">12</span>, <span class=\"number\">7</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"comment\">// a是上次的最大收益</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"comment\">// b是当前的最大受益</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> b = Math.max(nums[<span class=\"number\">0</span>], nums[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; i &lt; nums.length; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> tmp = b;</span><br><span class=\"line\">        <span class=\"comment\">// 当前的最大收益是两种选择里较大的那个</span></span><br><span class=\"line\">        b = Math.max(a + nums[i], b);</span><br><span class=\"line\">        a = tmp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> end = System.currentTimeMillis() - start;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"time:\"</span> + end + <span class=\"string\">\"ms,\"</span> + b);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果：time:0ms,135</p>\n<p>时间复杂度：O(n)</p>\n<p>​    </p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"动态规划一般流程\"><a href=\"#动态规划一般流程\" class=\"headerlink\" title=\"动态规划一般流程\"></a>动态规划一般流程</h3><p>说到动态规划我是拒绝的，一般来说都很恶心。。。</p>\n<p>DP的核心是将一个问题分解成为若干个子问题，解决一个动态规划大体分为三步：暴力搜索、查找冗余、消除冗余</p>\n<p>分解子问题需要注意的点：</p>\n<ul>\n<li><p>具有相同的子问题：必须保证我们分割成的子问题也能按照相同的方法分割成更小的自问题， 并这些自问题的最终分割情况是可以解决的</p>\n</li>\n<li><p>满足最优子结构：就是一个决策的子决策也是最优的</p>\n</li>\n<li><p>无后效性：这是DP中最重要的一点， 他要求每个子问题的决策不能对后面其他未解决的问题产影响， 如果产生就无法保证决策的最优性， 这就是无后效性。往往需要我们找到一个合适的状态。（非常重要）</p>\n</li>\n</ul>\n<h3 id=\"Fibnacci数列\"><a href=\"#Fibnacci数列\" class=\"headerlink\" title=\"Fibnacci数列\"></a>Fibnacci数列</h3><p>在学习动态规划之前我根本不认为fibnacci数列是个动态规划题</p>\n<p>fibnacci数列: 1 1 2 3 5 8 13 … 当n大于2时，第n项等于前两项之和。</p>\n<p>所以递推公式为fn(n) = f(n-1)+(fn-2)</p>\n<h4 id=\"1-写出暴力递归（自顶向下）\"><a href=\"#1-写出暴力递归（自顶向下）\" class=\"headerlink\" title=\"1) 写出暴力递归（自顶向下）\"></a>1) 写出暴力递归（自顶向下）</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">long</span> <span class=\"title\">fib</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">2</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fib(n - <span class=\"number\">1</span>) + fib(n - <span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> start = System.currentTimeMillis();</span><br><span class=\"line\">    <span class=\"keyword\">long</span> i = fib(<span class=\"number\">10000</span>);</span><br><span class=\"line\">    <span class=\"keyword\">long</span> end = System.currentTimeMillis() - start;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"time:\"</span>+end + <span class=\"string\">\"ms,\"</span> + i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>时间复杂度：O(2^n)</p>\n<p>第一次：我将 n 设置了1000000直接爆栈</p>\n<p>第二次执行：n = 10000 ，时间很长我等不住了，强制退出</p>\n<p>第三次执行 n = 1000 ,依然很长时间，强制退出</p>\n<p>第四次执行 n = 50,运行结果：time:34397ms,12586269025</p>\n<p>只有前50项结果已经到达了13位数，所以暴力递归花费的时间是非常长的</p>\n<h4 id=\"2-找出冗余\"><a href=\"#2-找出冗余\" class=\"headerlink\" title=\"2) 找出冗余\"></a>2) 找出冗余</h4><p>冗余分析：分解为当前问题为 fn(n) = f(n-1)+(fn-2)后，每一次计算子问题f(n)（如递推式中的f(n - 1)）,都会重新计算n-1之前的子问题，导致重复计算。以n=10为例，要求得f(10)，需要求得f(9)和f(8)。同样，要求得f(9)，要先求得f(8)和f(7)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">           f(10)</span><br><span class=\"line\">         /        \\</span><br><span class=\"line\">       f(9)         f(8)</span><br><span class=\"line\">      /     \\       /    \\</span><br><span class=\"line\">   (8)     f(7)  f(7)   f(6)</span><br><span class=\"line\">  /   \\     /   \\ </span><br><span class=\"line\">f(7)  f(6)  f(6) f(5)</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-消除冗余（计划搜索）\"><a href=\"#3-消除冗余（计划搜索）\" class=\"headerlink\" title=\"3) 消除冗余（计划搜索）\"></a>3) 消除冗余（计划搜索）</h4><p>在每算过一个子问题之后，将结果记录，在下一个子问题需要需要计算同一个子问题时，直接将结果return</p>\n<p>代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">long</span>[] res; <span class=\"comment\">// 声明一个全局数组，存储计算过的子项</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">long</span> <span class=\"title\">fib</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">2</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(res[n] &gt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> res[n];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        res[n] =  fib(n - <span class=\"number\">1</span>) + fib(n - <span class=\"number\">2</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res[n];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> start = System.currentTimeMillis();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = <span class=\"number\">50</span>;</span><br><span class=\"line\">        res = <span class=\"keyword\">new</span> <span class=\"keyword\">long</span>[n+<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n;i++)&#123;  <span class=\"comment\">//初始化数组</span></span><br><span class=\"line\">            res[i] = -<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> r = fib(n);</span><br><span class=\"line\">        <span class=\"keyword\">long</span> end = System.currentTimeMillis() - start;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"time:\"</span>+end + <span class=\"string\">\"ms,\"</span> + r);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>同样求解 n= 50 ,运行结果：time:0ms,12586269025</p>\n<p>求解 n = 1000 ,运行结果：time:0ms,817770325994397771</p>\n<p>在经过消除冗余后，时间复杂度O(n)</p>\n<h4 id=\"4-转换为递推式（自底向上）\"><a href=\"#4-转换为递推式（自底向上）\" class=\"headerlink\" title=\"4) 转换为递推式（自底向上）\"></a>4) 转换为递推式（自底向上）</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> start = System.currentTimeMillis();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = <span class=\"number\">50</span>;</span><br><span class=\"line\">    <span class=\"keyword\">long</span>[] res = <span class=\"keyword\">new</span> <span class=\"keyword\">long</span>[n];</span><br><span class=\"line\">    res[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    res[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; i &lt; n;i++)&#123;</span><br><span class=\"line\">        res[i] = res[i - <span class=\"number\">1</span>] + res[i - <span class=\"number\">2</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">long</span> end = System.currentTimeMillis() - start;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"time:\"</span>+end + <span class=\"string\">\"ms,\"</span> + res[n -<span class=\"number\">1</span>]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"House-Robber-Leet-code-198\"><a href=\"#House-Robber-Leet-code-198\" class=\"headerlink\" title=\"House Robber(Leet code 198)\"></a>House Robber(Leet code 198)</h3><blockquote>\n<p>   You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.</p>\n</blockquote>\n<blockquote>\n<p>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.</p>\n</blockquote>\n<p>问题大意：</p>\n<p>你是一名专业的强盗，计划抢劫沿街的房屋。每间房屋都藏有一定数量的金钱，如果在同一晚上有两间相邻的房屋被闯入，它将自动与警方联系。<br>给出一份代表每个房屋的金额的非负整数列表，确定你可以在没有提醒警方的情况下抢劫的最高金额。</p>\n<p>问题分析：假设在抢劫第n家店时会有两种决策</p>\n<ul>\n<li><p>抢这家店，但是就不能抢下一家，抢到的金额加上当前这家店的金额，表达式 </p>\n</li>\n<li><p>不抢这家店，则直接跳过，抢劫金额不变</p>\n</li>\n</ul>\n<p>由于问题为抢劫金额最高，所以递归表达式为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">f(n) = Max(f(n- <span class=\"number\">2</span>) + value, f(n - <span class=\"number\">1</span>))</span><br></pre></td></tr></table></figure>\n<h4 id=\"1-暴力递归（自顶向下）\"><a href=\"#1-暴力递归（自顶向下）\" class=\"headerlink\" title=\"1) 暴力递归（自顶向下）\"></a>1) 暴力递归（自顶向下）</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">solve</span><span class=\"params\">(<span class=\"keyword\">int</span> idx, <span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (idx &lt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Math.max(nums[idx] + solve(idx - <span class=\"number\">2</span>, nums),solve(idx -<span class=\"number\">1</span> ,nums));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> start = System.currentTimeMillis();</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] nums = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;</span><br><span class=\"line\">            <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>, <span class=\"number\">3</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">9</span>, <span class=\"number\">3</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>,</span><br><span class=\"line\">            <span class=\"number\">7</span>, <span class=\"number\">9</span>, <span class=\"number\">3</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>, <span class=\"number\">3</span>, <span class=\"number\">12</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>, <span class=\"number\">3</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>,</span><br><span class=\"line\">            <span class=\"number\">12</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>, <span class=\"number\">3</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>, <span class=\"number\">3</span>, <span class=\"number\">12</span>, <span class=\"number\">7</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = solve(nums.length - <span class=\"number\">1</span>, nums);</span><br><span class=\"line\">    <span class=\"keyword\">long</span> end = System.currentTimeMillis() - start;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"time:\"</span> + end + <span class=\"string\">\"ms,\"</span> + res);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果：time:1471ms,135</p>\n<p>时间复杂度：O(2^n)</p>\n<h4 id=\"2-冗余分析\"><a href=\"#2-冗余分析\" class=\"headerlink\" title=\"2) 冗余分析\"></a>2) 冗余分析</h4><p>和Fibnaicc数列类似，每次执行搜索时，依赖子项重复计算，开启一个数组保存计算过的结果</p>\n<h4 id=\"4）消除冗余（计划搜索）\"><a href=\"#4）消除冗余（计划搜索）\" class=\"headerlink\" title=\"4）消除冗余（计划搜索）\"></a>4）消除冗余（计划搜索）</h4><p>将计算过的子项保存</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[] result;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">solve</span><span class=\"params\">(<span class=\"keyword\">int</span> idx, <span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (idx &lt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (result[idx] &gt;= <span class=\"number\">0</span>) <span class=\"keyword\">return</span> result[idx];</span><br><span class=\"line\">        result[idx] = Math.max(nums[idx] + solve(idx - <span class=\"number\">2</span>, nums),</span><br><span class=\"line\">            solve(idx - <span class=\"number\">1</span>, nums));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result[idx];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> start = System.currentTimeMillis();</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] nums = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;</span><br><span class=\"line\">            <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>, <span class=\"number\">3</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">9</span>, <span class=\"number\">3</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>,</span><br><span class=\"line\">            <span class=\"number\">7</span>, <span class=\"number\">9</span>, <span class=\"number\">3</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>, <span class=\"number\">3</span>, <span class=\"number\">12</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>, <span class=\"number\">3</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>,</span><br><span class=\"line\">            <span class=\"number\">12</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>, <span class=\"number\">3</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>, <span class=\"number\">3</span>, <span class=\"number\">12</span>, <span class=\"number\">7</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    result = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[nums.length];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class=\"line\">        result[i] = -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = solve(nums.length - <span class=\"number\">1</span>, nums);</span><br><span class=\"line\">    <span class=\"keyword\">long</span> end = System.currentTimeMillis() - start;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"time:\"</span> + end + <span class=\"string\">\"ms,\"</span> + res);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果：time:0ms,135</p>\n<p>时间复杂度：O(n)</p>\n<h4 id=\"5）转换为递推式（自底向上）\"><a href=\"#5）转换为递推式（自底向上）\" class=\"headerlink\" title=\"5）转换为递推式（自底向上）\"></a>5）转换为递推式（自底向上）</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> start = System.currentTimeMillis();</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] nums = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;</span><br><span class=\"line\">            <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>, <span class=\"number\">3</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">9</span>, <span class=\"number\">3</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>,</span><br><span class=\"line\">            <span class=\"number\">7</span>, <span class=\"number\">9</span>, <span class=\"number\">3</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>, <span class=\"number\">3</span>, <span class=\"number\">12</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>, <span class=\"number\">3</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>,</span><br><span class=\"line\">            <span class=\"number\">12</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>, <span class=\"number\">3</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>, <span class=\"number\">3</span>, <span class=\"number\">12</span>, <span class=\"number\">7</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"comment\">// a是上次的最大收益</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"comment\">// b是当前的最大受益</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> b = Math.max(nums[<span class=\"number\">0</span>], nums[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; i &lt; nums.length; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> tmp = b;</span><br><span class=\"line\">        <span class=\"comment\">// 当前的最大收益是两种选择里较大的那个</span></span><br><span class=\"line\">        b = Math.max(a + nums[i], b);</span><br><span class=\"line\">        a = tmp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> end = System.currentTimeMillis() - start;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"time:\"</span> + end + <span class=\"string\">\"ms,\"</span> + b);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行结果：time:0ms,135</p>\n<p>时间复杂度：O(n)</p>\n<p>​    </p>\n"},{"layout":"post","title":"Navicat | show variables like'char%' 字符集无法更改导致乱码","date":"2018-03-03T06:02:00.000Z","author":"Gubaidan","header-img":"/Header/hero@2x.jpg","cdn":"header-on","_content":"\n## BUG FIX\n\n今天用python把一个txt文件中的数据导入到Mysql，因为txt中包含中文信息，导致中文乱码。\n\n- Mysql版本：5.7.22\n- 远程系统 ：CentOS Linux release 7.4.1708 (Core) \n- 本机系统 : MacOS 10.13.5\n- Navicat : 11.8\n- python 3.6\n\n导入中文乱码之后，查了一下远程Mysql的数据库编码：\n\n```sql\nmysql> SHOW VARIABLES LIKE 'character%';\n+--------------------------+----------------------------------+\n| Variable_name            | Value                            |\n+--------------------------+----------------------------------+\n| character_set_client     | latin1                           |\n| character_set_connection | latin1                           |\n| character_set_database   | utf8                             |\n| character_set_filesystem | binary                           |\n| character_set_results    | latin1                           |\n| character_set_server     | utf8                             |\n| character_set_system     | utf8                             |\n| character_sets_dir       | /usr/local/mysql/share/charsets/ |\n+--------------------------+----------------------------------+\n8 rows in set (0.00 sec)\n```\n\n发现有三个编码是Latin1，于是更改Mysql配置文件my.inf\n\n```ini\n[mysqld] \ncharacter_set_server=utf8   #这里不能写成 default-character-set=utf8\ninit-connect='set names utf8'\ncollation-server = utf8_general_ci\n\n[mysql]\ndefault-character-set = utf8\n\n[client]\ndefault-character-set=utf8\n```\n\n因Mysql5.7 之后 [mysqld] 中配置 default-character-set=utf8 将会报错。\n\n修改完成之后重启mysql：\n\n```sql\nmysql> SHOW VARIABLES LIKE 'character%';\n+--------------------------+----------------------------------+\n| Variable_name            | Value                            |\n+--------------------------+----------------------------------+\n| character_set_client     | utf8                             |\n| character_set_connection | utf8                             |\n| character_set_database   | utf8                             |\n| character_set_filesystem | binary                           |\n| character_set_results    | utf8                             |\n| character_set_server     | utf8                             |\n| character_set_system     | utf8                             |\n| character_sets_dir       | /usr/local/mysql/share/charsets/ |\n+--------------------------+----------------------------------+\n8 rows in set (0.00 sec)\n```\n\n但是更改之后，远程mysql数据库所有编码字符集正常，但是在navicat仍然显示：\n\n```sql\nmysql> SHOW VARIABLES LIKE 'character%';\n+--------------------------+----------------------------------+\n| Variable_name            | Value                            |\n+--------------------------+----------------------------------+\n| character_set_client     | latin1                           |\n| character_set_connection | latin1                           |\n| character_set_database   | utf8                             |\n| character_set_filesystem | binary                           |\n| character_set_results    | latin1                           |\n| character_set_server     | utf8                             |\n| character_set_system     | utf8                             |\n| character_sets_dir       | /usr/local/mysql/share/charsets/ |\n+--------------------------+----------------------------------+\n8 rows in set (0.00 sec)\n```\n\n当然，我是用navicat图形界面查的，但是结果和这个是一样的。\n\n测试了一下，导入数据后中文依旧乱码，而且在navicat 右键打开的数据库连接属性中 字符集也是utf8，既然字符集都是一样的，为什么还会出现乱码，百思不解。\n\n因为怀疑是python处理文件时出错，特地排查了一下python\n\npython文件读取：\n\n```python\n    with open('/Users/xxxx.txt', 'r', encoding=\"utf8\") as txt:\n        for line in txt:\n```\n\n存入数据库：\n\n```python\ntry:\n\tengine_route = create_engine(\"mysql+pymysql://用户名:密码@host:3306/数据库?charset=utf8\",\n                                     max_overflow=5)\n\tpd.io.sql.to_sql(result, name='hostel', con=engine_route, if_exists='append',\n                         index=False, index_label=False, schema='DoubleG', chunksize=10000)\nfinally:\n\tdel result\n```\n\n因为都设置的是utf8，之间测试过，把上述编码改为 latin1 ，依然乱码。\n\n本着试试又不会死的原则，我把navicat数据库连接中的 编码集由**utf-8 改为 自动**，再次查询Navicat：\n\n```sql\nmysql> SHOW VARIABLES LIKE 'character%';\n+--------------------------+----------------------------------+\n| Variable_name            | Value                            |\n+--------------------------+----------------------------------+\n| character_set_client     | utf8                             |\n| character_set_connection | utf8                             |\n| character_set_database   | utf8                             |\n| character_set_filesystem | binary                           |\n| character_set_results    | utf8                             |\n| character_set_server     | utf8                             |\n| character_set_system     | utf8                             |\n| character_sets_dir       | /usr/local/mysql/share/charsets/ |\n+--------------------------+----------------------------------+\n8 rows in set (0.00 sec)\n```\n\n结果正常，数据测试正常。\n\n## 总结\n\nMac 版Navicat 貌似和windows不同，windows中数据库连接中将字符编码改为utf8就能解决问题（当然前提是配置好mysql数据库编码），而mac版编码必须自动。\n\n\n\n","source":"_posts/2018-03-03-navicat-utf8.markdown","raw":"---\nlayout: post\ntitle: \"Navicat | show variables like'char%' 字符集无法更改导致乱码\"\ndate: 2018-03-03 14:02\nauthor: \"Gubaidan\"\nheader-img: \"/Header/hero@2x.jpg\"\ncdn: 'header-on'\ntags:\n        - mysql\n---\n\n## BUG FIX\n\n今天用python把一个txt文件中的数据导入到Mysql，因为txt中包含中文信息，导致中文乱码。\n\n- Mysql版本：5.7.22\n- 远程系统 ：CentOS Linux release 7.4.1708 (Core) \n- 本机系统 : MacOS 10.13.5\n- Navicat : 11.8\n- python 3.6\n\n导入中文乱码之后，查了一下远程Mysql的数据库编码：\n\n```sql\nmysql> SHOW VARIABLES LIKE 'character%';\n+--------------------------+----------------------------------+\n| Variable_name            | Value                            |\n+--------------------------+----------------------------------+\n| character_set_client     | latin1                           |\n| character_set_connection | latin1                           |\n| character_set_database   | utf8                             |\n| character_set_filesystem | binary                           |\n| character_set_results    | latin1                           |\n| character_set_server     | utf8                             |\n| character_set_system     | utf8                             |\n| character_sets_dir       | /usr/local/mysql/share/charsets/ |\n+--------------------------+----------------------------------+\n8 rows in set (0.00 sec)\n```\n\n发现有三个编码是Latin1，于是更改Mysql配置文件my.inf\n\n```ini\n[mysqld] \ncharacter_set_server=utf8   #这里不能写成 default-character-set=utf8\ninit-connect='set names utf8'\ncollation-server = utf8_general_ci\n\n[mysql]\ndefault-character-set = utf8\n\n[client]\ndefault-character-set=utf8\n```\n\n因Mysql5.7 之后 [mysqld] 中配置 default-character-set=utf8 将会报错。\n\n修改完成之后重启mysql：\n\n```sql\nmysql> SHOW VARIABLES LIKE 'character%';\n+--------------------------+----------------------------------+\n| Variable_name            | Value                            |\n+--------------------------+----------------------------------+\n| character_set_client     | utf8                             |\n| character_set_connection | utf8                             |\n| character_set_database   | utf8                             |\n| character_set_filesystem | binary                           |\n| character_set_results    | utf8                             |\n| character_set_server     | utf8                             |\n| character_set_system     | utf8                             |\n| character_sets_dir       | /usr/local/mysql/share/charsets/ |\n+--------------------------+----------------------------------+\n8 rows in set (0.00 sec)\n```\n\n但是更改之后，远程mysql数据库所有编码字符集正常，但是在navicat仍然显示：\n\n```sql\nmysql> SHOW VARIABLES LIKE 'character%';\n+--------------------------+----------------------------------+\n| Variable_name            | Value                            |\n+--------------------------+----------------------------------+\n| character_set_client     | latin1                           |\n| character_set_connection | latin1                           |\n| character_set_database   | utf8                             |\n| character_set_filesystem | binary                           |\n| character_set_results    | latin1                           |\n| character_set_server     | utf8                             |\n| character_set_system     | utf8                             |\n| character_sets_dir       | /usr/local/mysql/share/charsets/ |\n+--------------------------+----------------------------------+\n8 rows in set (0.00 sec)\n```\n\n当然，我是用navicat图形界面查的，但是结果和这个是一样的。\n\n测试了一下，导入数据后中文依旧乱码，而且在navicat 右键打开的数据库连接属性中 字符集也是utf8，既然字符集都是一样的，为什么还会出现乱码，百思不解。\n\n因为怀疑是python处理文件时出错，特地排查了一下python\n\npython文件读取：\n\n```python\n    with open('/Users/xxxx.txt', 'r', encoding=\"utf8\") as txt:\n        for line in txt:\n```\n\n存入数据库：\n\n```python\ntry:\n\tengine_route = create_engine(\"mysql+pymysql://用户名:密码@host:3306/数据库?charset=utf8\",\n                                     max_overflow=5)\n\tpd.io.sql.to_sql(result, name='hostel', con=engine_route, if_exists='append',\n                         index=False, index_label=False, schema='DoubleG', chunksize=10000)\nfinally:\n\tdel result\n```\n\n因为都设置的是utf8，之间测试过，把上述编码改为 latin1 ，依然乱码。\n\n本着试试又不会死的原则，我把navicat数据库连接中的 编码集由**utf-8 改为 自动**，再次查询Navicat：\n\n```sql\nmysql> SHOW VARIABLES LIKE 'character%';\n+--------------------------+----------------------------------+\n| Variable_name            | Value                            |\n+--------------------------+----------------------------------+\n| character_set_client     | utf8                             |\n| character_set_connection | utf8                             |\n| character_set_database   | utf8                             |\n| character_set_filesystem | binary                           |\n| character_set_results    | utf8                             |\n| character_set_server     | utf8                             |\n| character_set_system     | utf8                             |\n| character_sets_dir       | /usr/local/mysql/share/charsets/ |\n+--------------------------+----------------------------------+\n8 rows in set (0.00 sec)\n```\n\n结果正常，数据测试正常。\n\n## 总结\n\nMac 版Navicat 貌似和windows不同，windows中数据库连接中将字符编码改为utf8就能解决问题（当然前提是配置好mysql数据库编码），而mac版编码必须自动。\n\n\n\n","slug":"2018-03-03-navicat-utf8","published":1,"updated":"2018-07-14T07:35:06.186Z","comments":1,"photos":[],"link":"","_id":"cjvayvwfc000bm46a95gmp7lw","content":"<h2 id=\"BUG-FIX\"><a href=\"#BUG-FIX\" class=\"headerlink\" title=\"BUG FIX\"></a>BUG FIX</h2><p>今天用python把一个txt文件中的数据导入到Mysql，因为txt中包含中文信息，导致中文乱码。</p>\n<ul>\n<li>Mysql版本：5.7.22</li>\n<li>远程系统 ：CentOS Linux release 7.4.1708 (Core) </li>\n<li>本机系统 : MacOS 10.13.5</li>\n<li>Navicat : 11.8</li>\n<li>python 3.6</li>\n</ul>\n<p>导入中文乱码之后，查了一下远程Mysql的数据库编码：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysql&gt; SHOW VARIABLES LIKE 'character%';</span><br><span class=\"line\">+<span class=\"comment\">--------------------------+----------------------------------+</span></span><br><span class=\"line\">| Variable_name            | Value                            |</span><br><span class=\"line\">+<span class=\"comment\">--------------------------+----------------------------------+</span></span><br><span class=\"line\">| character_set_client     | latin1                           |</span><br><span class=\"line\">| character_set_connection | latin1                           |</span><br><span class=\"line\">| character_set_database   | utf8                             |</span><br><span class=\"line\">| character_set_filesystem | binary                           |</span><br><span class=\"line\">| character_set_results    | latin1                           |</span><br><span class=\"line\">| character_set_server     | utf8                             |</span><br><span class=\"line\">| character_set_system     | utf8                             |</span><br><span class=\"line\">| character_sets_dir       | /usr/local/mysql/share/charsets/ |</span><br><span class=\"line\">+<span class=\"comment\">--------------------------+----------------------------------+</span></span><br><span class=\"line\">8 rows in <span class=\"keyword\">set</span> (<span class=\"number\">0.00</span> sec)</span><br></pre></td></tr></table></figure>\n<p>发现有三个编码是Latin1，于是更改Mysql配置文件my.inf</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">[mysqld]</span> </span><br><span class=\"line\"><span class=\"attr\">character_set_server</span>=utf8   #这里不能写成 default-character-set=utf8</span><br><span class=\"line\"><span class=\"attr\">init-connect</span>=<span class=\"string\">'set names utf8'</span></span><br><span class=\"line\"><span class=\"attr\">collation-server</span> = utf8_general_ci</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">[mysql]</span></span><br><span class=\"line\"><span class=\"attr\">default-character-set</span> = utf8</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">[client]</span></span><br><span class=\"line\"><span class=\"attr\">default-character-set</span>=utf8</span><br></pre></td></tr></table></figure>\n<p>因Mysql5.7 之后 [mysqld] 中配置 default-character-set=utf8 将会报错。</p>\n<p>修改完成之后重启mysql：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysql&gt; SHOW VARIABLES LIKE 'character%';</span><br><span class=\"line\">+<span class=\"comment\">--------------------------+----------------------------------+</span></span><br><span class=\"line\">| Variable_name            | Value                            |</span><br><span class=\"line\">+<span class=\"comment\">--------------------------+----------------------------------+</span></span><br><span class=\"line\">| character_set_client     | utf8                             |</span><br><span class=\"line\">| character_set_connection | utf8                             |</span><br><span class=\"line\">| character_set_database   | utf8                             |</span><br><span class=\"line\">| character_set_filesystem | binary                           |</span><br><span class=\"line\">| character_set_results    | utf8                             |</span><br><span class=\"line\">| character_set_server     | utf8                             |</span><br><span class=\"line\">| character_set_system     | utf8                             |</span><br><span class=\"line\">| character_sets_dir       | /usr/local/mysql/share/charsets/ |</span><br><span class=\"line\">+<span class=\"comment\">--------------------------+----------------------------------+</span></span><br><span class=\"line\">8 rows in <span class=\"keyword\">set</span> (<span class=\"number\">0.00</span> sec)</span><br></pre></td></tr></table></figure>\n<p>但是更改之后，远程mysql数据库所有编码字符集正常，但是在navicat仍然显示：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysql&gt; SHOW VARIABLES LIKE 'character%';</span><br><span class=\"line\">+<span class=\"comment\">--------------------------+----------------------------------+</span></span><br><span class=\"line\">| Variable_name            | Value                            |</span><br><span class=\"line\">+<span class=\"comment\">--------------------------+----------------------------------+</span></span><br><span class=\"line\">| character_set_client     | latin1                           |</span><br><span class=\"line\">| character_set_connection | latin1                           |</span><br><span class=\"line\">| character_set_database   | utf8                             |</span><br><span class=\"line\">| character_set_filesystem | binary                           |</span><br><span class=\"line\">| character_set_results    | latin1                           |</span><br><span class=\"line\">| character_set_server     | utf8                             |</span><br><span class=\"line\">| character_set_system     | utf8                             |</span><br><span class=\"line\">| character_sets_dir       | /usr/local/mysql/share/charsets/ |</span><br><span class=\"line\">+<span class=\"comment\">--------------------------+----------------------------------+</span></span><br><span class=\"line\">8 rows in <span class=\"keyword\">set</span> (<span class=\"number\">0.00</span> sec)</span><br></pre></td></tr></table></figure>\n<p>当然，我是用navicat图形界面查的，但是结果和这个是一样的。</p>\n<p>测试了一下，导入数据后中文依旧乱码，而且在navicat 右键打开的数据库连接属性中 字符集也是utf8，既然字符集都是一样的，为什么还会出现乱码，百思不解。</p>\n<p>因为怀疑是python处理文件时出错，特地排查了一下python</p>\n<p>python文件读取：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">with</span> open(<span class=\"string\">'/Users/xxxx.txt'</span>, <span class=\"string\">'r'</span>, encoding=<span class=\"string\">\"utf8\"</span>) <span class=\"keyword\">as</span> txt:</span><br><span class=\"line\">    <span class=\"keyword\">for</span> line <span class=\"keyword\">in</span> txt:</span><br></pre></td></tr></table></figure>\n<p>存入数据库：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span>:</span><br><span class=\"line\">\tengine_route = create_engine(<span class=\"string\">\"mysql+pymysql://用户名:密码@host:3306/数据库?charset=utf8\"</span>,</span><br><span class=\"line\">                                     max_overflow=<span class=\"number\">5</span>)</span><br><span class=\"line\">\tpd.io.sql.to_sql(result, name=<span class=\"string\">'hostel'</span>, con=engine_route, if_exists=<span class=\"string\">'append'</span>,</span><br><span class=\"line\">                         index=<span class=\"keyword\">False</span>, index_label=<span class=\"keyword\">False</span>, schema=<span class=\"string\">'DoubleG'</span>, chunksize=<span class=\"number\">10000</span>)</span><br><span class=\"line\"><span class=\"keyword\">finally</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">del</span> result</span><br></pre></td></tr></table></figure>\n<p>因为都设置的是utf8，之间测试过，把上述编码改为 latin1 ，依然乱码。</p>\n<p>本着试试又不会死的原则，我把navicat数据库连接中的 编码集由<strong>utf-8 改为 自动</strong>，再次查询Navicat：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysql&gt; SHOW VARIABLES LIKE 'character%';</span><br><span class=\"line\">+<span class=\"comment\">--------------------------+----------------------------------+</span></span><br><span class=\"line\">| Variable_name            | Value                            |</span><br><span class=\"line\">+<span class=\"comment\">--------------------------+----------------------------------+</span></span><br><span class=\"line\">| character_set_client     | utf8                             |</span><br><span class=\"line\">| character_set_connection | utf8                             |</span><br><span class=\"line\">| character_set_database   | utf8                             |</span><br><span class=\"line\">| character_set_filesystem | binary                           |</span><br><span class=\"line\">| character_set_results    | utf8                             |</span><br><span class=\"line\">| character_set_server     | utf8                             |</span><br><span class=\"line\">| character_set_system     | utf8                             |</span><br><span class=\"line\">| character_sets_dir       | /usr/local/mysql/share/charsets/ |</span><br><span class=\"line\">+<span class=\"comment\">--------------------------+----------------------------------+</span></span><br><span class=\"line\">8 rows in <span class=\"keyword\">set</span> (<span class=\"number\">0.00</span> sec)</span><br></pre></td></tr></table></figure>\n<p>结果正常，数据测试正常。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>Mac 版Navicat 貌似和windows不同，windows中数据库连接中将字符编码改为utf8就能解决问题（当然前提是配置好mysql数据库编码），而mac版编码必须自动。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"BUG-FIX\"><a href=\"#BUG-FIX\" class=\"headerlink\" title=\"BUG FIX\"></a>BUG FIX</h2><p>今天用python把一个txt文件中的数据导入到Mysql，因为txt中包含中文信息，导致中文乱码。</p>\n<ul>\n<li>Mysql版本：5.7.22</li>\n<li>远程系统 ：CentOS Linux release 7.4.1708 (Core) </li>\n<li>本机系统 : MacOS 10.13.5</li>\n<li>Navicat : 11.8</li>\n<li>python 3.6</li>\n</ul>\n<p>导入中文乱码之后，查了一下远程Mysql的数据库编码：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysql&gt; SHOW VARIABLES LIKE 'character%';</span><br><span class=\"line\">+<span class=\"comment\">--------------------------+----------------------------------+</span></span><br><span class=\"line\">| Variable_name            | Value                            |</span><br><span class=\"line\">+<span class=\"comment\">--------------------------+----------------------------------+</span></span><br><span class=\"line\">| character_set_client     | latin1                           |</span><br><span class=\"line\">| character_set_connection | latin1                           |</span><br><span class=\"line\">| character_set_database   | utf8                             |</span><br><span class=\"line\">| character_set_filesystem | binary                           |</span><br><span class=\"line\">| character_set_results    | latin1                           |</span><br><span class=\"line\">| character_set_server     | utf8                             |</span><br><span class=\"line\">| character_set_system     | utf8                             |</span><br><span class=\"line\">| character_sets_dir       | /usr/local/mysql/share/charsets/ |</span><br><span class=\"line\">+<span class=\"comment\">--------------------------+----------------------------------+</span></span><br><span class=\"line\">8 rows in <span class=\"keyword\">set</span> (<span class=\"number\">0.00</span> sec)</span><br></pre></td></tr></table></figure>\n<p>发现有三个编码是Latin1，于是更改Mysql配置文件my.inf</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">[mysqld]</span> </span><br><span class=\"line\"><span class=\"attr\">character_set_server</span>=utf8   #这里不能写成 default-character-set=utf8</span><br><span class=\"line\"><span class=\"attr\">init-connect</span>=<span class=\"string\">'set names utf8'</span></span><br><span class=\"line\"><span class=\"attr\">collation-server</span> = utf8_general_ci</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">[mysql]</span></span><br><span class=\"line\"><span class=\"attr\">default-character-set</span> = utf8</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">[client]</span></span><br><span class=\"line\"><span class=\"attr\">default-character-set</span>=utf8</span><br></pre></td></tr></table></figure>\n<p>因Mysql5.7 之后 [mysqld] 中配置 default-character-set=utf8 将会报错。</p>\n<p>修改完成之后重启mysql：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysql&gt; SHOW VARIABLES LIKE 'character%';</span><br><span class=\"line\">+<span class=\"comment\">--------------------------+----------------------------------+</span></span><br><span class=\"line\">| Variable_name            | Value                            |</span><br><span class=\"line\">+<span class=\"comment\">--------------------------+----------------------------------+</span></span><br><span class=\"line\">| character_set_client     | utf8                             |</span><br><span class=\"line\">| character_set_connection | utf8                             |</span><br><span class=\"line\">| character_set_database   | utf8                             |</span><br><span class=\"line\">| character_set_filesystem | binary                           |</span><br><span class=\"line\">| character_set_results    | utf8                             |</span><br><span class=\"line\">| character_set_server     | utf8                             |</span><br><span class=\"line\">| character_set_system     | utf8                             |</span><br><span class=\"line\">| character_sets_dir       | /usr/local/mysql/share/charsets/ |</span><br><span class=\"line\">+<span class=\"comment\">--------------------------+----------------------------------+</span></span><br><span class=\"line\">8 rows in <span class=\"keyword\">set</span> (<span class=\"number\">0.00</span> sec)</span><br></pre></td></tr></table></figure>\n<p>但是更改之后，远程mysql数据库所有编码字符集正常，但是在navicat仍然显示：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysql&gt; SHOW VARIABLES LIKE 'character%';</span><br><span class=\"line\">+<span class=\"comment\">--------------------------+----------------------------------+</span></span><br><span class=\"line\">| Variable_name            | Value                            |</span><br><span class=\"line\">+<span class=\"comment\">--------------------------+----------------------------------+</span></span><br><span class=\"line\">| character_set_client     | latin1                           |</span><br><span class=\"line\">| character_set_connection | latin1                           |</span><br><span class=\"line\">| character_set_database   | utf8                             |</span><br><span class=\"line\">| character_set_filesystem | binary                           |</span><br><span class=\"line\">| character_set_results    | latin1                           |</span><br><span class=\"line\">| character_set_server     | utf8                             |</span><br><span class=\"line\">| character_set_system     | utf8                             |</span><br><span class=\"line\">| character_sets_dir       | /usr/local/mysql/share/charsets/ |</span><br><span class=\"line\">+<span class=\"comment\">--------------------------+----------------------------------+</span></span><br><span class=\"line\">8 rows in <span class=\"keyword\">set</span> (<span class=\"number\">0.00</span> sec)</span><br></pre></td></tr></table></figure>\n<p>当然，我是用navicat图形界面查的，但是结果和这个是一样的。</p>\n<p>测试了一下，导入数据后中文依旧乱码，而且在navicat 右键打开的数据库连接属性中 字符集也是utf8，既然字符集都是一样的，为什么还会出现乱码，百思不解。</p>\n<p>因为怀疑是python处理文件时出错，特地排查了一下python</p>\n<p>python文件读取：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">with</span> open(<span class=\"string\">'/Users/xxxx.txt'</span>, <span class=\"string\">'r'</span>, encoding=<span class=\"string\">\"utf8\"</span>) <span class=\"keyword\">as</span> txt:</span><br><span class=\"line\">    <span class=\"keyword\">for</span> line <span class=\"keyword\">in</span> txt:</span><br></pre></td></tr></table></figure>\n<p>存入数据库：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span>:</span><br><span class=\"line\">\tengine_route = create_engine(<span class=\"string\">\"mysql+pymysql://用户名:密码@host:3306/数据库?charset=utf8\"</span>,</span><br><span class=\"line\">                                     max_overflow=<span class=\"number\">5</span>)</span><br><span class=\"line\">\tpd.io.sql.to_sql(result, name=<span class=\"string\">'hostel'</span>, con=engine_route, if_exists=<span class=\"string\">'append'</span>,</span><br><span class=\"line\">                         index=<span class=\"keyword\">False</span>, index_label=<span class=\"keyword\">False</span>, schema=<span class=\"string\">'DoubleG'</span>, chunksize=<span class=\"number\">10000</span>)</span><br><span class=\"line\"><span class=\"keyword\">finally</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">del</span> result</span><br></pre></td></tr></table></figure>\n<p>因为都设置的是utf8，之间测试过，把上述编码改为 latin1 ，依然乱码。</p>\n<p>本着试试又不会死的原则，我把navicat数据库连接中的 编码集由<strong>utf-8 改为 自动</strong>，再次查询Navicat：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysql&gt; SHOW VARIABLES LIKE 'character%';</span><br><span class=\"line\">+<span class=\"comment\">--------------------------+----------------------------------+</span></span><br><span class=\"line\">| Variable_name            | Value                            |</span><br><span class=\"line\">+<span class=\"comment\">--------------------------+----------------------------------+</span></span><br><span class=\"line\">| character_set_client     | utf8                             |</span><br><span class=\"line\">| character_set_connection | utf8                             |</span><br><span class=\"line\">| character_set_database   | utf8                             |</span><br><span class=\"line\">| character_set_filesystem | binary                           |</span><br><span class=\"line\">| character_set_results    | utf8                             |</span><br><span class=\"line\">| character_set_server     | utf8                             |</span><br><span class=\"line\">| character_set_system     | utf8                             |</span><br><span class=\"line\">| character_sets_dir       | /usr/local/mysql/share/charsets/ |</span><br><span class=\"line\">+<span class=\"comment\">--------------------------+----------------------------------+</span></span><br><span class=\"line\">8 rows in <span class=\"keyword\">set</span> (<span class=\"number\">0.00</span> sec)</span><br></pre></td></tr></table></figure>\n<p>结果正常，数据测试正常。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>Mac 版Navicat 貌似和windows不同，windows中数据库连接中将字符编码改为utf8就能解决问题（当然前提是配置好mysql数据库编码），而mac版编码必须自动。</p>\n"},{"layout":"post","title":"Navicat for Oracle 表名不存在 ORA00903","date":"2018-04-22T08:50:00.000Z","author":"Gubaidan","header-img":"/Header/RbM63-XsLUY.png","cdn":"header-on","_content":"\n项目中用用的数据库是Oracle，数据库可视化工具用的Navicat，Mybatis自动生成的xml文件和mapper接口。既然SQL语句是自动生成的，语法肯定没有错误。\n\n后来发现**Navicat 在创建表的时候会自动给表名和字段加上引号**，导致找不到表。\n\n1. oracle表和字段是有大小写的区别。oracle默认是大写，如果我们用双引号括起来的就区分大小写，如果没有，系统会自动转成大写。\n\n2. 我们在使用navicat使用可视化创建数据库时候，navicat自动给我们加上了“”，在创建数据库时实际的代码是这样的：\n\n   \n\n```sql\nDROP TABLE \"alarm_data\".\"users\";\nCREATE TABLE \"alarm_data\".\"users\" (\n\"id\" NUMBER(2) NOT NULL \n)\n```\n\n解决办法就是去掉引号重新建表。","source":"_posts/2018-04-22-ORA00903.markdown","raw":"---\nlayout: post\ntitle: \"Navicat for Oracle 表名不存在 ORA00903\"\ndate: 2018-04-22 16:50\nauthor: \"Gubaidan\"\nheader-img:  \"/Header/RbM63-XsLUY.png\"\ncdn: 'header-on'\ntags:\n\t- Oracle\n---\n\n项目中用用的数据库是Oracle，数据库可视化工具用的Navicat，Mybatis自动生成的xml文件和mapper接口。既然SQL语句是自动生成的，语法肯定没有错误。\n\n后来发现**Navicat 在创建表的时候会自动给表名和字段加上引号**，导致找不到表。\n\n1. oracle表和字段是有大小写的区别。oracle默认是大写，如果我们用双引号括起来的就区分大小写，如果没有，系统会自动转成大写。\n\n2. 我们在使用navicat使用可视化创建数据库时候，navicat自动给我们加上了“”，在创建数据库时实际的代码是这样的：\n\n   \n\n```sql\nDROP TABLE \"alarm_data\".\"users\";\nCREATE TABLE \"alarm_data\".\"users\" (\n\"id\" NUMBER(2) NOT NULL \n)\n```\n\n解决办法就是去掉引号重新建表。","slug":"2018-04-22-ORA00903","published":1,"updated":"2018-07-04T06:21:45.136Z","comments":1,"photos":[],"link":"","_id":"cjvayvwfe000dm46af152pi92","content":"<p>项目中用用的数据库是Oracle，数据库可视化工具用的Navicat，Mybatis自动生成的xml文件和mapper接口。既然SQL语句是自动生成的，语法肯定没有错误。</p>\n<p>后来发现<strong>Navicat 在创建表的时候会自动给表名和字段加上引号</strong>，导致找不到表。</p>\n<ol>\n<li><p>oracle表和字段是有大小写的区别。oracle默认是大写，如果我们用双引号括起来的就区分大小写，如果没有，系统会自动转成大写。</p>\n</li>\n<li><p>我们在使用navicat使用可视化创建数据库时候，navicat自动给我们加上了“”，在创建数据库时实际的代码是这样的：</p>\n</li>\n</ol>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">TABLE</span> <span class=\"string\">\"alarm_data\"</span>.<span class=\"string\">\"users\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> <span class=\"string\">\"alarm_data\"</span>.<span class=\"string\">\"users\"</span> (</span><br><span class=\"line\"><span class=\"string\">\"id\"</span> <span class=\"built_in\">NUMBER</span>(<span class=\"number\">2</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span> </span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>解决办法就是去掉引号重新建表。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>项目中用用的数据库是Oracle，数据库可视化工具用的Navicat，Mybatis自动生成的xml文件和mapper接口。既然SQL语句是自动生成的，语法肯定没有错误。</p>\n<p>后来发现<strong>Navicat 在创建表的时候会自动给表名和字段加上引号</strong>，导致找不到表。</p>\n<ol>\n<li><p>oracle表和字段是有大小写的区别。oracle默认是大写，如果我们用双引号括起来的就区分大小写，如果没有，系统会自动转成大写。</p>\n</li>\n<li><p>我们在使用navicat使用可视化创建数据库时候，navicat自动给我们加上了“”，在创建数据库时实际的代码是这样的：</p>\n</li>\n</ol>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">TABLE</span> <span class=\"string\">\"alarm_data\"</span>.<span class=\"string\">\"users\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> <span class=\"string\">\"alarm_data\"</span>.<span class=\"string\">\"users\"</span> (</span><br><span class=\"line\"><span class=\"string\">\"id\"</span> <span class=\"built_in\">NUMBER</span>(<span class=\"number\">2</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span> </span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>解决办法就是去掉引号重新建表。</p>\n"},{"layout":"post","title":"pjax: 当ajax遇上pushState","date":"2018-02-12T00:55:00.000Z","comments":1,"_content":"\n>var pjax = pushState + ajax;                  \n>小时候，小浣熊方便面里面有各种水浒人物的卡片。我买了一包，吃了方便面，饱了。而我又买了第二包，不是想吃方便面，而是仅仅想得到里面的卡片…          \n\n<!-- more -->\n\n##**一、简介**\npushState是html5中提供的方法，用以\n\n- 无刷新的更新浏览器地址栏；            \n- 如其名称，将新地址push到历史堆栈中            \n\n用法：`pushState(data, title ,url)`            \n\ndata为保存的对象，可以在window.onpopstate时获取到；title为页面标题；url为需地址栏和历史发生改变的url。            \n正是这点看似很平常的功能，跟ajax结合到一起产生了火花。因为，ajax最擅长的事情就是局部刷新页面。\n\n##**二、ajax的纠结历史**\n一切可以从ajax最擅长的事情说起。\najax作为一个异步请求模型，从最初设计开始，也许压根就没打算将它跟浏览器历史挂钩。原因是历史堆栈所记录的，某种意思上可以说是顺序，跟我们理解的“同步”更为密切。\n\n因而，`ajax可以无刷新改变页面内容，却无法改变页面的url`。\n\n- ####历史问题1 - 如何操控历史\n\n当单页面越来越流行，操作记录却很容易被忽略。假设有这样的单页面，按照分类点击，界面逐层递进：`体育 - 篮球 -nba -马刺队 - 邓肯`                       \n当我们点了4下到“邓肯”界面时，一个不小心的刷新，出现在你面前的也许是“体育”。原因是操作记录没有被记录。                  \n而通常的解决方案是修改hash，每递进一层，去更新url的hash值，这样的方法：\n\n1. 刷新时预先判断url的hash，从而知道这是哪一层，加载相应数据；          \n2. 支持了历史\n\n这样的方式貌似比较完善，其实不然。\n\n- ####历史问题2 - 对搜索引擎不友好\n\n最大的问题是，hash后生成的内容是不会被搜索引擎引用到。数据不能被爬取，无疑是浪费和损失。因此google放言，咱可以约定个协议：`#!xxx`这样hash的url，google也去爬取。称之为`hash bang`（哈希大爆炸？）。这一协议，在g+，twitter，人人，新浪微博上都可以看到。\n\n事实上，ajax最或缺的两个问题，恰好被pushState的功能补充完善。\n\n##**三、pjax带来的价值**\n除去补齐了ajax的问题，我们发现pjax会给web带来更多的好处。                     \n回到开始说的“两包方便面”，我的意思是，有时你访问两个url，部分数据是相同的。比如百度贴吧，第一页和第二页的区别只是帖子内容（卡片）的不同，网站外框部分（方便面）都是一样的，这些东西就不需要在页面刷新时重复加载。\n\najax处理这样的局部刷新，已经给我们带来了web2.0的体验，而加上pushstate的ajax则更进一步：\n\n1. 一个url对应一套数据，有利于SEO；\n2. 更改数据和url时，只是局部刷新，带来较好的用户体验；\n3. 兼容性好，对不支持pushstate的浏览器，url也能正常请求页面（虽然有重复加载）；\n4. 刷新页面时，由于是url唯一，能正常加载到用户希望看到的数据，比处理hash的方式更方便；\n5. 后退与前进的浏览器操作，依然可以局部刷新（通过onpushstate事件捕获）\n\n##**四、注意事项**\n\n然而pjax不等于单纯的分离使用pushstate与ajax，还必须得做一些封装。缘于以下我能想到的注意事项：\n\n- 服务器端增加额外处理逻辑             \n服务器端，需要根据请求的参数，作出全页渲染或局部渲染响应\n``` \nAccept:text/html, */*; q=0.01\nAccept-Encoding:gzip,deflate,sdch\nConnection:keep-alive\nHost:qianduannotes.duapp.com\nUser-Agent:AppleWebKit/537.36 (KHTML, like Gecko) Chrome/31.0.1650.63 Safari/537.36\nX-Requested-With:XMLHttpRequest\nX-PJAX:true\n```\n比如请求头部可以设定一个X-PAJX:true，用以通知服务器。\n\n- 浏览器兼容\n假如浏览器不支持pushstate，提供fallback操作，直接打开需更改url的地址：\n```\n$.support.pjax = window.history && window.history.pushState\n// Fallback\nif ( !$.support.pjax ) {\n  $.pjax = function( options ) {\n    window.location = $.isFunction(options.url) ? options.url() : options.url\n  }\n  $.fn.pjax = function() { return this }\n}\n```\n- 本地存储机制                  \n无疑pjax与localstorage共同使用可以进一步提升体验，但这一步容易忽略的是数据上报。\n\n##**五、参考资料**\n[jquery-pjax](https://github.com/defunkt/jquery-pjax)                 \n[welefen封装的pjax](https://github.com/welefen/pjax)\n\n\n\n","source":"_posts/about-pjax.markdown","raw":"---\nlayout: post\ntitle: \"pjax: 当ajax遇上pushState\"\ndate: 2018-02-12 08:55\ncomments: true\ntags: \n\t- js \n\t- html5\n---\n\n>var pjax = pushState + ajax;                  \n>小时候，小浣熊方便面里面有各种水浒人物的卡片。我买了一包，吃了方便面，饱了。而我又买了第二包，不是想吃方便面，而是仅仅想得到里面的卡片…          \n\n<!-- more -->\n\n##**一、简介**\npushState是html5中提供的方法，用以\n\n- 无刷新的更新浏览器地址栏；            \n- 如其名称，将新地址push到历史堆栈中            \n\n用法：`pushState(data, title ,url)`            \n\ndata为保存的对象，可以在window.onpopstate时获取到；title为页面标题；url为需地址栏和历史发生改变的url。            \n正是这点看似很平常的功能，跟ajax结合到一起产生了火花。因为，ajax最擅长的事情就是局部刷新页面。\n\n##**二、ajax的纠结历史**\n一切可以从ajax最擅长的事情说起。\najax作为一个异步请求模型，从最初设计开始，也许压根就没打算将它跟浏览器历史挂钩。原因是历史堆栈所记录的，某种意思上可以说是顺序，跟我们理解的“同步”更为密切。\n\n因而，`ajax可以无刷新改变页面内容，却无法改变页面的url`。\n\n- ####历史问题1 - 如何操控历史\n\n当单页面越来越流行，操作记录却很容易被忽略。假设有这样的单页面，按照分类点击，界面逐层递进：`体育 - 篮球 -nba -马刺队 - 邓肯`                       \n当我们点了4下到“邓肯”界面时，一个不小心的刷新，出现在你面前的也许是“体育”。原因是操作记录没有被记录。                  \n而通常的解决方案是修改hash，每递进一层，去更新url的hash值，这样的方法：\n\n1. 刷新时预先判断url的hash，从而知道这是哪一层，加载相应数据；          \n2. 支持了历史\n\n这样的方式貌似比较完善，其实不然。\n\n- ####历史问题2 - 对搜索引擎不友好\n\n最大的问题是，hash后生成的内容是不会被搜索引擎引用到。数据不能被爬取，无疑是浪费和损失。因此google放言，咱可以约定个协议：`#!xxx`这样hash的url，google也去爬取。称之为`hash bang`（哈希大爆炸？）。这一协议，在g+，twitter，人人，新浪微博上都可以看到。\n\n事实上，ajax最或缺的两个问题，恰好被pushState的功能补充完善。\n\n##**三、pjax带来的价值**\n除去补齐了ajax的问题，我们发现pjax会给web带来更多的好处。                     \n回到开始说的“两包方便面”，我的意思是，有时你访问两个url，部分数据是相同的。比如百度贴吧，第一页和第二页的区别只是帖子内容（卡片）的不同，网站外框部分（方便面）都是一样的，这些东西就不需要在页面刷新时重复加载。\n\najax处理这样的局部刷新，已经给我们带来了web2.0的体验，而加上pushstate的ajax则更进一步：\n\n1. 一个url对应一套数据，有利于SEO；\n2. 更改数据和url时，只是局部刷新，带来较好的用户体验；\n3. 兼容性好，对不支持pushstate的浏览器，url也能正常请求页面（虽然有重复加载）；\n4. 刷新页面时，由于是url唯一，能正常加载到用户希望看到的数据，比处理hash的方式更方便；\n5. 后退与前进的浏览器操作，依然可以局部刷新（通过onpushstate事件捕获）\n\n##**四、注意事项**\n\n然而pjax不等于单纯的分离使用pushstate与ajax，还必须得做一些封装。缘于以下我能想到的注意事项：\n\n- 服务器端增加额外处理逻辑             \n服务器端，需要根据请求的参数，作出全页渲染或局部渲染响应\n``` \nAccept:text/html, */*; q=0.01\nAccept-Encoding:gzip,deflate,sdch\nConnection:keep-alive\nHost:qianduannotes.duapp.com\nUser-Agent:AppleWebKit/537.36 (KHTML, like Gecko) Chrome/31.0.1650.63 Safari/537.36\nX-Requested-With:XMLHttpRequest\nX-PJAX:true\n```\n比如请求头部可以设定一个X-PAJX:true，用以通知服务器。\n\n- 浏览器兼容\n假如浏览器不支持pushstate，提供fallback操作，直接打开需更改url的地址：\n```\n$.support.pjax = window.history && window.history.pushState\n// Fallback\nif ( !$.support.pjax ) {\n  $.pjax = function( options ) {\n    window.location = $.isFunction(options.url) ? options.url() : options.url\n  }\n  $.fn.pjax = function() { return this }\n}\n```\n- 本地存储机制                  \n无疑pjax与localstorage共同使用可以进一步提升体验，但这一步容易忽略的是数据上报。\n\n##**五、参考资料**\n[jquery-pjax](https://github.com/defunkt/jquery-pjax)                 \n[welefen封装的pjax](https://github.com/welefen/pjax)\n\n\n\n","slug":"about-pjax","published":1,"updated":"2018-07-04T06:55:05.946Z","photos":[],"link":"","_id":"cjvayvwfg000fm46aen2gsm4m","content":"<blockquote>\n<p>var pjax = pushState + ajax;<br>小时候，小浣熊方便面里面有各种水浒人物的卡片。我买了一包，吃了方便面，饱了。而我又买了第二包，不是想吃方便面，而是仅仅想得到里面的卡片…          </p>\n</blockquote>\n<a id=\"more\"></a>\n<p>##<strong>一、简介</strong><br>pushState是html5中提供的方法，用以</p>\n<ul>\n<li>无刷新的更新浏览器地址栏；            </li>\n<li>如其名称，将新地址push到历史堆栈中            </li>\n</ul>\n<p>用法：<code>pushState(data, title ,url)</code>            </p>\n<p>data为保存的对象，可以在window.onpopstate时获取到；title为页面标题；url为需地址栏和历史发生改变的url。<br>正是这点看似很平常的功能，跟ajax结合到一起产生了火花。因为，ajax最擅长的事情就是局部刷新页面。</p>\n<p>##<strong>二、ajax的纠结历史</strong><br>一切可以从ajax最擅长的事情说起。<br>ajax作为一个异步请求模型，从最初设计开始，也许压根就没打算将它跟浏览器历史挂钩。原因是历史堆栈所记录的，某种意思上可以说是顺序，跟我们理解的“同步”更为密切。</p>\n<p>因而，<code>ajax可以无刷新改变页面内容，却无法改变页面的url</code>。</p>\n<ul>\n<li>####历史问题1 - 如何操控历史</li>\n</ul>\n<p>当单页面越来越流行，操作记录却很容易被忽略。假设有这样的单页面，按照分类点击，界面逐层递进：<code>体育 - 篮球 -nba -马刺队 - 邓肯</code><br>当我们点了4下到“邓肯”界面时，一个不小心的刷新，出现在你面前的也许是“体育”。原因是操作记录没有被记录。<br>而通常的解决方案是修改hash，每递进一层，去更新url的hash值，这样的方法：</p>\n<ol>\n<li>刷新时预先判断url的hash，从而知道这是哪一层，加载相应数据；          </li>\n<li>支持了历史</li>\n</ol>\n<p>这样的方式貌似比较完善，其实不然。</p>\n<ul>\n<li>####历史问题2 - 对搜索引擎不友好</li>\n</ul>\n<p>最大的问题是，hash后生成的内容是不会被搜索引擎引用到。数据不能被爬取，无疑是浪费和损失。因此google放言，咱可以约定个协议：<code>#!xxx</code>这样hash的url，google也去爬取。称之为<code>hash bang</code>（哈希大爆炸？）。这一协议，在g+，twitter，人人，新浪微博上都可以看到。</p>\n<p>事实上，ajax最或缺的两个问题，恰好被pushState的功能补充完善。</p>\n<p>##<strong>三、pjax带来的价值</strong><br>除去补齐了ajax的问题，我们发现pjax会给web带来更多的好处。<br>回到开始说的“两包方便面”，我的意思是，有时你访问两个url，部分数据是相同的。比如百度贴吧，第一页和第二页的区别只是帖子内容（卡片）的不同，网站外框部分（方便面）都是一样的，这些东西就不需要在页面刷新时重复加载。</p>\n<p>ajax处理这样的局部刷新，已经给我们带来了web2.0的体验，而加上pushstate的ajax则更进一步：</p>\n<ol>\n<li>一个url对应一套数据，有利于SEO；</li>\n<li>更改数据和url时，只是局部刷新，带来较好的用户体验；</li>\n<li>兼容性好，对不支持pushstate的浏览器，url也能正常请求页面（虽然有重复加载）；</li>\n<li>刷新页面时，由于是url唯一，能正常加载到用户希望看到的数据，比处理hash的方式更方便；</li>\n<li>后退与前进的浏览器操作，依然可以局部刷新（通过onpushstate事件捕获）</li>\n</ol>\n<p>##<strong>四、注意事项</strong></p>\n<p>然而pjax不等于单纯的分离使用pushstate与ajax，还必须得做一些封装。缘于以下我能想到的注意事项：</p>\n<ul>\n<li>服务器端增加额外处理逻辑<br>服务器端，需要根据请求的参数，作出全页渲染或局部渲染响应<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Accept:text/html, */*; q=0.01</span><br><span class=\"line\">Accept-Encoding:gzip,deflate,sdch</span><br><span class=\"line\">Connection:keep-alive</span><br><span class=\"line\">Host:qianduannotes.duapp.com</span><br><span class=\"line\">User-Agent:AppleWebKit/537.36 (KHTML, like Gecko) Chrome/31.0.1650.63 Safari/537.36</span><br><span class=\"line\">X-Requested-With:XMLHttpRequest</span><br><span class=\"line\">X-PJAX:true</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>比如请求头部可以设定一个X-PAJX:true，用以通知服务器。</p>\n<ul>\n<li><p>浏览器兼容<br>假如浏览器不支持pushstate，提供fallback操作，直接打开需更改url的地址：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$.support.pjax = window.history &amp;&amp; window.history.pushState</span><br><span class=\"line\">// Fallback</span><br><span class=\"line\">if ( !$.support.pjax ) &#123;</span><br><span class=\"line\">  $.pjax = function( options ) &#123;</span><br><span class=\"line\">    window.location = $.isFunction(options.url) ? options.url() : options.url</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  $.fn.pjax = function() &#123; return this &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>本地存储机制<br>无疑pjax与localstorage共同使用可以进一步提升体验，但这一步容易忽略的是数据上报。</p>\n</li>\n</ul>\n<p>##<strong>五、参考资料</strong><br><a href=\"https://github.com/defunkt/jquery-pjax\" target=\"_blank\" rel=\"noopener\">jquery-pjax</a><br><a href=\"https://github.com/welefen/pjax\" target=\"_blank\" rel=\"noopener\">welefen封装的pjax</a></p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>var pjax = pushState + ajax;<br>小时候，小浣熊方便面里面有各种水浒人物的卡片。我买了一包，吃了方便面，饱了。而我又买了第二包，不是想吃方便面，而是仅仅想得到里面的卡片…          </p>\n</blockquote>","more":"<p>##<strong>一、简介</strong><br>pushState是html5中提供的方法，用以</p>\n<ul>\n<li>无刷新的更新浏览器地址栏；            </li>\n<li>如其名称，将新地址push到历史堆栈中            </li>\n</ul>\n<p>用法：<code>pushState(data, title ,url)</code>            </p>\n<p>data为保存的对象，可以在window.onpopstate时获取到；title为页面标题；url为需地址栏和历史发生改变的url。<br>正是这点看似很平常的功能，跟ajax结合到一起产生了火花。因为，ajax最擅长的事情就是局部刷新页面。</p>\n<p>##<strong>二、ajax的纠结历史</strong><br>一切可以从ajax最擅长的事情说起。<br>ajax作为一个异步请求模型，从最初设计开始，也许压根就没打算将它跟浏览器历史挂钩。原因是历史堆栈所记录的，某种意思上可以说是顺序，跟我们理解的“同步”更为密切。</p>\n<p>因而，<code>ajax可以无刷新改变页面内容，却无法改变页面的url</code>。</p>\n<ul>\n<li>####历史问题1 - 如何操控历史</li>\n</ul>\n<p>当单页面越来越流行，操作记录却很容易被忽略。假设有这样的单页面，按照分类点击，界面逐层递进：<code>体育 - 篮球 -nba -马刺队 - 邓肯</code><br>当我们点了4下到“邓肯”界面时，一个不小心的刷新，出现在你面前的也许是“体育”。原因是操作记录没有被记录。<br>而通常的解决方案是修改hash，每递进一层，去更新url的hash值，这样的方法：</p>\n<ol>\n<li>刷新时预先判断url的hash，从而知道这是哪一层，加载相应数据；          </li>\n<li>支持了历史</li>\n</ol>\n<p>这样的方式貌似比较完善，其实不然。</p>\n<ul>\n<li>####历史问题2 - 对搜索引擎不友好</li>\n</ul>\n<p>最大的问题是，hash后生成的内容是不会被搜索引擎引用到。数据不能被爬取，无疑是浪费和损失。因此google放言，咱可以约定个协议：<code>#!xxx</code>这样hash的url，google也去爬取。称之为<code>hash bang</code>（哈希大爆炸？）。这一协议，在g+，twitter，人人，新浪微博上都可以看到。</p>\n<p>事实上，ajax最或缺的两个问题，恰好被pushState的功能补充完善。</p>\n<p>##<strong>三、pjax带来的价值</strong><br>除去补齐了ajax的问题，我们发现pjax会给web带来更多的好处。<br>回到开始说的“两包方便面”，我的意思是，有时你访问两个url，部分数据是相同的。比如百度贴吧，第一页和第二页的区别只是帖子内容（卡片）的不同，网站外框部分（方便面）都是一样的，这些东西就不需要在页面刷新时重复加载。</p>\n<p>ajax处理这样的局部刷新，已经给我们带来了web2.0的体验，而加上pushstate的ajax则更进一步：</p>\n<ol>\n<li>一个url对应一套数据，有利于SEO；</li>\n<li>更改数据和url时，只是局部刷新，带来较好的用户体验；</li>\n<li>兼容性好，对不支持pushstate的浏览器，url也能正常请求页面（虽然有重复加载）；</li>\n<li>刷新页面时，由于是url唯一，能正常加载到用户希望看到的数据，比处理hash的方式更方便；</li>\n<li>后退与前进的浏览器操作，依然可以局部刷新（通过onpushstate事件捕获）</li>\n</ol>\n<p>##<strong>四、注意事项</strong></p>\n<p>然而pjax不等于单纯的分离使用pushstate与ajax，还必须得做一些封装。缘于以下我能想到的注意事项：</p>\n<ul>\n<li>服务器端增加额外处理逻辑<br>服务器端，需要根据请求的参数，作出全页渲染或局部渲染响应<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Accept:text/html, */*; q=0.01</span><br><span class=\"line\">Accept-Encoding:gzip,deflate,sdch</span><br><span class=\"line\">Connection:keep-alive</span><br><span class=\"line\">Host:qianduannotes.duapp.com</span><br><span class=\"line\">User-Agent:AppleWebKit/537.36 (KHTML, like Gecko) Chrome/31.0.1650.63 Safari/537.36</span><br><span class=\"line\">X-Requested-With:XMLHttpRequest</span><br><span class=\"line\">X-PJAX:true</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>比如请求头部可以设定一个X-PAJX:true，用以通知服务器。</p>\n<ul>\n<li><p>浏览器兼容<br>假如浏览器不支持pushstate，提供fallback操作，直接打开需更改url的地址：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$.support.pjax = window.history &amp;&amp; window.history.pushState</span><br><span class=\"line\">// Fallback</span><br><span class=\"line\">if ( !$.support.pjax ) &#123;</span><br><span class=\"line\">  $.pjax = function( options ) &#123;</span><br><span class=\"line\">    window.location = $.isFunction(options.url) ? options.url() : options.url</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  $.fn.pjax = function() &#123; return this &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>本地存储机制<br>无疑pjax与localstorage共同使用可以进一步提升体验，但这一步容易忽略的是数据上报。</p>\n</li>\n</ul>\n<p>##<strong>五、参考资料</strong><br><a href=\"https://github.com/defunkt/jquery-pjax\" target=\"_blank\" rel=\"noopener\">jquery-pjax</a><br><a href=\"https://github.com/welefen/pjax\" target=\"_blank\" rel=\"noopener\">welefen封装的pjax</a></p>"},{"layout":"post","title":"长白山 | 来去匆匆，惊鸿一瞥","date":"2016-04-01T02:36:00.000Z","comments":1,"top":true,"_content":"\n—— 写于 2015.12.02 ， 一篇旧游记 \n\n### 冷！\n\n到吉林下了飞机，虽做足了准备，还是冷\n现在，南国的深圳依然是穿短袖的季节，朋友说，仿佛一夜入冬。\n但这才是真正的冬天呀！\n\n小时候作文写四季，唯秋冬难写。\n如果南方的季节是一把尺子，那它的刻度仅仅是温度的高低\n到了北方，这把尺子，才变得有质感\n它丈量着你每一寸的身体发肤\n\n随行的朋友对下雪满怀期待\n但听说大雪会封山，可能看不到天池时\n又陷入愁云惨淡中\n应了那句话叫“一颗心掉进了冰窖里”\n\n但未来的事管它呢？\n那是上帝决定的事情。\n上帝在工作我在玩，还有什么不开心？（可惜这逻辑没人懂）\n\n<!--more-->\n\n### 鱼\n\n行走在结冰的松花江上，神清气爽。\n我喜欢看冻在冰里的小气泡\n有一种定格相片的美感\n\n途遇放生的人们，他们表情凝重，一脸严肃\n随后旌旗翻飞，佛经传扬，鱼虾入水，\n江面恢复平静后，他们也终于露出了笑脸\n\n随后在江旁的饭店用餐\n服务员介绍道：这道蒸鱼，就来自松花江里！\n真是让人啼笑皆非的事情\n鱼，让两类不同的人都得到了欢喜\n可能鱼就是佛吧？\n\n### 地广人稀\n\n下午三点半的时分，天色已逐渐漆黑，市民们陆续回家\n我想，鹅厂要是在东北，那就是睡个午觉就下班的节奏！\n不过听说平时要六点多起床上班\n我又打消了这念头\n\n但东北确实地广人稀\n晚上很多店铺都早早关门\n手套和帽子找了很久才买到\n但泡温泉的泳裤就难办了\n况且，在零下十几度的世界里卖泳裤的人，\n脑子都有问题吧…\n\n### 度假区\n\n后续几天都住万达度假区里\n漂亮且休闲的小镇，我很喜欢这里。\n\n也在这学会了滑雪，秦教练尽心尽责\n得知我是鹅厂工程师后，\n还加我微信，让我以后有问题多问他（然而我不用微信）\n他似乎对互联网很感兴趣，\n我怕他一冲动走上了程序员的不归路\n跟他说：好好工作，少上网！\n\n后来偶遇王思聪开了夜场，可以玩到很晚\n然后在雪夜里迷了路…\n那晚，我是怎么回到酒店的？\n这已经是一个未解之谜。\n\n### 天池\n\n也终于到了上长白山的时候！\n早上还下着雪，导游安慰说：\n已经封山了一个月，邓小平去了几次都没见着天池云云\n似乎上帝已经做出了决定\n\n但旅行之所以迷人，就在于各种不确定性\n吃完午饭大概一点半，一个消息在园区内爆炸开来—— 封山结束！\n每个人欣喜若狂，\n司机大哥相当豪爽，用袖子把车上的积雪一推，只留下一个字：\n走。\n\n车子旋绕而行，山路确实很险\n白茫茫的一片，要是不熟悉真的分不清哪里是路\n窗外风声越来越大，仿佛有无数的野禽在嘶鸣\n也终于来到了山顶\n\n此刻才觉得，所有的防寒措施都不管用\n风雪抓住每个机会向你的身体里钻\n刀片般的飞雪把脸刮得通红\n手机的锂电池也放弃了抵抗\n陷入了“冬眠”\n\n那还能怎样？跳吧！让热量释放出来！\n蹦着走过那段最艰难的路\n安详的天池就突然出现在脚下\n\n![](/assets/blogImg/changbaishan-2.jpg)\n\n太阳仿佛只离她几公分\n柔和的光潜入水中，幻化为风\n谦卑地贴着湖面缓缓地吹…\n光与水顺着千年的血脉流进心间，\n天池，就变成了一枚绝世风华的眼眸。\n你未能看清，她的眼神里藏了多少秘密，\n她却早已把你的灵魂一眼望穿。\n这让我突然忘记了寒冷\n\n半小时后，风雪加急\n工作人员催着下山，封山又要开始了\n这让我更觉得神奇\n好像天池，就等我见她一面。\n\n### 不多\n\n我要的不多。\n真的不多。\n你的一面，一眼，一念，一瞬\n我就能幸福。\n事情就能圆满。\n\n“我为你来看我不顾一切，\n我将熄灭永不能再回来\n我在这里啊\n我在这里啊\n惊鸿一般短暂\n像夏花一样绚烂……”\n\n\n\n\n\n","source":"_posts/changbaishan.markdown","raw":"---\nlayout: post\ntitle: \"长白山 | 来去匆匆，惊鸿一瞥\"\ndate: 2016-04-01 10:36\ncomments: true\ntop: true\ntags: \n\t- 旅行\n---\n\n—— 写于 2015.12.02 ， 一篇旧游记 \n\n### 冷！\n\n到吉林下了飞机，虽做足了准备，还是冷\n现在，南国的深圳依然是穿短袖的季节，朋友说，仿佛一夜入冬。\n但这才是真正的冬天呀！\n\n小时候作文写四季，唯秋冬难写。\n如果南方的季节是一把尺子，那它的刻度仅仅是温度的高低\n到了北方，这把尺子，才变得有质感\n它丈量着你每一寸的身体发肤\n\n随行的朋友对下雪满怀期待\n但听说大雪会封山，可能看不到天池时\n又陷入愁云惨淡中\n应了那句话叫“一颗心掉进了冰窖里”\n\n但未来的事管它呢？\n那是上帝决定的事情。\n上帝在工作我在玩，还有什么不开心？（可惜这逻辑没人懂）\n\n<!--more-->\n\n### 鱼\n\n行走在结冰的松花江上，神清气爽。\n我喜欢看冻在冰里的小气泡\n有一种定格相片的美感\n\n途遇放生的人们，他们表情凝重，一脸严肃\n随后旌旗翻飞，佛经传扬，鱼虾入水，\n江面恢复平静后，他们也终于露出了笑脸\n\n随后在江旁的饭店用餐\n服务员介绍道：这道蒸鱼，就来自松花江里！\n真是让人啼笑皆非的事情\n鱼，让两类不同的人都得到了欢喜\n可能鱼就是佛吧？\n\n### 地广人稀\n\n下午三点半的时分，天色已逐渐漆黑，市民们陆续回家\n我想，鹅厂要是在东北，那就是睡个午觉就下班的节奏！\n不过听说平时要六点多起床上班\n我又打消了这念头\n\n但东北确实地广人稀\n晚上很多店铺都早早关门\n手套和帽子找了很久才买到\n但泡温泉的泳裤就难办了\n况且，在零下十几度的世界里卖泳裤的人，\n脑子都有问题吧…\n\n### 度假区\n\n后续几天都住万达度假区里\n漂亮且休闲的小镇，我很喜欢这里。\n\n也在这学会了滑雪，秦教练尽心尽责\n得知我是鹅厂工程师后，\n还加我微信，让我以后有问题多问他（然而我不用微信）\n他似乎对互联网很感兴趣，\n我怕他一冲动走上了程序员的不归路\n跟他说：好好工作，少上网！\n\n后来偶遇王思聪开了夜场，可以玩到很晚\n然后在雪夜里迷了路…\n那晚，我是怎么回到酒店的？\n这已经是一个未解之谜。\n\n### 天池\n\n也终于到了上长白山的时候！\n早上还下着雪，导游安慰说：\n已经封山了一个月，邓小平去了几次都没见着天池云云\n似乎上帝已经做出了决定\n\n但旅行之所以迷人，就在于各种不确定性\n吃完午饭大概一点半，一个消息在园区内爆炸开来—— 封山结束！\n每个人欣喜若狂，\n司机大哥相当豪爽，用袖子把车上的积雪一推，只留下一个字：\n走。\n\n车子旋绕而行，山路确实很险\n白茫茫的一片，要是不熟悉真的分不清哪里是路\n窗外风声越来越大，仿佛有无数的野禽在嘶鸣\n也终于来到了山顶\n\n此刻才觉得，所有的防寒措施都不管用\n风雪抓住每个机会向你的身体里钻\n刀片般的飞雪把脸刮得通红\n手机的锂电池也放弃了抵抗\n陷入了“冬眠”\n\n那还能怎样？跳吧！让热量释放出来！\n蹦着走过那段最艰难的路\n安详的天池就突然出现在脚下\n\n![](/assets/blogImg/changbaishan-2.jpg)\n\n太阳仿佛只离她几公分\n柔和的光潜入水中，幻化为风\n谦卑地贴着湖面缓缓地吹…\n光与水顺着千年的血脉流进心间，\n天池，就变成了一枚绝世风华的眼眸。\n你未能看清，她的眼神里藏了多少秘密，\n她却早已把你的灵魂一眼望穿。\n这让我突然忘记了寒冷\n\n半小时后，风雪加急\n工作人员催着下山，封山又要开始了\n这让我更觉得神奇\n好像天池，就等我见她一面。\n\n### 不多\n\n我要的不多。\n真的不多。\n你的一面，一眼，一念，一瞬\n我就能幸福。\n事情就能圆满。\n\n“我为你来看我不顾一切，\n我将熄灭永不能再回来\n我在这里啊\n我在这里啊\n惊鸿一般短暂\n像夏花一样绚烂……”\n\n\n\n\n\n","slug":"changbaishan","published":1,"updated":"2018-07-08T12:44:06.602Z","photos":[],"link":"","_id":"cjvayvwfi000hm46aoqqb2z01","content":"<p>—— 写于 2015.12.02 ， 一篇旧游记 </p>\n<h3 id=\"冷！\"><a href=\"#冷！\" class=\"headerlink\" title=\"冷！\"></a>冷！</h3><p>到吉林下了飞机，虽做足了准备，还是冷<br>现在，南国的深圳依然是穿短袖的季节，朋友说，仿佛一夜入冬。<br>但这才是真正的冬天呀！</p>\n<p>小时候作文写四季，唯秋冬难写。<br>如果南方的季节是一把尺子，那它的刻度仅仅是温度的高低<br>到了北方，这把尺子，才变得有质感<br>它丈量着你每一寸的身体发肤</p>\n<p>随行的朋友对下雪满怀期待<br>但听说大雪会封山，可能看不到天池时<br>又陷入愁云惨淡中<br>应了那句话叫“一颗心掉进了冰窖里”</p>\n<p>但未来的事管它呢？<br>那是上帝决定的事情。<br>上帝在工作我在玩，还有什么不开心？（可惜这逻辑没人懂）</p>\n<a id=\"more\"></a>\n<h3 id=\"鱼\"><a href=\"#鱼\" class=\"headerlink\" title=\"鱼\"></a>鱼</h3><p>行走在结冰的松花江上，神清气爽。<br>我喜欢看冻在冰里的小气泡<br>有一种定格相片的美感</p>\n<p>途遇放生的人们，他们表情凝重，一脸严肃<br>随后旌旗翻飞，佛经传扬，鱼虾入水，<br>江面恢复平静后，他们也终于露出了笑脸</p>\n<p>随后在江旁的饭店用餐<br>服务员介绍道：这道蒸鱼，就来自松花江里！<br>真是让人啼笑皆非的事情<br>鱼，让两类不同的人都得到了欢喜<br>可能鱼就是佛吧？</p>\n<h3 id=\"地广人稀\"><a href=\"#地广人稀\" class=\"headerlink\" title=\"地广人稀\"></a>地广人稀</h3><p>下午三点半的时分，天色已逐渐漆黑，市民们陆续回家<br>我想，鹅厂要是在东北，那就是睡个午觉就下班的节奏！<br>不过听说平时要六点多起床上班<br>我又打消了这念头</p>\n<p>但东北确实地广人稀<br>晚上很多店铺都早早关门<br>手套和帽子找了很久才买到<br>但泡温泉的泳裤就难办了<br>况且，在零下十几度的世界里卖泳裤的人，<br>脑子都有问题吧…</p>\n<h3 id=\"度假区\"><a href=\"#度假区\" class=\"headerlink\" title=\"度假区\"></a>度假区</h3><p>后续几天都住万达度假区里<br>漂亮且休闲的小镇，我很喜欢这里。</p>\n<p>也在这学会了滑雪，秦教练尽心尽责<br>得知我是鹅厂工程师后，<br>还加我微信，让我以后有问题多问他（然而我不用微信）<br>他似乎对互联网很感兴趣，<br>我怕他一冲动走上了程序员的不归路<br>跟他说：好好工作，少上网！</p>\n<p>后来偶遇王思聪开了夜场，可以玩到很晚<br>然后在雪夜里迷了路…<br>那晚，我是怎么回到酒店的？<br>这已经是一个未解之谜。</p>\n<h3 id=\"天池\"><a href=\"#天池\" class=\"headerlink\" title=\"天池\"></a>天池</h3><p>也终于到了上长白山的时候！<br>早上还下着雪，导游安慰说：<br>已经封山了一个月，邓小平去了几次都没见着天池云云<br>似乎上帝已经做出了决定</p>\n<p>但旅行之所以迷人，就在于各种不确定性<br>吃完午饭大概一点半，一个消息在园区内爆炸开来—— 封山结束！<br>每个人欣喜若狂，<br>司机大哥相当豪爽，用袖子把车上的积雪一推，只留下一个字：<br>走。</p>\n<p>车子旋绕而行，山路确实很险<br>白茫茫的一片，要是不熟悉真的分不清哪里是路<br>窗外风声越来越大，仿佛有无数的野禽在嘶鸣<br>也终于来到了山顶</p>\n<p>此刻才觉得，所有的防寒措施都不管用<br>风雪抓住每个机会向你的身体里钻<br>刀片般的飞雪把脸刮得通红<br>手机的锂电池也放弃了抵抗<br>陷入了“冬眠”</p>\n<p>那还能怎样？跳吧！让热量释放出来！<br>蹦着走过那段最艰难的路<br>安详的天池就突然出现在脚下</p>\n<p><img src=\"/assets/blogImg/changbaishan-2.jpg\" alt></p>\n<p>太阳仿佛只离她几公分<br>柔和的光潜入水中，幻化为风<br>谦卑地贴着湖面缓缓地吹…<br>光与水顺着千年的血脉流进心间，<br>天池，就变成了一枚绝世风华的眼眸。<br>你未能看清，她的眼神里藏了多少秘密，<br>她却早已把你的灵魂一眼望穿。<br>这让我突然忘记了寒冷</p>\n<p>半小时后，风雪加急<br>工作人员催着下山，封山又要开始了<br>这让我更觉得神奇<br>好像天池，就等我见她一面。</p>\n<h3 id=\"不多\"><a href=\"#不多\" class=\"headerlink\" title=\"不多\"></a>不多</h3><p>我要的不多。<br>真的不多。<br>你的一面，一眼，一念，一瞬<br>我就能幸福。<br>事情就能圆满。</p>\n<p>“我为你来看我不顾一切，<br>我将熄灭永不能再回来<br>我在这里啊<br>我在这里啊<br>惊鸿一般短暂<br>像夏花一样绚烂……”</p>\n","site":{"data":{}},"excerpt":"<p>—— 写于 2015.12.02 ， 一篇旧游记 </p>\n<h3 id=\"冷！\"><a href=\"#冷！\" class=\"headerlink\" title=\"冷！\"></a>冷！</h3><p>到吉林下了飞机，虽做足了准备，还是冷<br>现在，南国的深圳依然是穿短袖的季节，朋友说，仿佛一夜入冬。<br>但这才是真正的冬天呀！</p>\n<p>小时候作文写四季，唯秋冬难写。<br>如果南方的季节是一把尺子，那它的刻度仅仅是温度的高低<br>到了北方，这把尺子，才变得有质感<br>它丈量着你每一寸的身体发肤</p>\n<p>随行的朋友对下雪满怀期待<br>但听说大雪会封山，可能看不到天池时<br>又陷入愁云惨淡中<br>应了那句话叫“一颗心掉进了冰窖里”</p>\n<p>但未来的事管它呢？<br>那是上帝决定的事情。<br>上帝在工作我在玩，还有什么不开心？（可惜这逻辑没人懂）</p>","more":"<h3 id=\"鱼\"><a href=\"#鱼\" class=\"headerlink\" title=\"鱼\"></a>鱼</h3><p>行走在结冰的松花江上，神清气爽。<br>我喜欢看冻在冰里的小气泡<br>有一种定格相片的美感</p>\n<p>途遇放生的人们，他们表情凝重，一脸严肃<br>随后旌旗翻飞，佛经传扬，鱼虾入水，<br>江面恢复平静后，他们也终于露出了笑脸</p>\n<p>随后在江旁的饭店用餐<br>服务员介绍道：这道蒸鱼，就来自松花江里！<br>真是让人啼笑皆非的事情<br>鱼，让两类不同的人都得到了欢喜<br>可能鱼就是佛吧？</p>\n<h3 id=\"地广人稀\"><a href=\"#地广人稀\" class=\"headerlink\" title=\"地广人稀\"></a>地广人稀</h3><p>下午三点半的时分，天色已逐渐漆黑，市民们陆续回家<br>我想，鹅厂要是在东北，那就是睡个午觉就下班的节奏！<br>不过听说平时要六点多起床上班<br>我又打消了这念头</p>\n<p>但东北确实地广人稀<br>晚上很多店铺都早早关门<br>手套和帽子找了很久才买到<br>但泡温泉的泳裤就难办了<br>况且，在零下十几度的世界里卖泳裤的人，<br>脑子都有问题吧…</p>\n<h3 id=\"度假区\"><a href=\"#度假区\" class=\"headerlink\" title=\"度假区\"></a>度假区</h3><p>后续几天都住万达度假区里<br>漂亮且休闲的小镇，我很喜欢这里。</p>\n<p>也在这学会了滑雪，秦教练尽心尽责<br>得知我是鹅厂工程师后，<br>还加我微信，让我以后有问题多问他（然而我不用微信）<br>他似乎对互联网很感兴趣，<br>我怕他一冲动走上了程序员的不归路<br>跟他说：好好工作，少上网！</p>\n<p>后来偶遇王思聪开了夜场，可以玩到很晚<br>然后在雪夜里迷了路…<br>那晚，我是怎么回到酒店的？<br>这已经是一个未解之谜。</p>\n<h3 id=\"天池\"><a href=\"#天池\" class=\"headerlink\" title=\"天池\"></a>天池</h3><p>也终于到了上长白山的时候！<br>早上还下着雪，导游安慰说：<br>已经封山了一个月，邓小平去了几次都没见着天池云云<br>似乎上帝已经做出了决定</p>\n<p>但旅行之所以迷人，就在于各种不确定性<br>吃完午饭大概一点半，一个消息在园区内爆炸开来—— 封山结束！<br>每个人欣喜若狂，<br>司机大哥相当豪爽，用袖子把车上的积雪一推，只留下一个字：<br>走。</p>\n<p>车子旋绕而行，山路确实很险<br>白茫茫的一片，要是不熟悉真的分不清哪里是路<br>窗外风声越来越大，仿佛有无数的野禽在嘶鸣<br>也终于来到了山顶</p>\n<p>此刻才觉得，所有的防寒措施都不管用<br>风雪抓住每个机会向你的身体里钻<br>刀片般的飞雪把脸刮得通红<br>手机的锂电池也放弃了抵抗<br>陷入了“冬眠”</p>\n<p>那还能怎样？跳吧！让热量释放出来！<br>蹦着走过那段最艰难的路<br>安详的天池就突然出现在脚下</p>\n<p><img src=\"/assets/blogImg/changbaishan-2.jpg\" alt></p>\n<p>太阳仿佛只离她几公分<br>柔和的光潜入水中，幻化为风<br>谦卑地贴着湖面缓缓地吹…<br>光与水顺着千年的血脉流进心间，<br>天池，就变成了一枚绝世风华的眼眸。<br>你未能看清，她的眼神里藏了多少秘密，<br>她却早已把你的灵魂一眼望穿。<br>这让我突然忘记了寒冷</p>\n<p>半小时后，风雪加急<br>工作人员催着下山，封山又要开始了<br>这让我更觉得神奇<br>好像天池，就等我见她一面。</p>\n<h3 id=\"不多\"><a href=\"#不多\" class=\"headerlink\" title=\"不多\"></a>不多</h3><p>我要的不多。<br>真的不多。<br>你的一面，一眼，一念，一瞬<br>我就能幸福。<br>事情就能圆满。</p>\n<p>“我为你来看我不顾一切，<br>我将熄灭永不能再回来<br>我在这里啊<br>我在这里啊<br>惊鸿一般短暂<br>像夏花一样绚烂……”</p>"},{"layout":"post","title":"旧事 等风来 7.31-8.6","date":"2016-08-07T02:36:00.000Z","comments":1,"_content":"\n![](/assets/blogImg/diary-7.jpg)\n\n七月底，去了趟冰雪世界。\n之前很是期待，因为大半年没滑过雪，上次的情景还历历在目。\n然而，只有滑冰…挺无趣的，说实话。\n但期待是个好事\n所以我也挺期待台风的（什么鬼逻辑？）\n\n八月初，妮妲过境。\n\n台风果真会影响人的思考与心绪。\n以前那次是“黑云压城城欲摧”，如临大敌，跑还来不及\n但这次甚至连雨点儿都没有\n我一开始有点怀疑\n\n又突然想到，产品同学在给我布置大需求时\n也是这般“暴风雨前的宁静”\n那我还是跑吧…\n\n这周失眠严重\n我想做很多事情，但一起步就感觉身体被枷锁连着\n在夜晚，这些锁链碰得叮当作响\n像是银白的蛛网，不断交织重叠。\n我把佛经背了又背\n\n台风来的那天晚上\n吹得窗户好响\n反而睡得很好\n可能，妮妲吹走了一些魔障吧\n\n每一个台风天，都像是我的老朋友。\n\n\n\n","source":"_posts/diary-2016-0731-0806.markdown","raw":"---\nlayout: post\ntitle: \"旧事 等风来 7.31-8.6\"\ndate: 2016-08-07 10:36\ncomments: true\ntags: \n\t- 旧事\n---\n\n![](/assets/blogImg/diary-7.jpg)\n\n七月底，去了趟冰雪世界。\n之前很是期待，因为大半年没滑过雪，上次的情景还历历在目。\n然而，只有滑冰…挺无趣的，说实话。\n但期待是个好事\n所以我也挺期待台风的（什么鬼逻辑？）\n\n八月初，妮妲过境。\n\n台风果真会影响人的思考与心绪。\n以前那次是“黑云压城城欲摧”，如临大敌，跑还来不及\n但这次甚至连雨点儿都没有\n我一开始有点怀疑\n\n又突然想到，产品同学在给我布置大需求时\n也是这般“暴风雨前的宁静”\n那我还是跑吧…\n\n这周失眠严重\n我想做很多事情，但一起步就感觉身体被枷锁连着\n在夜晚，这些锁链碰得叮当作响\n像是银白的蛛网，不断交织重叠。\n我把佛经背了又背\n\n台风来的那天晚上\n吹得窗户好响\n反而睡得很好\n可能，妮妲吹走了一些魔障吧\n\n每一个台风天，都像是我的老朋友。\n\n\n\n","slug":"diary-2016-0731-0806","published":1,"updated":"2018-06-21T08:50:00.497Z","photos":[],"link":"","_id":"cjvayvwfi000jm46al8ez3fz2","content":"<p><img src=\"/assets/blogImg/diary-7.jpg\" alt></p>\n<p>七月底，去了趟冰雪世界。<br>之前很是期待，因为大半年没滑过雪，上次的情景还历历在目。<br>然而，只有滑冰…挺无趣的，说实话。<br>但期待是个好事<br>所以我也挺期待台风的（什么鬼逻辑？）</p>\n<p>八月初，妮妲过境。</p>\n<p>台风果真会影响人的思考与心绪。<br>以前那次是“黑云压城城欲摧”，如临大敌，跑还来不及<br>但这次甚至连雨点儿都没有<br>我一开始有点怀疑</p>\n<p>又突然想到，产品同学在给我布置大需求时<br>也是这般“暴风雨前的宁静”<br>那我还是跑吧…</p>\n<p>这周失眠严重<br>我想做很多事情，但一起步就感觉身体被枷锁连着<br>在夜晚，这些锁链碰得叮当作响<br>像是银白的蛛网，不断交织重叠。<br>我把佛经背了又背</p>\n<p>台风来的那天晚上<br>吹得窗户好响<br>反而睡得很好<br>可能，妮妲吹走了一些魔障吧</p>\n<p>每一个台风天，都像是我的老朋友。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/assets/blogImg/diary-7.jpg\" alt></p>\n<p>七月底，去了趟冰雪世界。<br>之前很是期待，因为大半年没滑过雪，上次的情景还历历在目。<br>然而，只有滑冰…挺无趣的，说实话。<br>但期待是个好事<br>所以我也挺期待台风的（什么鬼逻辑？）</p>\n<p>八月初，妮妲过境。</p>\n<p>台风果真会影响人的思考与心绪。<br>以前那次是“黑云压城城欲摧”，如临大敌，跑还来不及<br>但这次甚至连雨点儿都没有<br>我一开始有点怀疑</p>\n<p>又突然想到，产品同学在给我布置大需求时<br>也是这般“暴风雨前的宁静”<br>那我还是跑吧…</p>\n<p>这周失眠严重<br>我想做很多事情，但一起步就感觉身体被枷锁连着<br>在夜晚，这些锁链碰得叮当作响<br>像是银白的蛛网，不断交织重叠。<br>我把佛经背了又背</p>\n<p>台风来的那天晚上<br>吹得窗户好响<br>反而睡得很好<br>可能，妮妲吹走了一些魔障吧</p>\n<p>每一个台风天，都像是我的老朋友。</p>\n"},{"layout":"post","title":"旧事 奥运 8.14-8.20","date":"2016-08-21T02:36:00.000Z","comments":1,"_content":"\n每晚小板凳备好，乐呵去守着CCTV5\n里约这个时差刚刚好，反正我忙得不行，只有晚上这点属于自己的时间。\n\n这两周主要看乒乓赛事\n最好看还是男团张继科打郑荣植那场\n郑的反手很强，张却持续使用反手拧拉\n攻彼之长，陷入苦战\n\n杨影相当着急，也说张应该选择打正手\n扬长避短，吃瓜群众都看得出来，何尝张不知道呢？\n只是，如果这么做，他就可能是马琳或刘国梁，而不是那个鲜衣怒马的张继科了。\n\n可能这才是我喜欢的奥运吧。\n\n人有时候，\n就应该热血而执拗\n就应该忽略掉喋喋不休的劝诫\n就应该蠢到无与伦比，不懂变通\n只为在最终的最终，说上一句：\n“还是我赢了”。\n\n","source":"_posts/diary-2016-0814-0820.markdown","raw":"---\nlayout: post\ntitle: \"旧事 奥运 8.14-8.20\"\ndate: 2016-08-21 10:36\ncomments: true\ntags: \n\t- 旧事\n---\n\n每晚小板凳备好，乐呵去守着CCTV5\n里约这个时差刚刚好，反正我忙得不行，只有晚上这点属于自己的时间。\n\n这两周主要看乒乓赛事\n最好看还是男团张继科打郑荣植那场\n郑的反手很强，张却持续使用反手拧拉\n攻彼之长，陷入苦战\n\n杨影相当着急，也说张应该选择打正手\n扬长避短，吃瓜群众都看得出来，何尝张不知道呢？\n只是，如果这么做，他就可能是马琳或刘国梁，而不是那个鲜衣怒马的张继科了。\n\n可能这才是我喜欢的奥运吧。\n\n人有时候，\n就应该热血而执拗\n就应该忽略掉喋喋不休的劝诫\n就应该蠢到无与伦比，不懂变通\n只为在最终的最终，说上一句：\n“还是我赢了”。\n\n","slug":"diary-2016-0814-0820","published":1,"updated":"2018-07-14T07:39:47.545Z","photos":[],"link":"","_id":"cjvayvwfj000lm46apfr3lffa","content":"<p>每晚小板凳备好，乐呵去守着CCTV5<br>里约这个时差刚刚好，反正我忙得不行，只有晚上这点属于自己的时间。</p>\n<p>这两周主要看乒乓赛事<br>最好看还是男团张继科打郑荣植那场<br>郑的反手很强，张却持续使用反手拧拉<br>攻彼之长，陷入苦战</p>\n<p>杨影相当着急，也说张应该选择打正手<br>扬长避短，吃瓜群众都看得出来，何尝张不知道呢？<br>只是，如果这么做，他就可能是马琳或刘国梁，而不是那个鲜衣怒马的张继科了。</p>\n<p>可能这才是我喜欢的奥运吧。</p>\n<p>人有时候，<br>就应该热血而执拗<br>就应该忽略掉喋喋不休的劝诫<br>就应该蠢到无与伦比，不懂变通<br>只为在最终的最终，说上一句：<br>“还是我赢了”。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>每晚小板凳备好，乐呵去守着CCTV5<br>里约这个时差刚刚好，反正我忙得不行，只有晚上这点属于自己的时间。</p>\n<p>这两周主要看乒乓赛事<br>最好看还是男团张继科打郑荣植那场<br>郑的反手很强，张却持续使用反手拧拉<br>攻彼之长，陷入苦战</p>\n<p>杨影相当着急，也说张应该选择打正手<br>扬长避短，吃瓜群众都看得出来，何尝张不知道呢？<br>只是，如果这么做，他就可能是马琳或刘国梁，而不是那个鲜衣怒马的张继科了。</p>\n<p>可能这才是我喜欢的奥运吧。</p>\n<p>人有时候，<br>就应该热血而执拗<br>就应该忽略掉喋喋不休的劝诫<br>就应该蠢到无与伦比，不懂变通<br>只为在最终的最终，说上一句：<br>“还是我赢了”。</p>\n"},{"layout":"post","title":"旧事 木头人 10.23-10.29","date":"2016-10-30T02:36:00.000Z","comments":1,"_content":"\n![](/assets/blogImg/diary-15.jpg)\n\n10月的最后一周，想在天气变冷前，完成一组照片。\n主题跟树林有关，因为我很喜欢这个季节树叶的厚重感。\n不过，木头比人难拍太多了。\n人非草木，起码有表情，有温度，可以装扮。\n有两次回来，我直接就把照片全删了，心情不太爽，怎么想都是这些树木不配合。\n\n后来妥协，是不是我得自己做些改变，营造一种拟人的环境呢？\n因此按快门时，我都很平常的喊一声：“一二三茄子！”\n那时天色已黑，别人一看这里没人啊…\n吓坏了两个孩子。\n对不起！\n\n另外，一个很重要的经验\n去小树林记得要带six god…","source":"_posts/diary-2016-1023-1029.markdown","raw":"---\nlayout: post\ntitle: \"旧事 木头人 10.23-10.29\"\ndate: 2016-10-30 10:36\ncomments: true\ntags: \n\t- 旧事\n---\n\n![](/assets/blogImg/diary-15.jpg)\n\n10月的最后一周，想在天气变冷前，完成一组照片。\n主题跟树林有关，因为我很喜欢这个季节树叶的厚重感。\n不过，木头比人难拍太多了。\n人非草木，起码有表情，有温度，可以装扮。\n有两次回来，我直接就把照片全删了，心情不太爽，怎么想都是这些树木不配合。\n\n后来妥协，是不是我得自己做些改变，营造一种拟人的环境呢？\n因此按快门时，我都很平常的喊一声：“一二三茄子！”\n那时天色已黑，别人一看这里没人啊…\n吓坏了两个孩子。\n对不起！\n\n另外，一个很重要的经验\n去小树林记得要带six god…","slug":"diary-2016-1023-1029","published":1,"updated":"2018-06-21T08:50:00.498Z","photos":[],"link":"","_id":"cjvayvwfk000nm46afjt6qpii","content":"<p><img src=\"/assets/blogImg/diary-15.jpg\" alt></p>\n<p>10月的最后一周，想在天气变冷前，完成一组照片。<br>主题跟树林有关，因为我很喜欢这个季节树叶的厚重感。<br>不过，木头比人难拍太多了。<br>人非草木，起码有表情，有温度，可以装扮。<br>有两次回来，我直接就把照片全删了，心情不太爽，怎么想都是这些树木不配合。</p>\n<p>后来妥协，是不是我得自己做些改变，营造一种拟人的环境呢？<br>因此按快门时，我都很平常的喊一声：“一二三茄子！”<br>那时天色已黑，别人一看这里没人啊…<br>吓坏了两个孩子。<br>对不起！</p>\n<p>另外，一个很重要的经验<br>去小树林记得要带six god…</p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/assets/blogImg/diary-15.jpg\" alt></p>\n<p>10月的最后一周，想在天气变冷前，完成一组照片。<br>主题跟树林有关，因为我很喜欢这个季节树叶的厚重感。<br>不过，木头比人难拍太多了。<br>人非草木，起码有表情，有温度，可以装扮。<br>有两次回来，我直接就把照片全删了，心情不太爽，怎么想都是这些树木不配合。</p>\n<p>后来妥协，是不是我得自己做些改变，营造一种拟人的环境呢？<br>因此按快门时，我都很平常的喊一声：“一二三茄子！”<br>那时天色已黑，别人一看这里没人啊…<br>吓坏了两个孩子。<br>对不起！</p>\n<p>另外，一个很重要的经验<br>去小树林记得要带six god…</p>\n"},{"layout":"post","title":"旧事 imweb-conf 9.4-9.10","date":"2016-09-11T02:36:00.000Z","comments":1,"_content":"\n周六开始\n每到这个时候，都觉得一年又过去得这么快。\n今年，有直播，有嘉宾，居然还有饭吃，太厉害了。\n\n回想自己第一次上台，也是在这个大会。\n不过，当时说的啥肯定很傻。\n但记得我做了个不错的开场。\n果然吹牛更能达成诗和远方、光芒万丈的效果。\n\n另外一个期待，就是能见着许多老朋友\n他们风尘仆仆，从各地赶来。\n八千里路云和月，千里江陵一日还，仿佛一种迷之仪式感，出场的时候都应该会有bgm响起\n\n然而周六那天，突然就发烧了\n应该是前两夜熬夜做设计带来的连锁反应。\n那晚做了个梦：皓月当空，天光似水\n而我的想法居然是，这个月亮好碍眼，怎么用图章工具把这月亮给干掉…\n\nPhotoshop有毒，真的。\n\n恍惚中想起那个，每年惊蛰，朋友从东方带来一壶酒的故事…\n然而早已白露而不是惊蛰，世间上也没有那壶叫醉生梦死的酒。\n","source":"_posts/diary-2016-0904-0910.markdown","raw":"---\nlayout: post\ntitle: \"旧事 imweb-conf 9.4-9.10\"\ndate: 2016-09-11 10:36\ncomments: true\ntags: \n\t- 旧事\n---\n\n周六开始\n每到这个时候，都觉得一年又过去得这么快。\n今年，有直播，有嘉宾，居然还有饭吃，太厉害了。\n\n回想自己第一次上台，也是在这个大会。\n不过，当时说的啥肯定很傻。\n但记得我做了个不错的开场。\n果然吹牛更能达成诗和远方、光芒万丈的效果。\n\n另外一个期待，就是能见着许多老朋友\n他们风尘仆仆，从各地赶来。\n八千里路云和月，千里江陵一日还，仿佛一种迷之仪式感，出场的时候都应该会有bgm响起\n\n然而周六那天，突然就发烧了\n应该是前两夜熬夜做设计带来的连锁反应。\n那晚做了个梦：皓月当空，天光似水\n而我的想法居然是，这个月亮好碍眼，怎么用图章工具把这月亮给干掉…\n\nPhotoshop有毒，真的。\n\n恍惚中想起那个，每年惊蛰，朋友从东方带来一壶酒的故事…\n然而早已白露而不是惊蛰，世间上也没有那壶叫醉生梦死的酒。\n","slug":"diary-2016-0904-0910","published":1,"updated":"2018-07-08T12:43:11.463Z","photos":[],"link":"","_id":"cjvayvwfl000om46a6wlzaxhu","content":"<p>周六开始<br>每到这个时候，都觉得一年又过去得这么快。<br>今年，有直播，有嘉宾，居然还有饭吃，太厉害了。</p>\n<p>回想自己第一次上台，也是在这个大会。<br>不过，当时说的啥肯定很傻。<br>但记得我做了个不错的开场。<br>果然吹牛更能达成诗和远方、光芒万丈的效果。</p>\n<p>另外一个期待，就是能见着许多老朋友<br>他们风尘仆仆，从各地赶来。<br>八千里路云和月，千里江陵一日还，仿佛一种迷之仪式感，出场的时候都应该会有bgm响起</p>\n<p>然而周六那天，突然就发烧了<br>应该是前两夜熬夜做设计带来的连锁反应。<br>那晚做了个梦：皓月当空，天光似水<br>而我的想法居然是，这个月亮好碍眼，怎么用图章工具把这月亮给干掉…</p>\n<p>Photoshop有毒，真的。</p>\n<p>恍惚中想起那个，每年惊蛰，朋友从东方带来一壶酒的故事…<br>然而早已白露而不是惊蛰，世间上也没有那壶叫醉生梦死的酒。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>周六开始<br>每到这个时候，都觉得一年又过去得这么快。<br>今年，有直播，有嘉宾，居然还有饭吃，太厉害了。</p>\n<p>回想自己第一次上台，也是在这个大会。<br>不过，当时说的啥肯定很傻。<br>但记得我做了个不错的开场。<br>果然吹牛更能达成诗和远方、光芒万丈的效果。</p>\n<p>另外一个期待，就是能见着许多老朋友<br>他们风尘仆仆，从各地赶来。<br>八千里路云和月，千里江陵一日还，仿佛一种迷之仪式感，出场的时候都应该会有bgm响起</p>\n<p>然而周六那天，突然就发烧了<br>应该是前两夜熬夜做设计带来的连锁反应。<br>那晚做了个梦：皓月当空，天光似水<br>而我的想法居然是，这个月亮好碍眼，怎么用图章工具把这月亮给干掉…</p>\n<p>Photoshop有毒，真的。</p>\n<p>恍惚中想起那个，每年惊蛰，朋友从东方带来一壶酒的故事…<br>然而早已白露而不是惊蛰，世间上也没有那壶叫醉生梦死的酒。</p>\n"},{"layout":"post","title":"工具 | CSDN博客转 -> markdown","date":"2018-05-25T00:52:00.000Z","author":"Gubaidan","header-img":"/Header/l8Qo5NqYG_k.png","cdn":"header-on","_content":"\n# csdn2md\n\n> 转换html至markdown\n\n### 前言 Before:\n如何转换html至md，简直纠结。         \n\n**因而，用来迁移博客的工具当然有呀。**[github here](https://github.com/Gubaidan/csdn2md.git).\n<!-- more -->\n\n### 使用 Usage:\n\n```java\n@param {author} csdn用户名               \n@param {dirPath} 文件保存路径\n\npublic class Main {\n\n    private static String host = \"http://blog.csdn.net\";\n\n    public static void main(String args[]) throws IOException {\n\n        String author = \"xxxx\";                           //csdn用户名\n\n        String dirPath = \"/Users/xxxx/\";   //文件保存路径（绝对路径）\n\n        new CorePaser().parse(host, author, dirPath, true);  //是否爬取图片 默认false\n    }\n}\n```\n\n### 展示 Show:\n\n展示某个人博客的转换效果\n\n<img style=\"width:80%;\" src=\"http://epoch-night.oss-cn-hangzhou.aliyuncs.com/PostImg/D2338CFF-0768-4E86-AAAA-9E8305FE381F.png\"/>\n\n### 用到的工具\n\n> 工具-[html2markdown](https://github.com/pnikosis/jHTML2Md)","source":"_posts/folder-to-tree.markdown","raw":"---\nlayout: post\ntitle: \"工具 | CSDN博客转 -> markdown\"\ndate: 2018-05-25 08:52\nauthor: \"Gubaidan\"\nheader-img: \"/Header/l8Qo5NqYG_k.png\"\ncdn: 'header-on'\ntags: \n\t- 工具 \n\n---\n\n# csdn2md\n\n> 转换html至markdown\n\n### 前言 Before:\n如何转换html至md，简直纠结。         \n\n**因而，用来迁移博客的工具当然有呀。**[github here](https://github.com/Gubaidan/csdn2md.git).\n<!-- more -->\n\n### 使用 Usage:\n\n```java\n@param {author} csdn用户名               \n@param {dirPath} 文件保存路径\n\npublic class Main {\n\n    private static String host = \"http://blog.csdn.net\";\n\n    public static void main(String args[]) throws IOException {\n\n        String author = \"xxxx\";                           //csdn用户名\n\n        String dirPath = \"/Users/xxxx/\";   //文件保存路径（绝对路径）\n\n        new CorePaser().parse(host, author, dirPath, true);  //是否爬取图片 默认false\n    }\n}\n```\n\n### 展示 Show:\n\n展示某个人博客的转换效果\n\n<img style=\"width:80%;\" src=\"http://epoch-night.oss-cn-hangzhou.aliyuncs.com/PostImg/D2338CFF-0768-4E86-AAAA-9E8305FE381F.png\"/>\n\n### 用到的工具\n\n> 工具-[html2markdown](https://github.com/pnikosis/jHTML2Md)","slug":"folder-to-tree","published":1,"updated":"2019-05-05T12:38:08.007Z","comments":1,"photos":[],"link":"","_id":"cjvayvwfm000rm46ajkkvw1ex","content":"<h1 id=\"csdn2md\"><a href=\"#csdn2md\" class=\"headerlink\" title=\"csdn2md\"></a>csdn2md</h1><blockquote>\n<p>转换html至markdown</p>\n</blockquote>\n<h3 id=\"前言-Before\"><a href=\"#前言-Before\" class=\"headerlink\" title=\"前言 Before:\"></a>前言 Before:</h3><p>如何转换html至md，简直纠结。         </p>\n<p><strong>因而，用来迁移博客的工具当然有呀。</strong><a href=\"https://github.com/Gubaidan/csdn2md.git\" target=\"_blank\" rel=\"noopener\">github here</a>.<br><a id=\"more\"></a></p>\n<h3 id=\"使用-Usage\"><a href=\"#使用-Usage\" class=\"headerlink\" title=\"使用 Usage:\"></a>使用 Usage:</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@param</span> &#123;author&#125; csdn用户名               </span><br><span class=\"line\"><span class=\"meta\">@param</span> &#123;dirPath&#125; 文件保存路径</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> String host = <span class=\"string\">\"http://blog.csdn.net\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        String author = <span class=\"string\">\"xxxx\"</span>;                           <span class=\"comment\">//csdn用户名</span></span><br><span class=\"line\"></span><br><span class=\"line\">        String dirPath = <span class=\"string\">\"/Users/xxxx/\"</span>;   <span class=\"comment\">//文件保存路径（绝对路径）</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> CorePaser().parse(host, author, dirPath, <span class=\"keyword\">true</span>);  <span class=\"comment\">//是否爬取图片 默认false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"展示-Show\"><a href=\"#展示-Show\" class=\"headerlink\" title=\"展示 Show:\"></a>展示 Show:</h3><p>展示某个人博客的转换效果</p>\n<p><img style=\"width:80%;\" src=\"http://epoch-night.oss-cn-hangzhou.aliyuncs.com/PostImg/D2338CFF-0768-4E86-AAAA-9E8305FE381F.png\"></p>\n<h3 id=\"用到的工具\"><a href=\"#用到的工具\" class=\"headerlink\" title=\"用到的工具\"></a>用到的工具</h3><blockquote>\n<p>工具-<a href=\"https://github.com/pnikosis/jHTML2Md\" target=\"_blank\" rel=\"noopener\">html2markdown</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<h1 id=\"csdn2md\"><a href=\"#csdn2md\" class=\"headerlink\" title=\"csdn2md\"></a>csdn2md</h1><blockquote>\n<p>转换html至markdown</p>\n</blockquote>\n<h3 id=\"前言-Before\"><a href=\"#前言-Before\" class=\"headerlink\" title=\"前言 Before:\"></a>前言 Before:</h3><p>如何转换html至md，简直纠结。         </p>\n<p><strong>因而，用来迁移博客的工具当然有呀。</strong><a href=\"https://github.com/Gubaidan/csdn2md.git\" target=\"_blank\" rel=\"noopener\">github here</a>.<br>","more":"</p>\n<h3 id=\"使用-Usage\"><a href=\"#使用-Usage\" class=\"headerlink\" title=\"使用 Usage:\"></a>使用 Usage:</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@param</span> &#123;author&#125; csdn用户名               </span><br><span class=\"line\"><span class=\"meta\">@param</span> &#123;dirPath&#125; 文件保存路径</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> String host = <span class=\"string\">\"http://blog.csdn.net\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        String author = <span class=\"string\">\"xxxx\"</span>;                           <span class=\"comment\">//csdn用户名</span></span><br><span class=\"line\"></span><br><span class=\"line\">        String dirPath = <span class=\"string\">\"/Users/xxxx/\"</span>;   <span class=\"comment\">//文件保存路径（绝对路径）</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> CorePaser().parse(host, author, dirPath, <span class=\"keyword\">true</span>);  <span class=\"comment\">//是否爬取图片 默认false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"展示-Show\"><a href=\"#展示-Show\" class=\"headerlink\" title=\"展示 Show:\"></a>展示 Show:</h3><p>展示某个人博客的转换效果</p>\n<p><img style=\"width:80%;\" src=\"http://epoch-night.oss-cn-hangzhou.aliyuncs.com/PostImg/D2338CFF-0768-4E86-AAAA-9E8305FE381F.png\"></p>\n<h3 id=\"用到的工具\"><a href=\"#用到的工具\" class=\"headerlink\" title=\"用到的工具\"></a>用到的工具</h3><blockquote>\n<p>工具-<a href=\"https://github.com/pnikosis/jHTML2Md\" target=\"_blank\" rel=\"noopener\">html2markdown</a></p>\n</blockquote>"},{"layout":"post","title":"Hello World","date":"2016-04-12T17:39:00.000Z","comments":1,"_content":"\nHello World。\n\n感谢Hexo提供的主题。","source":"_posts/hello-world.markdown","raw":"---\nlayout: post\ntitle: \"Hello World\"\ndate: 2016-4-13 01:39\ncomments: true\ntags: \n\t- 杂谈 \n---\n\nHello World。\n\n感谢Hexo提供的主题。","slug":"hello-world","published":1,"updated":"2018-07-04T06:53:14.343Z","photos":[],"link":"","_id":"cjvayvwfn000sm46a77h1w4vt","content":"<p>Hello World。</p>\n<p>感谢Hexo提供的主题。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Hello World。</p>\n<p>感谢Hexo提供的主题。</p>\n"},{"layout":"post","title":"说到加载图片，我们可以谈些什么","date":"2016-04-28T15:54:00.000Z","comments":1,"_content":"\n![原图 by Denis Perepelenko](/assets/blogImg/lazyload.jpg)    \n\n其实，一开始让我在网页中加载一张图片，我是，是拒绝的…因为实在太简单了。\n\n``<img src=\"xx.jpg\" />``是每个前端开发都会的技能。然而，如果你想做到极致，事情还没有这么简单。\n\n最近实现了个图片加载器，用于大型web前端项目中，关于加载图片这一话题，仔细想来可以加许多的特技。\n\n<!-- more -->\n\n###第一步：滚屏加载\n\n这是最容易想到的点，也是一开始就准备做的。\n\n随web体验的进步，滚屏加载代替分页加载的情形越来越多。也就是先预留图片位置，而不去加载图片，直到这个预留区域滚动到屏幕中，用户能看见了，才去加载图片。如此一来，有“按需加载”的意味，由于图片加载延后，不抢占带宽，在打开页面的首屏会快很多。我们称之为“懒加载(lazyload)”。\n\n其实现也很简单，在html里面写``<img lazy-src=\"xx.jpg\" />``，然后用js去判断这个节点是否出现在屏幕中，如果是，则取出``lazy-src``属性，赋值成``<img lazy-src=\"xx.jpg\" src=\"xx.jpg\"/>``，触发此节点onload，这就实现最简单的滚屏加载了。\n\n###第二步：特殊状态处理\n\n特殊状态有两种：加载中与加载失败。这两种情况的处理逻辑相类似，拿加载中的逻辑做例子。\n\n图片触发加载，到图片加载完成（或失败）之间，肯定会有一段时间。不做处理的话，用户在等待的过程中，就只能看到空白的区域，非常的奇怪。在低网速，以及用户非常快的拉滚动条的情形下，这种现象将更加明显。\n\n那么在触发onload之前，就需要补一些逻辑，展示对应的loading图。\n将需要处理的img节点作为参数，调用tempImg函数，克隆一个节点强行插在img之前，用于loading中的展示。\n\n```\n\tvar tempImg = function(target){\n\t    var w = target.width();\n\t    var h = target.height();\n\t    var tempDom = target.clone().addClass(\"lazy-loding\").insertBefore(target);\n\n\t    if(w/h == 1){\n\t        tempDom[0].src = \"http://9.url.cn/edu/img/img-loading.png\";\n\t    }else{\n\t        tempDom[0].src = \"http://9.url.cn/edu/img/img-loading2.png\";\n\t    }\n\t    target.hide();\n\t}\n```\n\n###第三步：上报监控\n\n这一步在大型前端项目中非常重要，也是经常被忽略的地方。尽管需要简易的后台配合，但不算麻烦的上报监控，能让产品更加稳定和健壮。\n\n我在两个地方用到了上报。其一是图片加载失败，触发``onerror``时，这样一来我们能知道每天图片拉取失败的量；其二是图片加载的时间，能够帮助我们分析cdn服务是否异常，分析全国慢速用户比例等等。\n\n而所谓的上报其实就是一个http请求，我会大概把这些信息带上\n\n```\n    log({\n\t\t'type': 'error',\n\t\t'msg': 'lazyload拉取图片失败上报 ',\n\t\t'url': window.location.href,\n\t\t'pid': 414342  //产品对应的id\n\t});\n```\n\n###第四步：居中截取\n\n这是前端无可避免的一个问题，先来说下此问题的背景。\n\n由于我们是先用一个空白的img标签占位，再去加载图片，如果图片的高度特别长（比如新浪长微博），加载完成时就会撑开节点，引起滚动条的跳动。由于移动端屏幕较PC窄，一个跳动就可能让你找不到前一秒正在浏览的内容，这种体验尤其严重。在移动端的web设计中，可以看到许多知名互联网公司的产品，也经常忽略这一点。\n\n因此我们可以限定占位区域的size，以此区域来做居中截取。当占位区域与图片最终展示同宽同高时，就不会引起跳动，而且也保持了视觉的一致性。\n\n其原理如下，先判断是竖向长型图，还是横向长型图，根据不同的情况，优先让宽或高填充满占位区域，然后通过不同的负margin去实现居中。\n\n```\n\tvar calSize = function($img) {\n\t    var w = $img.width(), h = $img.height(), width = size[0], height = size[1];\n\t    if(w+h == 0) return;\n\n\t    //如果是长型图，优先适配宽度，高度居中截取\n\t    if(w/h > width/height){\n\t        var newWidth = height * w / h;\n\t        var margin = (width - newWidth)/2;\n\t        $img.height(height).css({\"margin-left\": margin});\n\t    }else{\n\t        var newHeight = width * h / w;\n\t        var margin = (height - newHeight)/2;\n\t        $img.width(width).css({\"margin-top\": margin});\n\t    }\n\t}\n```\n\n###第五步：支持webp\n\nwebp格式图片是google开发的一种旨在加快图片加载速度的图片格式，压缩提交大概只有jpg的2/3。随chrome的比例越来越多，其实让更多用户体验到webp也是一件好事。\n\n那么问题来了，怎么去判断用户的浏览器是否支持webp呢？\n根据ua去判断是个好方法，但不太靠谱，因为chrome中其实也有设置，让它不能去支持webp，而且webkit本身就开源，会衍生出很多你不知道名字的浏览器。\n\n最终我使用的是特性检测：\n\n```\n\tif(!supportedWebPIsLoading) {\n\t    supportedWebPIsLoading = true;\n\t    var images = {\n\t        basic: \"data:image/webp;base64,UklGRjIAAABXRUJQVlA4ICYAAACyAgCdASoCAAEALmk0mk0iIiIiIgBoSygABc6zbAAA/v56QAAAAA==\"\n\t    }, $img = new Image();\n\t    $img.onload = function () {\n\t        supportedWebPIsLoading = false;\n\t        $.cookie.set(\"iswebp\" , +supportedWebP);\n\t    };\n\t    $img.onerror = function () {\n\t        supportedWebP = false;\n\t        supportedWebPIsLoading = false;\n\t        $.cookie.set(\"iswebp\" , +supportedWebP);\n\t    };\n\t    $img.src = images.basic;\n\t}\n```\n\n我们会让浏览器试着加载一张非常小的base64格式的webp图片，如果能够正常加载，说明是支持webp的。\n\n并且，会把测试记录在cookie里，所以第二次直接从cookie里读结果，基本不会影响性能。完成了最重要的检查，我们就可以放心让服务器返回不同格式的图片了。\n\n\nEnd.","source":"_posts/img-lazy-load.markdown","raw":"---\nlayout: post\ntitle: \"说到加载图片，我们可以谈些什么\"\ndate: 2016-04-28 23:54\ncomments: true\ntags: \n\t- js\n---\n\n![原图 by Denis Perepelenko](/assets/blogImg/lazyload.jpg)    \n\n其实，一开始让我在网页中加载一张图片，我是，是拒绝的…因为实在太简单了。\n\n``<img src=\"xx.jpg\" />``是每个前端开发都会的技能。然而，如果你想做到极致，事情还没有这么简单。\n\n最近实现了个图片加载器，用于大型web前端项目中，关于加载图片这一话题，仔细想来可以加许多的特技。\n\n<!-- more -->\n\n###第一步：滚屏加载\n\n这是最容易想到的点，也是一开始就准备做的。\n\n随web体验的进步，滚屏加载代替分页加载的情形越来越多。也就是先预留图片位置，而不去加载图片，直到这个预留区域滚动到屏幕中，用户能看见了，才去加载图片。如此一来，有“按需加载”的意味，由于图片加载延后，不抢占带宽，在打开页面的首屏会快很多。我们称之为“懒加载(lazyload)”。\n\n其实现也很简单，在html里面写``<img lazy-src=\"xx.jpg\" />``，然后用js去判断这个节点是否出现在屏幕中，如果是，则取出``lazy-src``属性，赋值成``<img lazy-src=\"xx.jpg\" src=\"xx.jpg\"/>``，触发此节点onload，这就实现最简单的滚屏加载了。\n\n###第二步：特殊状态处理\n\n特殊状态有两种：加载中与加载失败。这两种情况的处理逻辑相类似，拿加载中的逻辑做例子。\n\n图片触发加载，到图片加载完成（或失败）之间，肯定会有一段时间。不做处理的话，用户在等待的过程中，就只能看到空白的区域，非常的奇怪。在低网速，以及用户非常快的拉滚动条的情形下，这种现象将更加明显。\n\n那么在触发onload之前，就需要补一些逻辑，展示对应的loading图。\n将需要处理的img节点作为参数，调用tempImg函数，克隆一个节点强行插在img之前，用于loading中的展示。\n\n```\n\tvar tempImg = function(target){\n\t    var w = target.width();\n\t    var h = target.height();\n\t    var tempDom = target.clone().addClass(\"lazy-loding\").insertBefore(target);\n\n\t    if(w/h == 1){\n\t        tempDom[0].src = \"http://9.url.cn/edu/img/img-loading.png\";\n\t    }else{\n\t        tempDom[0].src = \"http://9.url.cn/edu/img/img-loading2.png\";\n\t    }\n\t    target.hide();\n\t}\n```\n\n###第三步：上报监控\n\n这一步在大型前端项目中非常重要，也是经常被忽略的地方。尽管需要简易的后台配合，但不算麻烦的上报监控，能让产品更加稳定和健壮。\n\n我在两个地方用到了上报。其一是图片加载失败，触发``onerror``时，这样一来我们能知道每天图片拉取失败的量；其二是图片加载的时间，能够帮助我们分析cdn服务是否异常，分析全国慢速用户比例等等。\n\n而所谓的上报其实就是一个http请求，我会大概把这些信息带上\n\n```\n    log({\n\t\t'type': 'error',\n\t\t'msg': 'lazyload拉取图片失败上报 ',\n\t\t'url': window.location.href,\n\t\t'pid': 414342  //产品对应的id\n\t});\n```\n\n###第四步：居中截取\n\n这是前端无可避免的一个问题，先来说下此问题的背景。\n\n由于我们是先用一个空白的img标签占位，再去加载图片，如果图片的高度特别长（比如新浪长微博），加载完成时就会撑开节点，引起滚动条的跳动。由于移动端屏幕较PC窄，一个跳动就可能让你找不到前一秒正在浏览的内容，这种体验尤其严重。在移动端的web设计中，可以看到许多知名互联网公司的产品，也经常忽略这一点。\n\n因此我们可以限定占位区域的size，以此区域来做居中截取。当占位区域与图片最终展示同宽同高时，就不会引起跳动，而且也保持了视觉的一致性。\n\n其原理如下，先判断是竖向长型图，还是横向长型图，根据不同的情况，优先让宽或高填充满占位区域，然后通过不同的负margin去实现居中。\n\n```\n\tvar calSize = function($img) {\n\t    var w = $img.width(), h = $img.height(), width = size[0], height = size[1];\n\t    if(w+h == 0) return;\n\n\t    //如果是长型图，优先适配宽度，高度居中截取\n\t    if(w/h > width/height){\n\t        var newWidth = height * w / h;\n\t        var margin = (width - newWidth)/2;\n\t        $img.height(height).css({\"margin-left\": margin});\n\t    }else{\n\t        var newHeight = width * h / w;\n\t        var margin = (height - newHeight)/2;\n\t        $img.width(width).css({\"margin-top\": margin});\n\t    }\n\t}\n```\n\n###第五步：支持webp\n\nwebp格式图片是google开发的一种旨在加快图片加载速度的图片格式，压缩提交大概只有jpg的2/3。随chrome的比例越来越多，其实让更多用户体验到webp也是一件好事。\n\n那么问题来了，怎么去判断用户的浏览器是否支持webp呢？\n根据ua去判断是个好方法，但不太靠谱，因为chrome中其实也有设置，让它不能去支持webp，而且webkit本身就开源，会衍生出很多你不知道名字的浏览器。\n\n最终我使用的是特性检测：\n\n```\n\tif(!supportedWebPIsLoading) {\n\t    supportedWebPIsLoading = true;\n\t    var images = {\n\t        basic: \"data:image/webp;base64,UklGRjIAAABXRUJQVlA4ICYAAACyAgCdASoCAAEALmk0mk0iIiIiIgBoSygABc6zbAAA/v56QAAAAA==\"\n\t    }, $img = new Image();\n\t    $img.onload = function () {\n\t        supportedWebPIsLoading = false;\n\t        $.cookie.set(\"iswebp\" , +supportedWebP);\n\t    };\n\t    $img.onerror = function () {\n\t        supportedWebP = false;\n\t        supportedWebPIsLoading = false;\n\t        $.cookie.set(\"iswebp\" , +supportedWebP);\n\t    };\n\t    $img.src = images.basic;\n\t}\n```\n\n我们会让浏览器试着加载一张非常小的base64格式的webp图片，如果能够正常加载，说明是支持webp的。\n\n并且，会把测试记录在cookie里，所以第二次直接从cookie里读结果，基本不会影响性能。完成了最重要的检查，我们就可以放心让服务器返回不同格式的图片了。\n\n\nEnd.","slug":"img-lazy-load","published":1,"updated":"2018-07-04T06:53:22.463Z","photos":[],"link":"","_id":"cjvayvwfo000um46abz3qzb2c","content":"<p><img src=\"/assets/blogImg/lazyload.jpg\" alt=\"原图 by Denis Perepelenko\">    </p>\n<p>其实，一开始让我在网页中加载一张图片，我是，是拒绝的…因为实在太简单了。</p>\n<p><code>&lt;img src=&quot;xx.jpg&quot; /&gt;</code>是每个前端开发都会的技能。然而，如果你想做到极致，事情还没有这么简单。</p>\n<p>最近实现了个图片加载器，用于大型web前端项目中，关于加载图片这一话题，仔细想来可以加许多的特技。</p>\n<a id=\"more\"></a>\n<p>###第一步：滚屏加载</p>\n<p>这是最容易想到的点，也是一开始就准备做的。</p>\n<p>随web体验的进步，滚屏加载代替分页加载的情形越来越多。也就是先预留图片位置，而不去加载图片，直到这个预留区域滚动到屏幕中，用户能看见了，才去加载图片。如此一来，有“按需加载”的意味，由于图片加载延后，不抢占带宽，在打开页面的首屏会快很多。我们称之为“懒加载(lazyload)”。</p>\n<p>其实现也很简单，在html里面写<code>&lt;img lazy-src=&quot;xx.jpg&quot; /&gt;</code>，然后用js去判断这个节点是否出现在屏幕中，如果是，则取出<code>lazy-src</code>属性，赋值成<code>&lt;img lazy-src=&quot;xx.jpg&quot; src=&quot;xx.jpg&quot;/&gt;</code>，触发此节点onload，这就实现最简单的滚屏加载了。</p>\n<p>###第二步：特殊状态处理</p>\n<p>特殊状态有两种：加载中与加载失败。这两种情况的处理逻辑相类似，拿加载中的逻辑做例子。</p>\n<p>图片触发加载，到图片加载完成（或失败）之间，肯定会有一段时间。不做处理的话，用户在等待的过程中，就只能看到空白的区域，非常的奇怪。在低网速，以及用户非常快的拉滚动条的情形下，这种现象将更加明显。</p>\n<p>那么在触发onload之前，就需要补一些逻辑，展示对应的loading图。<br>将需要处理的img节点作为参数，调用tempImg函数，克隆一个节点强行插在img之前，用于loading中的展示。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var tempImg = function(target)&#123;</span><br><span class=\"line\">    var w = target.width();</span><br><span class=\"line\">    var h = target.height();</span><br><span class=\"line\">    var tempDom = target.clone().addClass(&quot;lazy-loding&quot;).insertBefore(target);</span><br><span class=\"line\"></span><br><span class=\"line\">    if(w/h == 1)&#123;</span><br><span class=\"line\">        tempDom[0].src = &quot;http://9.url.cn/edu/img/img-loading.png&quot;;</span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">        tempDom[0].src = &quot;http://9.url.cn/edu/img/img-loading2.png&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    target.hide();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>###第三步：上报监控</p>\n<p>这一步在大型前端项目中非常重要，也是经常被忽略的地方。尽管需要简易的后台配合，但不算麻烦的上报监控，能让产品更加稳定和健壮。</p>\n<p>我在两个地方用到了上报。其一是图片加载失败，触发<code>onerror</code>时，这样一来我们能知道每天图片拉取失败的量；其二是图片加载的时间，能够帮助我们分析cdn服务是否异常，分析全国慢速用户比例等等。</p>\n<p>而所谓的上报其实就是一个http请求，我会大概把这些信息带上</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">   log(&#123;</span><br><span class=\"line\">\t&apos;type&apos;: &apos;error&apos;,</span><br><span class=\"line\">\t&apos;msg&apos;: &apos;lazyload拉取图片失败上报 &apos;,</span><br><span class=\"line\">\t&apos;url&apos;: window.location.href,</span><br><span class=\"line\">\t&apos;pid&apos;: 414342  //产品对应的id</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>###第四步：居中截取</p>\n<p>这是前端无可避免的一个问题，先来说下此问题的背景。</p>\n<p>由于我们是先用一个空白的img标签占位，再去加载图片，如果图片的高度特别长（比如新浪长微博），加载完成时就会撑开节点，引起滚动条的跳动。由于移动端屏幕较PC窄，一个跳动就可能让你找不到前一秒正在浏览的内容，这种体验尤其严重。在移动端的web设计中，可以看到许多知名互联网公司的产品，也经常忽略这一点。</p>\n<p>因此我们可以限定占位区域的size，以此区域来做居中截取。当占位区域与图片最终展示同宽同高时，就不会引起跳动，而且也保持了视觉的一致性。</p>\n<p>其原理如下，先判断是竖向长型图，还是横向长型图，根据不同的情况，优先让宽或高填充满占位区域，然后通过不同的负margin去实现居中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var calSize = function($img) &#123;</span><br><span class=\"line\">    var w = $img.width(), h = $img.height(), width = size[0], height = size[1];</span><br><span class=\"line\">    if(w+h == 0) return;</span><br><span class=\"line\"></span><br><span class=\"line\">    //如果是长型图，优先适配宽度，高度居中截取</span><br><span class=\"line\">    if(w/h &gt; width/height)&#123;</span><br><span class=\"line\">        var newWidth = height * w / h;</span><br><span class=\"line\">        var margin = (width - newWidth)/2;</span><br><span class=\"line\">        $img.height(height).css(&#123;&quot;margin-left&quot;: margin&#125;);</span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">        var newHeight = width * h / w;</span><br><span class=\"line\">        var margin = (height - newHeight)/2;</span><br><span class=\"line\">        $img.width(width).css(&#123;&quot;margin-top&quot;: margin&#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>###第五步：支持webp</p>\n<p>webp格式图片是google开发的一种旨在加快图片加载速度的图片格式，压缩提交大概只有jpg的2/3。随chrome的比例越来越多，其实让更多用户体验到webp也是一件好事。</p>\n<p>那么问题来了，怎么去判断用户的浏览器是否支持webp呢？<br>根据ua去判断是个好方法，但不太靠谱，因为chrome中其实也有设置，让它不能去支持webp，而且webkit本身就开源，会衍生出很多你不知道名字的浏览器。</p>\n<p>最终我使用的是特性检测：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">if(!supportedWebPIsLoading) &#123;</span><br><span class=\"line\">    supportedWebPIsLoading = true;</span><br><span class=\"line\">    var images = &#123;</span><br><span class=\"line\">        basic: &quot;data:image/webp;base64,UklGRjIAAABXRUJQVlA4ICYAAACyAgCdASoCAAEALmk0mk0iIiIiIgBoSygABc6zbAAA/v56QAAAAA==&quot;</span><br><span class=\"line\">    &#125;, $img = new Image();</span><br><span class=\"line\">    $img.onload = function () &#123;</span><br><span class=\"line\">        supportedWebPIsLoading = false;</span><br><span class=\"line\">        $.cookie.set(&quot;iswebp&quot; , +supportedWebP);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    $img.onerror = function () &#123;</span><br><span class=\"line\">        supportedWebP = false;</span><br><span class=\"line\">        supportedWebPIsLoading = false;</span><br><span class=\"line\">        $.cookie.set(&quot;iswebp&quot; , +supportedWebP);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    $img.src = images.basic;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们会让浏览器试着加载一张非常小的base64格式的webp图片，如果能够正常加载，说明是支持webp的。</p>\n<p>并且，会把测试记录在cookie里，所以第二次直接从cookie里读结果，基本不会影响性能。完成了最重要的检查，我们就可以放心让服务器返回不同格式的图片了。</p>\n<p>End.</p>\n","site":{"data":{}},"excerpt":"<p><img src=\"/assets/blogImg/lazyload.jpg\" alt=\"原图 by Denis Perepelenko\">    </p>\n<p>其实，一开始让我在网页中加载一张图片，我是，是拒绝的…因为实在太简单了。</p>\n<p><code>&lt;img src=&quot;xx.jpg&quot; /&gt;</code>是每个前端开发都会的技能。然而，如果你想做到极致，事情还没有这么简单。</p>\n<p>最近实现了个图片加载器，用于大型web前端项目中，关于加载图片这一话题，仔细想来可以加许多的特技。</p>","more":"<p>###第一步：滚屏加载</p>\n<p>这是最容易想到的点，也是一开始就准备做的。</p>\n<p>随web体验的进步，滚屏加载代替分页加载的情形越来越多。也就是先预留图片位置，而不去加载图片，直到这个预留区域滚动到屏幕中，用户能看见了，才去加载图片。如此一来，有“按需加载”的意味，由于图片加载延后，不抢占带宽，在打开页面的首屏会快很多。我们称之为“懒加载(lazyload)”。</p>\n<p>其实现也很简单，在html里面写<code>&lt;img lazy-src=&quot;xx.jpg&quot; /&gt;</code>，然后用js去判断这个节点是否出现在屏幕中，如果是，则取出<code>lazy-src</code>属性，赋值成<code>&lt;img lazy-src=&quot;xx.jpg&quot; src=&quot;xx.jpg&quot;/&gt;</code>，触发此节点onload，这就实现最简单的滚屏加载了。</p>\n<p>###第二步：特殊状态处理</p>\n<p>特殊状态有两种：加载中与加载失败。这两种情况的处理逻辑相类似，拿加载中的逻辑做例子。</p>\n<p>图片触发加载，到图片加载完成（或失败）之间，肯定会有一段时间。不做处理的话，用户在等待的过程中，就只能看到空白的区域，非常的奇怪。在低网速，以及用户非常快的拉滚动条的情形下，这种现象将更加明显。</p>\n<p>那么在触发onload之前，就需要补一些逻辑，展示对应的loading图。<br>将需要处理的img节点作为参数，调用tempImg函数，克隆一个节点强行插在img之前，用于loading中的展示。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var tempImg = function(target)&#123;</span><br><span class=\"line\">    var w = target.width();</span><br><span class=\"line\">    var h = target.height();</span><br><span class=\"line\">    var tempDom = target.clone().addClass(&quot;lazy-loding&quot;).insertBefore(target);</span><br><span class=\"line\"></span><br><span class=\"line\">    if(w/h == 1)&#123;</span><br><span class=\"line\">        tempDom[0].src = &quot;http://9.url.cn/edu/img/img-loading.png&quot;;</span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">        tempDom[0].src = &quot;http://9.url.cn/edu/img/img-loading2.png&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    target.hide();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>###第三步：上报监控</p>\n<p>这一步在大型前端项目中非常重要，也是经常被忽略的地方。尽管需要简易的后台配合，但不算麻烦的上报监控，能让产品更加稳定和健壮。</p>\n<p>我在两个地方用到了上报。其一是图片加载失败，触发<code>onerror</code>时，这样一来我们能知道每天图片拉取失败的量；其二是图片加载的时间，能够帮助我们分析cdn服务是否异常，分析全国慢速用户比例等等。</p>\n<p>而所谓的上报其实就是一个http请求，我会大概把这些信息带上</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">   log(&#123;</span><br><span class=\"line\">\t&apos;type&apos;: &apos;error&apos;,</span><br><span class=\"line\">\t&apos;msg&apos;: &apos;lazyload拉取图片失败上报 &apos;,</span><br><span class=\"line\">\t&apos;url&apos;: window.location.href,</span><br><span class=\"line\">\t&apos;pid&apos;: 414342  //产品对应的id</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>###第四步：居中截取</p>\n<p>这是前端无可避免的一个问题，先来说下此问题的背景。</p>\n<p>由于我们是先用一个空白的img标签占位，再去加载图片，如果图片的高度特别长（比如新浪长微博），加载完成时就会撑开节点，引起滚动条的跳动。由于移动端屏幕较PC窄，一个跳动就可能让你找不到前一秒正在浏览的内容，这种体验尤其严重。在移动端的web设计中，可以看到许多知名互联网公司的产品，也经常忽略这一点。</p>\n<p>因此我们可以限定占位区域的size，以此区域来做居中截取。当占位区域与图片最终展示同宽同高时，就不会引起跳动，而且也保持了视觉的一致性。</p>\n<p>其原理如下，先判断是竖向长型图，还是横向长型图，根据不同的情况，优先让宽或高填充满占位区域，然后通过不同的负margin去实现居中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var calSize = function($img) &#123;</span><br><span class=\"line\">    var w = $img.width(), h = $img.height(), width = size[0], height = size[1];</span><br><span class=\"line\">    if(w+h == 0) return;</span><br><span class=\"line\"></span><br><span class=\"line\">    //如果是长型图，优先适配宽度，高度居中截取</span><br><span class=\"line\">    if(w/h &gt; width/height)&#123;</span><br><span class=\"line\">        var newWidth = height * w / h;</span><br><span class=\"line\">        var margin = (width - newWidth)/2;</span><br><span class=\"line\">        $img.height(height).css(&#123;&quot;margin-left&quot;: margin&#125;);</span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">        var newHeight = width * h / w;</span><br><span class=\"line\">        var margin = (height - newHeight)/2;</span><br><span class=\"line\">        $img.width(width).css(&#123;&quot;margin-top&quot;: margin&#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>###第五步：支持webp</p>\n<p>webp格式图片是google开发的一种旨在加快图片加载速度的图片格式，压缩提交大概只有jpg的2/3。随chrome的比例越来越多，其实让更多用户体验到webp也是一件好事。</p>\n<p>那么问题来了，怎么去判断用户的浏览器是否支持webp呢？<br>根据ua去判断是个好方法，但不太靠谱，因为chrome中其实也有设置，让它不能去支持webp，而且webkit本身就开源，会衍生出很多你不知道名字的浏览器。</p>\n<p>最终我使用的是特性检测：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">if(!supportedWebPIsLoading) &#123;</span><br><span class=\"line\">    supportedWebPIsLoading = true;</span><br><span class=\"line\">    var images = &#123;</span><br><span class=\"line\">        basic: &quot;data:image/webp;base64,UklGRjIAAABXRUJQVlA4ICYAAACyAgCdASoCAAEALmk0mk0iIiIiIgBoSygABc6zbAAA/v56QAAAAA==&quot;</span><br><span class=\"line\">    &#125;, $img = new Image();</span><br><span class=\"line\">    $img.onload = function () &#123;</span><br><span class=\"line\">        supportedWebPIsLoading = false;</span><br><span class=\"line\">        $.cookie.set(&quot;iswebp&quot; , +supportedWebP);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    $img.onerror = function () &#123;</span><br><span class=\"line\">        supportedWebP = false;</span><br><span class=\"line\">        supportedWebPIsLoading = false;</span><br><span class=\"line\">        $.cookie.set(&quot;iswebp&quot; , +supportedWebP);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    $img.src = images.basic;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们会让浏览器试着加载一张非常小的base64格式的webp图片，如果能够正常加载，说明是支持webp的。</p>\n<p>并且，会把测试记录在cookie里，所以第二次直接从cookie里读结果，基本不会影响性能。完成了最重要的检查，我们就可以放心让服务器返回不同格式的图片了。</p>\n<p>End.</p>"},{"layout":"post","title":"Blog主题更新-1.0","date":"2017-12-16T07:16:00.000Z","author":"Gubaidan","header-img":"/Header/l8Qo5NqYG_k.png","cdn":"header-on","_content":"\n此博客更新自 [Anisina v-3.0](https://github.com/Gubaidan/hexo-theme-Anisina)\n\n这次的主题更新重点放在**功能的完善与优化**上，以下是本次（<code>1.0</code>）的更新内容：    \n\n### 更新记录\n\n* V 1.0 \n  * **新增** - 修改原主题字体为Lato字体，更加清晰舒适。\n\n  * **新增** - “新浪微博”按钮\n\n  * **新增** - [来比力]第三方评论平台\n\n  * **新增** - 代码高亮显示\n\n  * **修改** - 精简原主题代码\n\n  * **新增** - 数学公式支持\n\n  * **修改** - 修改归档样式为时间轴样式\n\n  * **修改** - tags 跳一跳\n\n    \n\n","source":"_posts/theme-update1-dot-0.markdown","raw":"---\nlayout: post\ntitle: \"Blog主题更新-1.0\"\ndate: 2017-12-16 15:16\nauthor: \"Gubaidan\"\nheader-img: \"/Header/l8Qo5NqYG_k.png\"\ncdn: 'header-on' \ntags: \n\t- 主题\n---\n\n此博客更新自 [Anisina v-3.0](https://github.com/Gubaidan/hexo-theme-Anisina)\n\n这次的主题更新重点放在**功能的完善与优化**上，以下是本次（<code>1.0</code>）的更新内容：    \n\n### 更新记录\n\n* V 1.0 \n  * **新增** - 修改原主题字体为Lato字体，更加清晰舒适。\n\n  * **新增** - “新浪微博”按钮\n\n  * **新增** - [来比力]第三方评论平台\n\n  * **新增** - 代码高亮显示\n\n  * **修改** - 精简原主题代码\n\n  * **新增** - 数学公式支持\n\n  * **修改** - 修改归档样式为时间轴样式\n\n  * **修改** - tags 跳一跳\n\n    \n\n","slug":"theme-update1-dot-0","published":1,"updated":"2018-07-22T05:20:06.349Z","comments":1,"photos":[],"link":"","_id":"cjvayvwfp000wm46aexp4rmey","content":"<p>此博客更新自 <a href=\"https://github.com/Gubaidan/hexo-theme-Anisina\" target=\"_blank\" rel=\"noopener\">Anisina v-3.0</a></p>\n<p>这次的主题更新重点放在<strong>功能的完善与优化</strong>上，以下是本次（<code>1.0</code>）的更新内容：    </p>\n<h3 id=\"更新记录\"><a href=\"#更新记录\" class=\"headerlink\" title=\"更新记录\"></a>更新记录</h3><ul>\n<li><p>V 1.0 </p>\n<ul>\n<li><p><strong>新增</strong> - 修改原主题字体为Lato字体，更加清晰舒适。</p>\n</li>\n<li><p><strong>新增</strong> - “新浪微博”按钮</p>\n</li>\n<li><p><strong>新增</strong> - [来比力]第三方评论平台</p>\n</li>\n<li><p><strong>新增</strong> - 代码高亮显示</p>\n</li>\n<li><p><strong>修改</strong> - 精简原主题代码</p>\n</li>\n<li><p><strong>新增</strong> - 数学公式支持</p>\n</li>\n<li><p><strong>修改</strong> - 修改归档样式为时间轴样式</p>\n</li>\n<li><p><strong>修改</strong> - tags 跳一跳</p>\n</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>此博客更新自 <a href=\"https://github.com/Gubaidan/hexo-theme-Anisina\" target=\"_blank\" rel=\"noopener\">Anisina v-3.0</a></p>\n<p>这次的主题更新重点放在<strong>功能的完善与优化</strong>上，以下是本次（<code>1.0</code>）的更新内容：    </p>\n<h3 id=\"更新记录\"><a href=\"#更新记录\" class=\"headerlink\" title=\"更新记录\"></a>更新记录</h3><ul>\n<li><p>V 1.0 </p>\n<ul>\n<li><p><strong>新增</strong> - 修改原主题字体为Lato字体，更加清晰舒适。</p>\n</li>\n<li><p><strong>新增</strong> - “新浪微博”按钮</p>\n</li>\n<li><p><strong>新增</strong> - [来比力]第三方评论平台</p>\n</li>\n<li><p><strong>新增</strong> - 代码高亮显示</p>\n</li>\n<li><p><strong>修改</strong> - 精简原主题代码</p>\n</li>\n<li><p><strong>新增</strong> - 数学公式支持</p>\n</li>\n<li><p><strong>修改</strong> - 修改归档样式为时间轴样式</p>\n</li>\n<li><p><strong>修改</strong> - tags 跳一跳</p>\n</li>\n</ul>\n</li>\n</ul>\n"},{"layout":"post","title":"反击爬虫，前端工程师的脑洞可以有多大？","date":"2017-07-09T02:36:00.000Z","comments":1,"toc":true,"_content":"\n<img src=\"http://epoch-night.oss-cn-hangzhou.aliyuncs.com/PostImg/FmIvXiOiFFET4oPGkVU6rdDCl87S\" width=\"400\">\n\n\n\n### 1. 前言\n\n对于一张网页，我们往往希望它是结构良好，内容清晰的，这样搜索引擎才能准确地认知它。       \n而反过来，又有一些情景，我们不希望内容能被轻易获取，比方说电商网站的交易额，教育网站的题目等。因为这些内容，往往是一个产品的生命线，必须做到有效地保护。这就是**爬虫与反爬虫**这一话题的由来。\n\n<!-- more -->\n\n### 2. 常见反爬虫策略\n\n但是世界上没有一个网站，能做到完美地反爬虫。\n\n如果页面希望能在用户面前正常展示，同时又不给爬虫机会，就必须要做到识别真人与机器人。因此工程师们做了各种尝试，这些策略大多采用于**后端**，也是目前比较常规单有效的手段，比如：\n* User-Agent + Referer检测\n* 账号及Cookie验证\n* 验证码\n* IP限制频次\n\n而爬虫是可以无限逼近于真人的，比如：\n* chrome headless或phantomjs来模拟浏览器环境\n* [tesseract](http://udn.yyuap.com/doc/ae/920457.html)识别验证码\n* 代理IP淘宝就能买到\n\n所以我们说，100%的反爬虫策略？不存在的。        \n更多的是体力活，是个难易程度的问题。\n\n不过作为前端工程师，我们可以增加一下游戏难度，设计出一些**很(sang)有(xin)意(bing)思(kuang)**的反爬虫策略。\n\n### 3. 前端与反爬虫\n\n#### 3.1 font-face拼凑式\n\n**例子：[猫眼电影](http://maoyan.com/films/342601)**\n\n猫眼电影里，对于票房数据，展示的并不是纯粹的数字。\n页面使用了font-face定义了字符集，并通过unicode去映射展示。也就是说，除去图像识别，必须同时爬取字符集，才能识别出数字。\n\n![](http://7tszky.com1.z0.glb.clouddn.com/Fr4tKHT39qEwCjjK7QlhWpHWNkvs)\n\n并且，每次刷新页面，字符集的url都是有变化的，无疑更大难度地增加了爬取成本。\n\n![](http://7tszky.com1.z0.glb.clouddn.com/FnBGGXcZgJ_PN9CbX5gVz_f5Y579)\n\n\n#### 3.2 background拼凑式\n\n**例子：[美团](http://www.meituan.com/dianying/342601?#content)**\n\n与font的策略类似，美团里用到的是background拼凑。数字其实是图片，根据不同的background偏移，显示出不同的字符。\n\n![](http://7tszky.com1.z0.glb.clouddn.com/FvAROr33mC0rpTFO46Xtl3j-8HrW)\n\n并且不同页面，图片的字符排序也是有区别的。不过理论上只需生成0-9与小数点，为何有重复字符就不是很懂。\n\n页面A：\n![](http://7tszky.com1.z0.glb.clouddn.com/Fp_3RGHisGjjKoofp-W7oOx731ry)\n页面B：\n![](http://7tszky.com1.z0.glb.clouddn.com/FiuQ2nSHzD6VoM2L_LDloXUo9ndL)\n\n\n#### 3.3 字符穿插式\n\n**例子：[微信公众号文章](https://mp.weixin.qq.com/s?__biz=MzI0MDYwNjk2OA==&mid=2247484365&idx=4&sn=291a93e8a4ce6e90d3b6ef8b98fe09c4&chksm=e919085ade6e814cc037ecf6a873f22da0e492911a4e539e6f8fdeff022806b4d248c4d54194&scene=4)**\n\n\n某些微信公众号的文章里，穿插了各种迷之字符，并且通过样式把这些字符隐藏掉。       \n这种方式虽然令人震惊…但其实没有太大的识别与过滤难度，甚至可以做得更好，不过也算是一种脑洞吧。\n![](http://7tszky.com1.z0.glb.clouddn.com/FoFF_VXDYzM0DyLDjAbOz8ATzH59)\n\n对了，我的手机流量可以找谁报销吗？\n\n\n#### 3.4 伪元素隐藏式\n\n**例子：[汽车之家](http://car.autohome.com.cn/config/series/3170.html)**\n\n汽车之家里，把关键的厂商信息，做到了伪元素的content里。        \n这也是一种思路：爬取网页，必须得解析css，需要拿到伪元素的content，这就提升了爬虫的难度。\n\n![](http://7tszky.com1.z0.glb.clouddn.com/FslsPbUtQhM2uE_bK-LZw7NHynl5)\n\n\n#### 3.5 元素定位覆盖式\n\n**例子：[去哪儿](https://flight.qunar.com/site/oneway_list.htm?searchDepartureAirport=%E5%B9%BF%E5%B7%9E&searchArrivalAirport=%E5%8C%97%E4%BA%AC&searchDepartureTime=2017-07-06&searchArrivalTime=2017-07-09&nextNDays=0&startSearch=true&fromCode=CAN&toCode=BJS&from=qunarindex&lowestPrice=null)**\n\n还有热爱数学的去哪儿，对于一个4位数字的机票价格，先用四个``i``标签渲染，再用两个``b``标签去绝对定位偏移量，覆盖故意展示错误的``i``标签，最后在视觉上形成正确的价格…\n\n![](http://7tszky.com1.z0.glb.clouddn.com/FtZdGFs-53tAYT10GS_ukosJL8CF)\n\n这说明爬虫会解析css还不行，还得会做数学题。\n\n\n#### 3.6 iframe异步加载式\n\n**例子：[网易云音乐](http://music.163.com/#/song?id=424477863)**\n\n网易云音乐页面一打开，html源码里几乎只有一个``iframe``，并且它的src是空白的：``about:blank``。接着js开始运行，把整个页面的框架异步塞到了iframe里面…\n\n![](http://7tszky.com1.z0.glb.clouddn.com/FjHp4gqXWu1YeYWVJ1vkMAgRzO-g)\n\n不过这个方式带来的难度并不大，只是在异步与iframe处理上绕了个弯（或者有其他原因，不完全是基于反爬虫考虑），无论你是用selenium还是phantom，都有API可以拿到iframe里面的content信息。\n\n\n#### 3.7 字符分割式\n\n**例子：[全网代理IP](http://www.goubanjia.com/)**\n\n在一些展示代理IP信息的页面，对于IP的保护也是大费周折。\n\n![](http://7tszky.com1.z0.glb.clouddn.com/FiY93YeoTulfbXWBxfX3nrksVQVV)\n\n他们会先把IP的数字与符号分割成dom节点，再在中间插入迷惑人的数字，如果爬虫不知道这个策略，还会以为自己成功拿到了数值；不过如果爬虫注意到，就很好解决了。\n\n\n#### 3.8 字符集替换式\n\n**例子：[去哪儿移动侧](https://m.flight.qunar.com/ncs/page/flightlist?depCity=%E5%8C%97%E4%BA%AC&arrCity=%E4%B8%8A%E6%B5%B7&goDate=2017-07-05&backDate=&sort=&airLine=&from=)**\n\n同样会欺骗爬虫的还有去哪儿的移动版。\n\n![](http://7tszky.com1.z0.glb.clouddn.com/Ft3i0NfbT8udcJ-OMIQQvdeU-LTb)\n\nhtml里明明写的3211，视觉上展示的却是1233。原来他们重新定义了字符集，3与1的顺序刚好调换得来的结果…\n\n![](http://7tszky.com1.z0.glb.clouddn.com/FoMbTu14ollkxEO0tSv7F55ZVxMq)","source":"_posts/prevent-spiders.markdown","raw":"---\nlayout: post\ntitle: \"反击爬虫，前端工程师的脑洞可以有多大？\"\ndate: 2017-07-09 10:36\ncomments: true\ntoc: true\ntags: \n\t- 前端\n\t- 爬虫\n---\n\n<img src=\"http://epoch-night.oss-cn-hangzhou.aliyuncs.com/PostImg/FmIvXiOiFFET4oPGkVU6rdDCl87S\" width=\"400\">\n\n\n\n### 1. 前言\n\n对于一张网页，我们往往希望它是结构良好，内容清晰的，这样搜索引擎才能准确地认知它。       \n而反过来，又有一些情景，我们不希望内容能被轻易获取，比方说电商网站的交易额，教育网站的题目等。因为这些内容，往往是一个产品的生命线，必须做到有效地保护。这就是**爬虫与反爬虫**这一话题的由来。\n\n<!-- more -->\n\n### 2. 常见反爬虫策略\n\n但是世界上没有一个网站，能做到完美地反爬虫。\n\n如果页面希望能在用户面前正常展示，同时又不给爬虫机会，就必须要做到识别真人与机器人。因此工程师们做了各种尝试，这些策略大多采用于**后端**，也是目前比较常规单有效的手段，比如：\n* User-Agent + Referer检测\n* 账号及Cookie验证\n* 验证码\n* IP限制频次\n\n而爬虫是可以无限逼近于真人的，比如：\n* chrome headless或phantomjs来模拟浏览器环境\n* [tesseract](http://udn.yyuap.com/doc/ae/920457.html)识别验证码\n* 代理IP淘宝就能买到\n\n所以我们说，100%的反爬虫策略？不存在的。        \n更多的是体力活，是个难易程度的问题。\n\n不过作为前端工程师，我们可以增加一下游戏难度，设计出一些**很(sang)有(xin)意(bing)思(kuang)**的反爬虫策略。\n\n### 3. 前端与反爬虫\n\n#### 3.1 font-face拼凑式\n\n**例子：[猫眼电影](http://maoyan.com/films/342601)**\n\n猫眼电影里，对于票房数据，展示的并不是纯粹的数字。\n页面使用了font-face定义了字符集，并通过unicode去映射展示。也就是说，除去图像识别，必须同时爬取字符集，才能识别出数字。\n\n![](http://7tszky.com1.z0.glb.clouddn.com/Fr4tKHT39qEwCjjK7QlhWpHWNkvs)\n\n并且，每次刷新页面，字符集的url都是有变化的，无疑更大难度地增加了爬取成本。\n\n![](http://7tszky.com1.z0.glb.clouddn.com/FnBGGXcZgJ_PN9CbX5gVz_f5Y579)\n\n\n#### 3.2 background拼凑式\n\n**例子：[美团](http://www.meituan.com/dianying/342601?#content)**\n\n与font的策略类似，美团里用到的是background拼凑。数字其实是图片，根据不同的background偏移，显示出不同的字符。\n\n![](http://7tszky.com1.z0.glb.clouddn.com/FvAROr33mC0rpTFO46Xtl3j-8HrW)\n\n并且不同页面，图片的字符排序也是有区别的。不过理论上只需生成0-9与小数点，为何有重复字符就不是很懂。\n\n页面A：\n![](http://7tszky.com1.z0.glb.clouddn.com/Fp_3RGHisGjjKoofp-W7oOx731ry)\n页面B：\n![](http://7tszky.com1.z0.glb.clouddn.com/FiuQ2nSHzD6VoM2L_LDloXUo9ndL)\n\n\n#### 3.3 字符穿插式\n\n**例子：[微信公众号文章](https://mp.weixin.qq.com/s?__biz=MzI0MDYwNjk2OA==&mid=2247484365&idx=4&sn=291a93e8a4ce6e90d3b6ef8b98fe09c4&chksm=e919085ade6e814cc037ecf6a873f22da0e492911a4e539e6f8fdeff022806b4d248c4d54194&scene=4)**\n\n\n某些微信公众号的文章里，穿插了各种迷之字符，并且通过样式把这些字符隐藏掉。       \n这种方式虽然令人震惊…但其实没有太大的识别与过滤难度，甚至可以做得更好，不过也算是一种脑洞吧。\n![](http://7tszky.com1.z0.glb.clouddn.com/FoFF_VXDYzM0DyLDjAbOz8ATzH59)\n\n对了，我的手机流量可以找谁报销吗？\n\n\n#### 3.4 伪元素隐藏式\n\n**例子：[汽车之家](http://car.autohome.com.cn/config/series/3170.html)**\n\n汽车之家里，把关键的厂商信息，做到了伪元素的content里。        \n这也是一种思路：爬取网页，必须得解析css，需要拿到伪元素的content，这就提升了爬虫的难度。\n\n![](http://7tszky.com1.z0.glb.clouddn.com/FslsPbUtQhM2uE_bK-LZw7NHynl5)\n\n\n#### 3.5 元素定位覆盖式\n\n**例子：[去哪儿](https://flight.qunar.com/site/oneway_list.htm?searchDepartureAirport=%E5%B9%BF%E5%B7%9E&searchArrivalAirport=%E5%8C%97%E4%BA%AC&searchDepartureTime=2017-07-06&searchArrivalTime=2017-07-09&nextNDays=0&startSearch=true&fromCode=CAN&toCode=BJS&from=qunarindex&lowestPrice=null)**\n\n还有热爱数学的去哪儿，对于一个4位数字的机票价格，先用四个``i``标签渲染，再用两个``b``标签去绝对定位偏移量，覆盖故意展示错误的``i``标签，最后在视觉上形成正确的价格…\n\n![](http://7tszky.com1.z0.glb.clouddn.com/FtZdGFs-53tAYT10GS_ukosJL8CF)\n\n这说明爬虫会解析css还不行，还得会做数学题。\n\n\n#### 3.6 iframe异步加载式\n\n**例子：[网易云音乐](http://music.163.com/#/song?id=424477863)**\n\n网易云音乐页面一打开，html源码里几乎只有一个``iframe``，并且它的src是空白的：``about:blank``。接着js开始运行，把整个页面的框架异步塞到了iframe里面…\n\n![](http://7tszky.com1.z0.glb.clouddn.com/FjHp4gqXWu1YeYWVJ1vkMAgRzO-g)\n\n不过这个方式带来的难度并不大，只是在异步与iframe处理上绕了个弯（或者有其他原因，不完全是基于反爬虫考虑），无论你是用selenium还是phantom，都有API可以拿到iframe里面的content信息。\n\n\n#### 3.7 字符分割式\n\n**例子：[全网代理IP](http://www.goubanjia.com/)**\n\n在一些展示代理IP信息的页面，对于IP的保护也是大费周折。\n\n![](http://7tszky.com1.z0.glb.clouddn.com/FiY93YeoTulfbXWBxfX3nrksVQVV)\n\n他们会先把IP的数字与符号分割成dom节点，再在中间插入迷惑人的数字，如果爬虫不知道这个策略，还会以为自己成功拿到了数值；不过如果爬虫注意到，就很好解决了。\n\n\n#### 3.8 字符集替换式\n\n**例子：[去哪儿移动侧](https://m.flight.qunar.com/ncs/page/flightlist?depCity=%E5%8C%97%E4%BA%AC&arrCity=%E4%B8%8A%E6%B5%B7&goDate=2017-07-05&backDate=&sort=&airLine=&from=)**\n\n同样会欺骗爬虫的还有去哪儿的移动版。\n\n![](http://7tszky.com1.z0.glb.clouddn.com/Ft3i0NfbT8udcJ-OMIQQvdeU-LTb)\n\nhtml里明明写的3211，视觉上展示的却是1233。原来他们重新定义了字符集，3与1的顺序刚好调换得来的结果…\n\n![](http://7tszky.com1.z0.glb.clouddn.com/FoMbTu14ollkxEO0tSv7F55ZVxMq)","slug":"prevent-spiders","published":1,"updated":"2019-05-05T12:39:18.903Z","photos":[],"link":"","_id":"cjvayvwfp000ym46aadbs8236","content":"<p><img src=\"http://epoch-night.oss-cn-hangzhou.aliyuncs.com/PostImg/FmIvXiOiFFET4oPGkVU6rdDCl87S\" width=\"400\"></p>\n<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h3><p>对于一张网页，我们往往希望它是结构良好，内容清晰的，这样搜索引擎才能准确地认知它。<br>而反过来，又有一些情景，我们不希望内容能被轻易获取，比方说电商网站的交易额，教育网站的题目等。因为这些内容，往往是一个产品的生命线，必须做到有效地保护。这就是<strong>爬虫与反爬虫</strong>这一话题的由来。</p>\n<a id=\"more\"></a>\n<h3 id=\"2-常见反爬虫策略\"><a href=\"#2-常见反爬虫策略\" class=\"headerlink\" title=\"2. 常见反爬虫策略\"></a>2. 常见反爬虫策略</h3><p>但是世界上没有一个网站，能做到完美地反爬虫。</p>\n<p>如果页面希望能在用户面前正常展示，同时又不给爬虫机会，就必须要做到识别真人与机器人。因此工程师们做了各种尝试，这些策略大多采用于<strong>后端</strong>，也是目前比较常规单有效的手段，比如：</p>\n<ul>\n<li>User-Agent + Referer检测</li>\n<li>账号及Cookie验证</li>\n<li>验证码</li>\n<li>IP限制频次</li>\n</ul>\n<p>而爬虫是可以无限逼近于真人的，比如：</p>\n<ul>\n<li>chrome headless或phantomjs来模拟浏览器环境</li>\n<li><a href=\"http://udn.yyuap.com/doc/ae/920457.html\" target=\"_blank\" rel=\"noopener\">tesseract</a>识别验证码</li>\n<li>代理IP淘宝就能买到</li>\n</ul>\n<p>所以我们说，100%的反爬虫策略？不存在的。<br>更多的是体力活，是个难易程度的问题。</p>\n<p>不过作为前端工程师，我们可以增加一下游戏难度，设计出一些<strong>很(sang)有(xin)意(bing)思(kuang)</strong>的反爬虫策略。</p>\n<h3 id=\"3-前端与反爬虫\"><a href=\"#3-前端与反爬虫\" class=\"headerlink\" title=\"3. 前端与反爬虫\"></a>3. 前端与反爬虫</h3><h4 id=\"3-1-font-face拼凑式\"><a href=\"#3-1-font-face拼凑式\" class=\"headerlink\" title=\"3.1 font-face拼凑式\"></a>3.1 font-face拼凑式</h4><p><strong>例子：<a href=\"http://maoyan.com/films/342601\" target=\"_blank\" rel=\"noopener\">猫眼电影</a></strong></p>\n<p>猫眼电影里，对于票房数据，展示的并不是纯粹的数字。<br>页面使用了font-face定义了字符集，并通过unicode去映射展示。也就是说，除去图像识别，必须同时爬取字符集，才能识别出数字。</p>\n<p><img src=\"http://7tszky.com1.z0.glb.clouddn.com/Fr4tKHT39qEwCjjK7QlhWpHWNkvs\" alt></p>\n<p>并且，每次刷新页面，字符集的url都是有变化的，无疑更大难度地增加了爬取成本。</p>\n<p><img src=\"http://7tszky.com1.z0.glb.clouddn.com/FnBGGXcZgJ_PN9CbX5gVz_f5Y579\" alt></p>\n<h4 id=\"3-2-background拼凑式\"><a href=\"#3-2-background拼凑式\" class=\"headerlink\" title=\"3.2 background拼凑式\"></a>3.2 background拼凑式</h4><p><strong>例子：<a href=\"http://www.meituan.com/dianying/342601?#content\" target=\"_blank\" rel=\"noopener\">美团</a></strong></p>\n<p>与font的策略类似，美团里用到的是background拼凑。数字其实是图片，根据不同的background偏移，显示出不同的字符。</p>\n<p><img src=\"http://7tszky.com1.z0.glb.clouddn.com/FvAROr33mC0rpTFO46Xtl3j-8HrW\" alt></p>\n<p>并且不同页面，图片的字符排序也是有区别的。不过理论上只需生成0-9与小数点，为何有重复字符就不是很懂。</p>\n<p>页面A：<br><img src=\"http://7tszky.com1.z0.glb.clouddn.com/Fp_3RGHisGjjKoofp-W7oOx731ry\" alt><br>页面B：<br><img src=\"http://7tszky.com1.z0.glb.clouddn.com/FiuQ2nSHzD6VoM2L_LDloXUo9ndL\" alt></p>\n<h4 id=\"3-3-字符穿插式\"><a href=\"#3-3-字符穿插式\" class=\"headerlink\" title=\"3.3 字符穿插式\"></a>3.3 字符穿插式</h4><p><strong>例子：<a href=\"https://mp.weixin.qq.com/s?__biz=MzI0MDYwNjk2OA==&amp;mid=2247484365&amp;idx=4&amp;sn=291a93e8a4ce6e90d3b6ef8b98fe09c4&amp;chksm=e919085ade6e814cc037ecf6a873f22da0e492911a4e539e6f8fdeff022806b4d248c4d54194&amp;scene=4\" target=\"_blank\" rel=\"noopener\">微信公众号文章</a></strong></p>\n<p>某些微信公众号的文章里，穿插了各种迷之字符，并且通过样式把这些字符隐藏掉。<br>这种方式虽然令人震惊…但其实没有太大的识别与过滤难度，甚至可以做得更好，不过也算是一种脑洞吧。<br><img src=\"http://7tszky.com1.z0.glb.clouddn.com/FoFF_VXDYzM0DyLDjAbOz8ATzH59\" alt></p>\n<p>对了，我的手机流量可以找谁报销吗？</p>\n<h4 id=\"3-4-伪元素隐藏式\"><a href=\"#3-4-伪元素隐藏式\" class=\"headerlink\" title=\"3.4 伪元素隐藏式\"></a>3.4 伪元素隐藏式</h4><p><strong>例子：<a href=\"http://car.autohome.com.cn/config/series/3170.html\" target=\"_blank\" rel=\"noopener\">汽车之家</a></strong></p>\n<p>汽车之家里，把关键的厂商信息，做到了伪元素的content里。<br>这也是一种思路：爬取网页，必须得解析css，需要拿到伪元素的content，这就提升了爬虫的难度。</p>\n<p><img src=\"http://7tszky.com1.z0.glb.clouddn.com/FslsPbUtQhM2uE_bK-LZw7NHynl5\" alt></p>\n<h4 id=\"3-5-元素定位覆盖式\"><a href=\"#3-5-元素定位覆盖式\" class=\"headerlink\" title=\"3.5 元素定位覆盖式\"></a>3.5 元素定位覆盖式</h4><p><strong>例子：<a href=\"https://flight.qunar.com/site/oneway_list.htm?searchDepartureAirport=%E5%B9%BF%E5%B7%9E&amp;searchArrivalAirport=%E5%8C%97%E4%BA%AC&amp;searchDepartureTime=2017-07-06&amp;searchArrivalTime=2017-07-09&amp;nextNDays=0&amp;startSearch=true&amp;fromCode=CAN&amp;toCode=BJS&amp;from=qunarindex&amp;lowestPrice=null\" target=\"_blank\" rel=\"noopener\">去哪儿</a></strong></p>\n<p>还有热爱数学的去哪儿，对于一个4位数字的机票价格，先用四个<code>i</code>标签渲染，再用两个<code>b</code>标签去绝对定位偏移量，覆盖故意展示错误的<code>i</code>标签，最后在视觉上形成正确的价格…</p>\n<p><img src=\"http://7tszky.com1.z0.glb.clouddn.com/FtZdGFs-53tAYT10GS_ukosJL8CF\" alt></p>\n<p>这说明爬虫会解析css还不行，还得会做数学题。</p>\n<h4 id=\"3-6-iframe异步加载式\"><a href=\"#3-6-iframe异步加载式\" class=\"headerlink\" title=\"3.6 iframe异步加载式\"></a>3.6 iframe异步加载式</h4><p><strong>例子：<a href=\"http://music.163.com/#/song?id=424477863\" target=\"_blank\" rel=\"noopener\">网易云音乐</a></strong></p>\n<p>网易云音乐页面一打开，html源码里几乎只有一个<code>iframe</code>，并且它的src是空白的：<code>about:blank</code>。接着js开始运行，把整个页面的框架异步塞到了iframe里面…</p>\n<p><img src=\"http://7tszky.com1.z0.glb.clouddn.com/FjHp4gqXWu1YeYWVJ1vkMAgRzO-g\" alt></p>\n<p>不过这个方式带来的难度并不大，只是在异步与iframe处理上绕了个弯（或者有其他原因，不完全是基于反爬虫考虑），无论你是用selenium还是phantom，都有API可以拿到iframe里面的content信息。</p>\n<h4 id=\"3-7-字符分割式\"><a href=\"#3-7-字符分割式\" class=\"headerlink\" title=\"3.7 字符分割式\"></a>3.7 字符分割式</h4><p><strong>例子：<a href=\"http://www.goubanjia.com/\" target=\"_blank\" rel=\"noopener\">全网代理IP</a></strong></p>\n<p>在一些展示代理IP信息的页面，对于IP的保护也是大费周折。</p>\n<p><img src=\"http://7tszky.com1.z0.glb.clouddn.com/FiY93YeoTulfbXWBxfX3nrksVQVV\" alt></p>\n<p>他们会先把IP的数字与符号分割成dom节点，再在中间插入迷惑人的数字，如果爬虫不知道这个策略，还会以为自己成功拿到了数值；不过如果爬虫注意到，就很好解决了。</p>\n<h4 id=\"3-8-字符集替换式\"><a href=\"#3-8-字符集替换式\" class=\"headerlink\" title=\"3.8 字符集替换式\"></a>3.8 字符集替换式</h4><p><strong>例子：<a href=\"https://m.flight.qunar.com/ncs/page/flightlist?depCity=%E5%8C%97%E4%BA%AC&amp;arrCity=%E4%B8%8A%E6%B5%B7&amp;goDate=2017-07-05&amp;backDate=&amp;sort=&amp;airLine=&amp;from=\" target=\"_blank\" rel=\"noopener\">去哪儿移动侧</a></strong></p>\n<p>同样会欺骗爬虫的还有去哪儿的移动版。</p>\n<p><img src=\"http://7tszky.com1.z0.glb.clouddn.com/Ft3i0NfbT8udcJ-OMIQQvdeU-LTb\" alt></p>\n<p>html里明明写的3211，视觉上展示的却是1233。原来他们重新定义了字符集，3与1的顺序刚好调换得来的结果…</p>\n<p><img src=\"http://7tszky.com1.z0.glb.clouddn.com/FoMbTu14ollkxEO0tSv7F55ZVxMq\" alt></p>\n","site":{"data":{}},"excerpt":"<p><img src=\"http://epoch-night.oss-cn-hangzhou.aliyuncs.com/PostImg/FmIvXiOiFFET4oPGkVU6rdDCl87S\" width=\"400\"></p>\n<h3 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h3><p>对于一张网页，我们往往希望它是结构良好，内容清晰的，这样搜索引擎才能准确地认知它。<br>而反过来，又有一些情景，我们不希望内容能被轻易获取，比方说电商网站的交易额，教育网站的题目等。因为这些内容，往往是一个产品的生命线，必须做到有效地保护。这就是<strong>爬虫与反爬虫</strong>这一话题的由来。</p>","more":"<h3 id=\"2-常见反爬虫策略\"><a href=\"#2-常见反爬虫策略\" class=\"headerlink\" title=\"2. 常见反爬虫策略\"></a>2. 常见反爬虫策略</h3><p>但是世界上没有一个网站，能做到完美地反爬虫。</p>\n<p>如果页面希望能在用户面前正常展示，同时又不给爬虫机会，就必须要做到识别真人与机器人。因此工程师们做了各种尝试，这些策略大多采用于<strong>后端</strong>，也是目前比较常规单有效的手段，比如：</p>\n<ul>\n<li>User-Agent + Referer检测</li>\n<li>账号及Cookie验证</li>\n<li>验证码</li>\n<li>IP限制频次</li>\n</ul>\n<p>而爬虫是可以无限逼近于真人的，比如：</p>\n<ul>\n<li>chrome headless或phantomjs来模拟浏览器环境</li>\n<li><a href=\"http://udn.yyuap.com/doc/ae/920457.html\" target=\"_blank\" rel=\"noopener\">tesseract</a>识别验证码</li>\n<li>代理IP淘宝就能买到</li>\n</ul>\n<p>所以我们说，100%的反爬虫策略？不存在的。<br>更多的是体力活，是个难易程度的问题。</p>\n<p>不过作为前端工程师，我们可以增加一下游戏难度，设计出一些<strong>很(sang)有(xin)意(bing)思(kuang)</strong>的反爬虫策略。</p>\n<h3 id=\"3-前端与反爬虫\"><a href=\"#3-前端与反爬虫\" class=\"headerlink\" title=\"3. 前端与反爬虫\"></a>3. 前端与反爬虫</h3><h4 id=\"3-1-font-face拼凑式\"><a href=\"#3-1-font-face拼凑式\" class=\"headerlink\" title=\"3.1 font-face拼凑式\"></a>3.1 font-face拼凑式</h4><p><strong>例子：<a href=\"http://maoyan.com/films/342601\" target=\"_blank\" rel=\"noopener\">猫眼电影</a></strong></p>\n<p>猫眼电影里，对于票房数据，展示的并不是纯粹的数字。<br>页面使用了font-face定义了字符集，并通过unicode去映射展示。也就是说，除去图像识别，必须同时爬取字符集，才能识别出数字。</p>\n<p><img src=\"http://7tszky.com1.z0.glb.clouddn.com/Fr4tKHT39qEwCjjK7QlhWpHWNkvs\" alt></p>\n<p>并且，每次刷新页面，字符集的url都是有变化的，无疑更大难度地增加了爬取成本。</p>\n<p><img src=\"http://7tszky.com1.z0.glb.clouddn.com/FnBGGXcZgJ_PN9CbX5gVz_f5Y579\" alt></p>\n<h4 id=\"3-2-background拼凑式\"><a href=\"#3-2-background拼凑式\" class=\"headerlink\" title=\"3.2 background拼凑式\"></a>3.2 background拼凑式</h4><p><strong>例子：<a href=\"http://www.meituan.com/dianying/342601?#content\" target=\"_blank\" rel=\"noopener\">美团</a></strong></p>\n<p>与font的策略类似，美团里用到的是background拼凑。数字其实是图片，根据不同的background偏移，显示出不同的字符。</p>\n<p><img src=\"http://7tszky.com1.z0.glb.clouddn.com/FvAROr33mC0rpTFO46Xtl3j-8HrW\" alt></p>\n<p>并且不同页面，图片的字符排序也是有区别的。不过理论上只需生成0-9与小数点，为何有重复字符就不是很懂。</p>\n<p>页面A：<br><img src=\"http://7tszky.com1.z0.glb.clouddn.com/Fp_3RGHisGjjKoofp-W7oOx731ry\" alt><br>页面B：<br><img src=\"http://7tszky.com1.z0.glb.clouddn.com/FiuQ2nSHzD6VoM2L_LDloXUo9ndL\" alt></p>\n<h4 id=\"3-3-字符穿插式\"><a href=\"#3-3-字符穿插式\" class=\"headerlink\" title=\"3.3 字符穿插式\"></a>3.3 字符穿插式</h4><p><strong>例子：<a href=\"https://mp.weixin.qq.com/s?__biz=MzI0MDYwNjk2OA==&amp;mid=2247484365&amp;idx=4&amp;sn=291a93e8a4ce6e90d3b6ef8b98fe09c4&amp;chksm=e919085ade6e814cc037ecf6a873f22da0e492911a4e539e6f8fdeff022806b4d248c4d54194&amp;scene=4\" target=\"_blank\" rel=\"noopener\">微信公众号文章</a></strong></p>\n<p>某些微信公众号的文章里，穿插了各种迷之字符，并且通过样式把这些字符隐藏掉。<br>这种方式虽然令人震惊…但其实没有太大的识别与过滤难度，甚至可以做得更好，不过也算是一种脑洞吧。<br><img src=\"http://7tszky.com1.z0.glb.clouddn.com/FoFF_VXDYzM0DyLDjAbOz8ATzH59\" alt></p>\n<p>对了，我的手机流量可以找谁报销吗？</p>\n<h4 id=\"3-4-伪元素隐藏式\"><a href=\"#3-4-伪元素隐藏式\" class=\"headerlink\" title=\"3.4 伪元素隐藏式\"></a>3.4 伪元素隐藏式</h4><p><strong>例子：<a href=\"http://car.autohome.com.cn/config/series/3170.html\" target=\"_blank\" rel=\"noopener\">汽车之家</a></strong></p>\n<p>汽车之家里，把关键的厂商信息，做到了伪元素的content里。<br>这也是一种思路：爬取网页，必须得解析css，需要拿到伪元素的content，这就提升了爬虫的难度。</p>\n<p><img src=\"http://7tszky.com1.z0.glb.clouddn.com/FslsPbUtQhM2uE_bK-LZw7NHynl5\" alt></p>\n<h4 id=\"3-5-元素定位覆盖式\"><a href=\"#3-5-元素定位覆盖式\" class=\"headerlink\" title=\"3.5 元素定位覆盖式\"></a>3.5 元素定位覆盖式</h4><p><strong>例子：<a href=\"https://flight.qunar.com/site/oneway_list.htm?searchDepartureAirport=%E5%B9%BF%E5%B7%9E&amp;searchArrivalAirport=%E5%8C%97%E4%BA%AC&amp;searchDepartureTime=2017-07-06&amp;searchArrivalTime=2017-07-09&amp;nextNDays=0&amp;startSearch=true&amp;fromCode=CAN&amp;toCode=BJS&amp;from=qunarindex&amp;lowestPrice=null\" target=\"_blank\" rel=\"noopener\">去哪儿</a></strong></p>\n<p>还有热爱数学的去哪儿，对于一个4位数字的机票价格，先用四个<code>i</code>标签渲染，再用两个<code>b</code>标签去绝对定位偏移量，覆盖故意展示错误的<code>i</code>标签，最后在视觉上形成正确的价格…</p>\n<p><img src=\"http://7tszky.com1.z0.glb.clouddn.com/FtZdGFs-53tAYT10GS_ukosJL8CF\" alt></p>\n<p>这说明爬虫会解析css还不行，还得会做数学题。</p>\n<h4 id=\"3-6-iframe异步加载式\"><a href=\"#3-6-iframe异步加载式\" class=\"headerlink\" title=\"3.6 iframe异步加载式\"></a>3.6 iframe异步加载式</h4><p><strong>例子：<a href=\"http://music.163.com/#/song?id=424477863\" target=\"_blank\" rel=\"noopener\">网易云音乐</a></strong></p>\n<p>网易云音乐页面一打开，html源码里几乎只有一个<code>iframe</code>，并且它的src是空白的：<code>about:blank</code>。接着js开始运行，把整个页面的框架异步塞到了iframe里面…</p>\n<p><img src=\"http://7tszky.com1.z0.glb.clouddn.com/FjHp4gqXWu1YeYWVJ1vkMAgRzO-g\" alt></p>\n<p>不过这个方式带来的难度并不大，只是在异步与iframe处理上绕了个弯（或者有其他原因，不完全是基于反爬虫考虑），无论你是用selenium还是phantom，都有API可以拿到iframe里面的content信息。</p>\n<h4 id=\"3-7-字符分割式\"><a href=\"#3-7-字符分割式\" class=\"headerlink\" title=\"3.7 字符分割式\"></a>3.7 字符分割式</h4><p><strong>例子：<a href=\"http://www.goubanjia.com/\" target=\"_blank\" rel=\"noopener\">全网代理IP</a></strong></p>\n<p>在一些展示代理IP信息的页面，对于IP的保护也是大费周折。</p>\n<p><img src=\"http://7tszky.com1.z0.glb.clouddn.com/FiY93YeoTulfbXWBxfX3nrksVQVV\" alt></p>\n<p>他们会先把IP的数字与符号分割成dom节点，再在中间插入迷惑人的数字，如果爬虫不知道这个策略，还会以为自己成功拿到了数值；不过如果爬虫注意到，就很好解决了。</p>\n<h4 id=\"3-8-字符集替换式\"><a href=\"#3-8-字符集替换式\" class=\"headerlink\" title=\"3.8 字符集替换式\"></a>3.8 字符集替换式</h4><p><strong>例子：<a href=\"https://m.flight.qunar.com/ncs/page/flightlist?depCity=%E5%8C%97%E4%BA%AC&amp;arrCity=%E4%B8%8A%E6%B5%B7&amp;goDate=2017-07-05&amp;backDate=&amp;sort=&amp;airLine=&amp;from=\" target=\"_blank\" rel=\"noopener\">去哪儿移动侧</a></strong></p>\n<p>同样会欺骗爬虫的还有去哪儿的移动版。</p>\n<p><img src=\"http://7tszky.com1.z0.glb.clouddn.com/Ft3i0NfbT8udcJ-OMIQQvdeU-LTb\" alt></p>\n<p>html里明明写的3211，视觉上展示的却是1233。原来他们重新定义了字符集，3与1的顺序刚好调换得来的结果…</p>\n<p><img src=\"http://7tszky.com1.z0.glb.clouddn.com/FoMbTu14ollkxEO0tSv7F55ZVxMq\" alt></p>"},{"layout":"post","title":"BoolmFilter算法解析","date":"2017-05-23T08:00:00.000Z","author":"Gubaidan","header-img":"/Header/lake.jpg","cdn":"header-on","_content":"# 介绍\n\nBloomFilter（布隆过滤器）是一种可以高效地判断元素是否在某个集合中的算法。\n\n在很多日常场景中，都大量存在着布隆过滤器的应用。例如：检查单词是否拼写正确、网络爬虫的URL去重、黑名单检验，微博中昵称不能重复的检测。Google Chrome浏览器使用BloomFilter来判断一个网站是否为恶意网站。\n\n对于以上场景，可能很多人会说，用HashSet甚至简单的链表、数组做存储，然后判断是否存在不就可以了吗？\n\n当然，对于少量数据来说，HashSet是很好的选择。但是对于海量数据来说，BloomFilter相比于其他数据结构在空间效率和时间效率方面都有着明显的优势。\n\n但是，布隆过滤器具有一定的误判率，有可能会将本不存在的元素判定为存在。因此，对于那些需要“零错误”的应用场景，布隆过滤器将不太适用。具体的原因将会在第二部分中介绍。  \n\n在本文的第二部分，本文将会介绍BloomFilter的基本算法思想；第三部分将会基于Google开源库Guava来讲解BloomFilter的具体实现；在第四部分中，将会介绍一些开源的BloomFilter的扩展，以解决目前BloomFilter的不足。\n\n# 算法讲述\n\n布隆过滤器是基于Hash来实现的，在学习BloomFilter之前，也需要对Hash的原理有基本的了解。个人认为，BloomFilter的总体思想实际上和bitmap很像，但是比bitmap更节省空间，误判率也更低。\n\nBloomFilter的整体思想并不复杂，主要是使用k个Hash函数将元素映射到位向量的k个位置上面，并将这k个位置全部置为1。当查找某元素是否存在时，查找该元素所对应的k位是否全部为1即可说明该元素是否存在。\n\n# 算法流程\n\n**BloomFilter的整体算法流程可总结为如下步骤：**\n\n\n\n1. BloomFilter初始化为m位长度的位向量，每一位均初始化为![bf1](http://epoch-night.oss-cn-hangzhou.aliyuncs.com/PostImg/bf1.jpg)\n\n2. 使用k个相互独立的Hash函数，每个Hash函数将元素映射到{1..m}的范围内，并将对应的位置为1。![bf2](http://epoch-night.oss-cn-hangzhou.aliyuncs.com/PostImg/bf2.jpg)如上图所示，元素x分别被三个Hash函数映射到了三个位置8、1、14，并将这三个位置从0变为1。\n\n3. 若检查一个元素y是否存在，首先第一步使用k个Hash函数将元素y映射到k位。分别检测每一位是否为0。若某一位为0，则元素y一定不存在，若全部为1，则有可能存在。\n\n**空间复杂度**\n\nBloomFilter 使用位向量来表示元素，而不存储本身，这样极大压缩了元素的存储空间。其空间复杂度为O(m)，m是位向量的长度。而m与插入总数量n的关系如公式（1）所示：\n\n$$\n\\begin{equation} \\label{euler}  m=-{\\frac {n\\ln p}{(\\ln 2)^{2}}}   \\end{equation}\n$$\n我们可以利用这个公式来算一下需要抓取100万个URL时BloomFilter所占据的空间。\n\n假设要求误判率为1%，因此该公式可转化为m=9.6∗nm=9.6∗n。故此时BloomFilter位向量的大小为100w∗9.6=960wbit100w∗9.6=960wbit，约1.1M内存空间。\n只需要1.1M的内存空间，就可满足100万个url的去重需求，这个空间复杂度之低不可谓不惊人。\n实际上，哪怕是1亿个URL，也仅需100M左右的内存空间即可满足BloomFilter的空间需求，这对于绝大部分爬虫的体量来说，是完全可行的。\n\n**时间复杂度**\n时间复杂度方面 BloomFilter的时间复杂度仅与Hash函数的个数k有关，即O(k)\n\n# 误判率\n\n为什么说，在查找元素时，即使某个元素所映射的k位全部位1，依然无法确定它一定存在？\n\n这是因为当插入的元素很多的情况下，某个元素即使之前不存在，但是它所映射的k位已经被之前其他的元素置为1了，这样就会出现误判，BloomFilter会认为它已经存在了。但是这个概率是非常小的。根据维基百科的推导公式来说，误判率的大小p满足以下公式（2）\n\n$$\n\\begin{equation}   \\ln p = -{\\frac {m}{n}}\\left(\\ln 2\\right)^{2} \\label{eq:p} \\end{equation}\n$$\n其中m为位向量的长度，n为要插入元素的总数。当误判率为1%时,mn=9.6mn=9.6即每个元素仅需要9.6个字节存储即可\n\nHash函数的个数k，与误判率大小p的关系为公式（3） 所示\n\n$$\n\\begin{equation}   k = {-{\\ln p} \\over {\\ln 2}} \\label{eq:k1} \\end{equation}\n$$\n当误判率大小为0.1时，k为3。当误判率大小为0.01时，k为7\n\n与位向量的长度m和插入元素的总数n的关系为公式（4）\n\n$$\n\\begin{equation}   k = {\\frac {m}{n}}\\ln 2 \\label{eq:k2} \\end{equation}\n$$\n\n\n# 缺点\n\nBloomFilter 由于并不存储元素，而是用位的01来表示元素是否存在，并且很有可能一个位时被多个元素同时使用。所以无法通过将某元素对应的位置为0来删除元素。\n\n幸运的是，目前学术界和工业界都有很多方法扩展已解决以上问题。具体可以参考本文第三部分 **BloomFilter的优化和扩展**\n\n# Guava’s BloomFilter源码剖析\n\nGuava引入了一个叫做`Funnel`的类，Funnel类定义了如何把一个具体的对象类型分解为原生字段值，从而将值分解为Byte以供后面BloomFilter进行hash运算。通过使用这个类，我们可以自己定义一个属于自己类的Funnel。如下代码\n\n```java\npublic enum StringFunnel implements Funnel<String> {    \n    INSTANCE;   \n    @Override    \n    public void funnel(String from, PrimitiveSink into) {        \t\t\n    \tinto.putString(from,Charset.defaultCharset());    \n    }\n}\n```\n\n\n\n此外，Guava预定义了一些原生类型的Funnel，如String、Long、Integer。具体代码可以在[这里看到](https://github.com/google/guava/blob/master/guava/src/com/google/common/hash/Funnels.java)。当我们的BloomFilter存储的是这些原生类型时，不用再额外自行写Funnel，直接使用Guava预定义的这些即可。\n\n以下是整个代码调用的流程\n                                                               \n\n```java\npublic class BloomFilterSamle {                                                                                             \npublic static void main(String[] args) {    \n\t// 创建一个BloomFilter，其预计插入的个数为10，误判率大约为0.01\n    BloomFilter<String> bloomFilter = BloomFilter.create(StringFunnel.INSTANCE, 10, 0.01);                              \n    // 查询www.google.com是否存在                                                                                                                   \n    System.out.println(bloomFilter.mightContain(\"www.google.com\"));\n     // 将www.google.com对象放入BloomFilter中\n    bloomFilter.put(\"www.google.com\");  \n    // 再次查询www.google.com是否存在\n    System.out.println(bloomFilter.mightContain(\"www.google.com\"));                                                     \n\t}    \n} \n```\n\n\n\n# 源码解读\n\n在例子中，我们通过调用`BloomFilter.create`工厂方法来生成一个BloomFilter\n\n```java\n<T> BloomFilter<T> create(Funnel<? super T> funnel, \n                          long expectedInsertions,  //预期会插入多少元素\n                          double fpp, //自定义误判率\n                          Strategy strategy //Hash策略 \n                          ) {  \n    if (expectedInsertions == 0) {\n      expectedInsertions = 1;\n    }\n    ...\n    //根据插入的数量和误判率来得出位向量应有的长度,这里使用的算法就是公式 2\n    long numBits = optimalNumOfBits(expectedInsertions, fpp);\n    //根据插入的数量和位向量的长度来得出应该用多少个Hash函数，这里使用的算法是公式 4\n    int numHashFunctions = optimalNumOfHashFunctions(expectedInsertions, numBits);\n    return new BloomFilter<T>(new BitArray(numBits), numHashFunctions, funnel, strategy);\n}\n```\n\n\n整个创建流程非常清晰，如果看懂了本文的算法描述部分，应该不难理解该段代码。整个初始化流程的目的主要有两个：根据参数计算出位向量的长度以及Hash函数的个数\n\n* 根据预期插入的数量expectedInsertions和自定义的误判率fpp来得到位向量的长度numBits，其中optimalNumOfBits的实现如下\n\n    ```java\n    // 根据插入的数量和误判率来得出位向量应有的长度\n    static long optimalNumOfBits(long n, double p) {\n        if (p == 0) {\n          p = Double.MIN_VALUE;\n        }\n    \treturn (long) (-n * Math.log(p) / (Math.log(2) * Math.log(2)));\n    }\n    ```\n\n    可以很明显看出，optimalNumOfBits的源码，其实就是对公式(1)的实现\n\n* 根据插入的数量expectedInsertions和位向量的长度numBits来得出应该用多少个Hash函数，其中optimalNumOfHashFunctions的实现如下\n\n     ```java\n     static int optimalNumOfHashFunctions(long n, long m) {\n         // (m / n) * log(2), but avoid truncation due to division!\n         return Math.max(1, (int) Math.round((double) m / n * Math.log(2)));\n       }\n     ```\n\n     同样，optimalNumOfHashFunctions也对应了我们算法中公式(4) \n\n* 根据numBits生成BitArray\n\n     BitArray是Guava中位向量的表示，具体的实现细节\n# 位向量的表示\n\n```java\n static final class BitArray {\n    final long[] data;\n    long bitCount;\n\n    BitArray(long bits) {\n      //对于长度为m的位向量来说，对应的long数组的长度应为m/64向上取整。\n      this(new long[Ints.checkedCast(LongMath.divide(bits, 64, RoundingMode.CEILING))]);\n    }\n\n    // Used by serialization\n    BitArray(long[] data) {\n      checkArgument(data.length > 0, \"data length is zero!\");\n      this.data = data;\n      long bitCount = 0;\n      for (long value : data) {\n        bitCount += Long.bitCount(value);\n      }\n      this.bitCount = bitCount;\n    }\n\n    /** Returns true if the bit changed value. */\n    boolean set(long index) {\n      if (!get(index)) {\n        data[(int) (index >>> 6)] |= (1L << index);\n        bitCount++;\n        return true;\n      }\n      return false;\n    }\n\n    boolean get(long index) {\n      return (data[(int) (index >>> 6)] & (1L << index)) != 0;\n    }\n\n    /** Number of bits */\n    long bitSize() {\n      return (long) data.length * Long.SIZE;\n    }\n\n    /** Number of set bits (1s) */\n    long bitCount() {\n      return bitCount;\n    }\n\n    BitArray copy() {\n      return new BitArray(data.clone());\n    }\n\n    /** Combines the two BitArrays using bitwise OR. */\n    void putAll(BitArray array) {\n      checkArgument(\n          data.length == array.data.length,\n          \"BitArrays must be of equal length (%s != %s)\",\n          data.length,\n          array.data.length);\n      bitCount = 0;\n      for (int i = 0; i < data.length; i++) {\n        data[i] |= array.data[i];\n        bitCount += Long.bitCount(data[i]);\n      }\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (o instanceof BitArray) {\n        BitArray bitArray = (BitArray) o;\n        return Arrays.equals(data, bitArray.data);\n      }\n      return false;\n    }\n\n    @Override\n    public int hashCode() {\n      return Arrays.hashCode(data);\n    }\n  }\n```\n\n在BitArray中，使用long数组来表示位向量，一个数组元素对应位向量的64位，所以对于长度为m的位向量来说，对应的long数组的长度应为m/64向上取整。\n\n即\n\n```java\n    new long[Ints.checkedCast(LongMath.divide(bits, 64, RoundingMode.CEILING))]\n```\n\n在BloomFilter算法讲解部分，我们可以看到，对于位向量的常用操作主要有两个，将位向量某一位置为1以及查看位向量某一位是否为1。分别对应源码中得set操作和get操作 本文只讲下get方法的源码部分，set方法与get方法类似，不再累述。\n\nget方法大致可以分为两部分\n\n* data[(int) (index >>> 6)] 定位到元素\n\n  上面讲到long数组的每一个元素都包含位向量其中的64位，如果想要找出某个位的bit，那么首先第一步就是定位到该bit所在的元素编号。我们一般的做法是`index/64`。 而源码中使用了`index >>> 6`,逻辑右移6位，$2^6 = 64$,其效果与除以64相同。采用位运算的速度比普通的除法要快很多。\n\n* … & (1L << index) 获取位的状态\n\n  源码中直接将要查看的bit以及同一数组元素块的64位bits一起取出，将1L左移index位后求且运算，最终即可得出该位的值。\n\n# BloomFilter的优化和扩展\n\n上文提到布隆过滤器无法支持元素的删除操作,Counting BloomFilter通过存储位元素每一位的置为1的数量，使得布隆过滤器可以支持删除操作。 但是这样会数倍地增加布隆过滤器的存储空间。\n\n\n\n\n\n# 参考\n\n> [维基百科](<https://en.wikipedia.org/wiki/Bloom_filter>)\n\n> [Dalhousie University](https://www.cs.dal.ca/research/techreports/cs-2002-10)\n\n> [Guava笔记](http://leadtoit.iteye.com/blog/1961751)\n\n> [Counting Bloom Filter](https://blog.csdn.net/jiaomeng/article/details/1498283)\n\n> [http://ifeve.com/google-guava-hashing/](http://ifeve.com/google-guava-hashing/)\n\n\n\n\n\n","source":"_posts/2017-05-31-boolmFilter.markdown","raw":"---\nlayout: post\ntitle: \"BoolmFilter算法解析\"\ndate: 2017-05-23 16:00\nauthor: \"Gubaidan\"\nheader-img: \"/Header/lake.jpg\"\ncdn: 'header-on'\ntags:\n\t- 算法\n---\n# 介绍\n\nBloomFilter（布隆过滤器）是一种可以高效地判断元素是否在某个集合中的算法。\n\n在很多日常场景中，都大量存在着布隆过滤器的应用。例如：检查单词是否拼写正确、网络爬虫的URL去重、黑名单检验，微博中昵称不能重复的检测。Google Chrome浏览器使用BloomFilter来判断一个网站是否为恶意网站。\n\n对于以上场景，可能很多人会说，用HashSet甚至简单的链表、数组做存储，然后判断是否存在不就可以了吗？\n\n当然，对于少量数据来说，HashSet是很好的选择。但是对于海量数据来说，BloomFilter相比于其他数据结构在空间效率和时间效率方面都有着明显的优势。\n\n但是，布隆过滤器具有一定的误判率，有可能会将本不存在的元素判定为存在。因此，对于那些需要“零错误”的应用场景，布隆过滤器将不太适用。具体的原因将会在第二部分中介绍。  \n\n在本文的第二部分，本文将会介绍BloomFilter的基本算法思想；第三部分将会基于Google开源库Guava来讲解BloomFilter的具体实现；在第四部分中，将会介绍一些开源的BloomFilter的扩展，以解决目前BloomFilter的不足。\n\n# 算法讲述\n\n布隆过滤器是基于Hash来实现的，在学习BloomFilter之前，也需要对Hash的原理有基本的了解。个人认为，BloomFilter的总体思想实际上和bitmap很像，但是比bitmap更节省空间，误判率也更低。\n\nBloomFilter的整体思想并不复杂，主要是使用k个Hash函数将元素映射到位向量的k个位置上面，并将这k个位置全部置为1。当查找某元素是否存在时，查找该元素所对应的k位是否全部为1即可说明该元素是否存在。\n\n# 算法流程\n\n**BloomFilter的整体算法流程可总结为如下步骤：**\n\n\n\n1. BloomFilter初始化为m位长度的位向量，每一位均初始化为![bf1](http://epoch-night.oss-cn-hangzhou.aliyuncs.com/PostImg/bf1.jpg)\n\n2. 使用k个相互独立的Hash函数，每个Hash函数将元素映射到{1..m}的范围内，并将对应的位置为1。![bf2](http://epoch-night.oss-cn-hangzhou.aliyuncs.com/PostImg/bf2.jpg)如上图所示，元素x分别被三个Hash函数映射到了三个位置8、1、14，并将这三个位置从0变为1。\n\n3. 若检查一个元素y是否存在，首先第一步使用k个Hash函数将元素y映射到k位。分别检测每一位是否为0。若某一位为0，则元素y一定不存在，若全部为1，则有可能存在。\n\n**空间复杂度**\n\nBloomFilter 使用位向量来表示元素，而不存储本身，这样极大压缩了元素的存储空间。其空间复杂度为O(m)，m是位向量的长度。而m与插入总数量n的关系如公式（1）所示：\n\n$$\n\\begin{equation} \\label{euler}  m=-{\\frac {n\\ln p}{(\\ln 2)^{2}}}   \\end{equation}\n$$\n我们可以利用这个公式来算一下需要抓取100万个URL时BloomFilter所占据的空间。\n\n假设要求误判率为1%，因此该公式可转化为m=9.6∗nm=9.6∗n。故此时BloomFilter位向量的大小为100w∗9.6=960wbit100w∗9.6=960wbit，约1.1M内存空间。\n只需要1.1M的内存空间，就可满足100万个url的去重需求，这个空间复杂度之低不可谓不惊人。\n实际上，哪怕是1亿个URL，也仅需100M左右的内存空间即可满足BloomFilter的空间需求，这对于绝大部分爬虫的体量来说，是完全可行的。\n\n**时间复杂度**\n时间复杂度方面 BloomFilter的时间复杂度仅与Hash函数的个数k有关，即O(k)\n\n# 误判率\n\n为什么说，在查找元素时，即使某个元素所映射的k位全部位1，依然无法确定它一定存在？\n\n这是因为当插入的元素很多的情况下，某个元素即使之前不存在，但是它所映射的k位已经被之前其他的元素置为1了，这样就会出现误判，BloomFilter会认为它已经存在了。但是这个概率是非常小的。根据维基百科的推导公式来说，误判率的大小p满足以下公式（2）\n\n$$\n\\begin{equation}   \\ln p = -{\\frac {m}{n}}\\left(\\ln 2\\right)^{2} \\label{eq:p} \\end{equation}\n$$\n其中m为位向量的长度，n为要插入元素的总数。当误判率为1%时,mn=9.6mn=9.6即每个元素仅需要9.6个字节存储即可\n\nHash函数的个数k，与误判率大小p的关系为公式（3） 所示\n\n$$\n\\begin{equation}   k = {-{\\ln p} \\over {\\ln 2}} \\label{eq:k1} \\end{equation}\n$$\n当误判率大小为0.1时，k为3。当误判率大小为0.01时，k为7\n\n与位向量的长度m和插入元素的总数n的关系为公式（4）\n\n$$\n\\begin{equation}   k = {\\frac {m}{n}}\\ln 2 \\label{eq:k2} \\end{equation}\n$$\n\n\n# 缺点\n\nBloomFilter 由于并不存储元素，而是用位的01来表示元素是否存在，并且很有可能一个位时被多个元素同时使用。所以无法通过将某元素对应的位置为0来删除元素。\n\n幸运的是，目前学术界和工业界都有很多方法扩展已解决以上问题。具体可以参考本文第三部分 **BloomFilter的优化和扩展**\n\n# Guava’s BloomFilter源码剖析\n\nGuava引入了一个叫做`Funnel`的类，Funnel类定义了如何把一个具体的对象类型分解为原生字段值，从而将值分解为Byte以供后面BloomFilter进行hash运算。通过使用这个类，我们可以自己定义一个属于自己类的Funnel。如下代码\n\n```java\npublic enum StringFunnel implements Funnel<String> {    \n    INSTANCE;   \n    @Override    \n    public void funnel(String from, PrimitiveSink into) {        \t\t\n    \tinto.putString(from,Charset.defaultCharset());    \n    }\n}\n```\n\n\n\n此外，Guava预定义了一些原生类型的Funnel，如String、Long、Integer。具体代码可以在[这里看到](https://github.com/google/guava/blob/master/guava/src/com/google/common/hash/Funnels.java)。当我们的BloomFilter存储的是这些原生类型时，不用再额外自行写Funnel，直接使用Guava预定义的这些即可。\n\n以下是整个代码调用的流程\n                                                               \n\n```java\npublic class BloomFilterSamle {                                                                                             \npublic static void main(String[] args) {    \n\t// 创建一个BloomFilter，其预计插入的个数为10，误判率大约为0.01\n    BloomFilter<String> bloomFilter = BloomFilter.create(StringFunnel.INSTANCE, 10, 0.01);                              \n    // 查询www.google.com是否存在                                                                                                                   \n    System.out.println(bloomFilter.mightContain(\"www.google.com\"));\n     // 将www.google.com对象放入BloomFilter中\n    bloomFilter.put(\"www.google.com\");  \n    // 再次查询www.google.com是否存在\n    System.out.println(bloomFilter.mightContain(\"www.google.com\"));                                                     \n\t}    \n} \n```\n\n\n\n# 源码解读\n\n在例子中，我们通过调用`BloomFilter.create`工厂方法来生成一个BloomFilter\n\n```java\n<T> BloomFilter<T> create(Funnel<? super T> funnel, \n                          long expectedInsertions,  //预期会插入多少元素\n                          double fpp, //自定义误判率\n                          Strategy strategy //Hash策略 \n                          ) {  \n    if (expectedInsertions == 0) {\n      expectedInsertions = 1;\n    }\n    ...\n    //根据插入的数量和误判率来得出位向量应有的长度,这里使用的算法就是公式 2\n    long numBits = optimalNumOfBits(expectedInsertions, fpp);\n    //根据插入的数量和位向量的长度来得出应该用多少个Hash函数，这里使用的算法是公式 4\n    int numHashFunctions = optimalNumOfHashFunctions(expectedInsertions, numBits);\n    return new BloomFilter<T>(new BitArray(numBits), numHashFunctions, funnel, strategy);\n}\n```\n\n\n整个创建流程非常清晰，如果看懂了本文的算法描述部分，应该不难理解该段代码。整个初始化流程的目的主要有两个：根据参数计算出位向量的长度以及Hash函数的个数\n\n* 根据预期插入的数量expectedInsertions和自定义的误判率fpp来得到位向量的长度numBits，其中optimalNumOfBits的实现如下\n\n    ```java\n    // 根据插入的数量和误判率来得出位向量应有的长度\n    static long optimalNumOfBits(long n, double p) {\n        if (p == 0) {\n          p = Double.MIN_VALUE;\n        }\n    \treturn (long) (-n * Math.log(p) / (Math.log(2) * Math.log(2)));\n    }\n    ```\n\n    可以很明显看出，optimalNumOfBits的源码，其实就是对公式(1)的实现\n\n* 根据插入的数量expectedInsertions和位向量的长度numBits来得出应该用多少个Hash函数，其中optimalNumOfHashFunctions的实现如下\n\n     ```java\n     static int optimalNumOfHashFunctions(long n, long m) {\n         // (m / n) * log(2), but avoid truncation due to division!\n         return Math.max(1, (int) Math.round((double) m / n * Math.log(2)));\n       }\n     ```\n\n     同样，optimalNumOfHashFunctions也对应了我们算法中公式(4) \n\n* 根据numBits生成BitArray\n\n     BitArray是Guava中位向量的表示，具体的实现细节\n# 位向量的表示\n\n```java\n static final class BitArray {\n    final long[] data;\n    long bitCount;\n\n    BitArray(long bits) {\n      //对于长度为m的位向量来说，对应的long数组的长度应为m/64向上取整。\n      this(new long[Ints.checkedCast(LongMath.divide(bits, 64, RoundingMode.CEILING))]);\n    }\n\n    // Used by serialization\n    BitArray(long[] data) {\n      checkArgument(data.length > 0, \"data length is zero!\");\n      this.data = data;\n      long bitCount = 0;\n      for (long value : data) {\n        bitCount += Long.bitCount(value);\n      }\n      this.bitCount = bitCount;\n    }\n\n    /** Returns true if the bit changed value. */\n    boolean set(long index) {\n      if (!get(index)) {\n        data[(int) (index >>> 6)] |= (1L << index);\n        bitCount++;\n        return true;\n      }\n      return false;\n    }\n\n    boolean get(long index) {\n      return (data[(int) (index >>> 6)] & (1L << index)) != 0;\n    }\n\n    /** Number of bits */\n    long bitSize() {\n      return (long) data.length * Long.SIZE;\n    }\n\n    /** Number of set bits (1s) */\n    long bitCount() {\n      return bitCount;\n    }\n\n    BitArray copy() {\n      return new BitArray(data.clone());\n    }\n\n    /** Combines the two BitArrays using bitwise OR. */\n    void putAll(BitArray array) {\n      checkArgument(\n          data.length == array.data.length,\n          \"BitArrays must be of equal length (%s != %s)\",\n          data.length,\n          array.data.length);\n      bitCount = 0;\n      for (int i = 0; i < data.length; i++) {\n        data[i] |= array.data[i];\n        bitCount += Long.bitCount(data[i]);\n      }\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (o instanceof BitArray) {\n        BitArray bitArray = (BitArray) o;\n        return Arrays.equals(data, bitArray.data);\n      }\n      return false;\n    }\n\n    @Override\n    public int hashCode() {\n      return Arrays.hashCode(data);\n    }\n  }\n```\n\n在BitArray中，使用long数组来表示位向量，一个数组元素对应位向量的64位，所以对于长度为m的位向量来说，对应的long数组的长度应为m/64向上取整。\n\n即\n\n```java\n    new long[Ints.checkedCast(LongMath.divide(bits, 64, RoundingMode.CEILING))]\n```\n\n在BloomFilter算法讲解部分，我们可以看到，对于位向量的常用操作主要有两个，将位向量某一位置为1以及查看位向量某一位是否为1。分别对应源码中得set操作和get操作 本文只讲下get方法的源码部分，set方法与get方法类似，不再累述。\n\nget方法大致可以分为两部分\n\n* data[(int) (index >>> 6)] 定位到元素\n\n  上面讲到long数组的每一个元素都包含位向量其中的64位，如果想要找出某个位的bit，那么首先第一步就是定位到该bit所在的元素编号。我们一般的做法是`index/64`。 而源码中使用了`index >>> 6`,逻辑右移6位，$2^6 = 64$,其效果与除以64相同。采用位运算的速度比普通的除法要快很多。\n\n* … & (1L << index) 获取位的状态\n\n  源码中直接将要查看的bit以及同一数组元素块的64位bits一起取出，将1L左移index位后求且运算，最终即可得出该位的值。\n\n# BloomFilter的优化和扩展\n\n上文提到布隆过滤器无法支持元素的删除操作,Counting BloomFilter通过存储位元素每一位的置为1的数量，使得布隆过滤器可以支持删除操作。 但是这样会数倍地增加布隆过滤器的存储空间。\n\n\n\n\n\n# 参考\n\n> [维基百科](<https://en.wikipedia.org/wiki/Bloom_filter>)\n\n> [Dalhousie University](https://www.cs.dal.ca/research/techreports/cs-2002-10)\n\n> [Guava笔记](http://leadtoit.iteye.com/blog/1961751)\n\n> [Counting Bloom Filter](https://blog.csdn.net/jiaomeng/article/details/1498283)\n\n> [http://ifeve.com/google-guava-hashing/](http://ifeve.com/google-guava-hashing/)\n\n\n\n\n\n","slug":"2017-05-31-boolmFilter","published":1,"updated":"2019-05-05T12:26:30.483Z","comments":1,"photos":[],"link":"","_id":"cjvayvwg6001rm46akdb8jx4c","content":"<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><p>BloomFilter（布隆过滤器）是一种可以高效地判断元素是否在某个集合中的算法。</p>\n<p>在很多日常场景中，都大量存在着布隆过滤器的应用。例如：检查单词是否拼写正确、网络爬虫的URL去重、黑名单检验，微博中昵称不能重复的检测。Google Chrome浏览器使用BloomFilter来判断一个网站是否为恶意网站。</p>\n<p>对于以上场景，可能很多人会说，用HashSet甚至简单的链表、数组做存储，然后判断是否存在不就可以了吗？</p>\n<p>当然，对于少量数据来说，HashSet是很好的选择。但是对于海量数据来说，BloomFilter相比于其他数据结构在空间效率和时间效率方面都有着明显的优势。</p>\n<p>但是，布隆过滤器具有一定的误判率，有可能会将本不存在的元素判定为存在。因此，对于那些需要“零错误”的应用场景，布隆过滤器将不太适用。具体的原因将会在第二部分中介绍。  </p>\n<p>在本文的第二部分，本文将会介绍BloomFilter的基本算法思想；第三部分将会基于Google开源库Guava来讲解BloomFilter的具体实现；在第四部分中，将会介绍一些开源的BloomFilter的扩展，以解决目前BloomFilter的不足。</p>\n<h1 id=\"算法讲述\"><a href=\"#算法讲述\" class=\"headerlink\" title=\"算法讲述\"></a>算法讲述</h1><p>布隆过滤器是基于Hash来实现的，在学习BloomFilter之前，也需要对Hash的原理有基本的了解。个人认为，BloomFilter的总体思想实际上和bitmap很像，但是比bitmap更节省空间，误判率也更低。</p>\n<p>BloomFilter的整体思想并不复杂，主要是使用k个Hash函数将元素映射到位向量的k个位置上面，并将这k个位置全部置为1。当查找某元素是否存在时，查找该元素所对应的k位是否全部为1即可说明该元素是否存在。</p>\n<h1 id=\"算法流程\"><a href=\"#算法流程\" class=\"headerlink\" title=\"算法流程\"></a>算法流程</h1><p><strong>BloomFilter的整体算法流程可总结为如下步骤：</strong></p>\n<ol>\n<li><p>BloomFilter初始化为m位长度的位向量，每一位均初始化为<img src=\"http://epoch-night.oss-cn-hangzhou.aliyuncs.com/PostImg/bf1.jpg\" alt=\"bf1\"></p>\n</li>\n<li><p>使用k个相互独立的Hash函数，每个Hash函数将元素映射到{1..m}的范围内，并将对应的位置为1。<img src=\"http://epoch-night.oss-cn-hangzhou.aliyuncs.com/PostImg/bf2.jpg\" alt=\"bf2\">如上图所示，元素x分别被三个Hash函数映射到了三个位置8、1、14，并将这三个位置从0变为1。</p>\n</li>\n<li><p>若检查一个元素y是否存在，首先第一步使用k个Hash函数将元素y映射到k位。分别检测每一位是否为0。若某一位为0，则元素y一定不存在，若全部为1，则有可能存在。</p>\n</li>\n</ol>\n<p><strong>空间复杂度</strong></p>\n<p>BloomFilter 使用位向量来表示元素，而不存储本身，这样极大压缩了元素的存储空间。其空间复杂度为O(m)，m是位向量的长度。而m与插入总数量n的关系如公式（1）所示：</p>\n<p>$$<br>\\begin{equation} \\label{euler}  m=-{\\frac {n\\ln p}{(\\ln 2)^{2}}}   \\end{equation}<br>$$<br>我们可以利用这个公式来算一下需要抓取100万个URL时BloomFilter所占据的空间。</p>\n<p>假设要求误判率为1%，因此该公式可转化为m=9.6∗nm=9.6∗n。故此时BloomFilter位向量的大小为100w∗9.6=960wbit100w∗9.6=960wbit，约1.1M内存空间。<br>只需要1.1M的内存空间，就可满足100万个url的去重需求，这个空间复杂度之低不可谓不惊人。<br>实际上，哪怕是1亿个URL，也仅需100M左右的内存空间即可满足BloomFilter的空间需求，这对于绝大部分爬虫的体量来说，是完全可行的。</p>\n<p><strong>时间复杂度</strong><br>时间复杂度方面 BloomFilter的时间复杂度仅与Hash函数的个数k有关，即O(k)</p>\n<h1 id=\"误判率\"><a href=\"#误判率\" class=\"headerlink\" title=\"误判率\"></a>误判率</h1><p>为什么说，在查找元素时，即使某个元素所映射的k位全部位1，依然无法确定它一定存在？</p>\n<p>这是因为当插入的元素很多的情况下，某个元素即使之前不存在，但是它所映射的k位已经被之前其他的元素置为1了，这样就会出现误判，BloomFilter会认为它已经存在了。但是这个概率是非常小的。根据维基百科的推导公式来说，误判率的大小p满足以下公式（2）</p>\n<p>$$<br>\\begin{equation}   \\ln p = -{\\frac {m}{n}}\\left(\\ln 2\\right)^{2} \\label{eq:p} \\end{equation}<br>$$<br>其中m为位向量的长度，n为要插入元素的总数。当误判率为1%时,mn=9.6mn=9.6即每个元素仅需要9.6个字节存储即可</p>\n<p>Hash函数的个数k，与误判率大小p的关系为公式（3） 所示</p>\n<p>$$<br>\\begin{equation}   k = {-{\\ln p} \\over {\\ln 2}} \\label{eq:k1} \\end{equation}<br>$$<br>当误判率大小为0.1时，k为3。当误判率大小为0.01时，k为7</p>\n<p>与位向量的长度m和插入元素的总数n的关系为公式（4）</p>\n<p>$$<br>\\begin{equation}   k = {\\frac {m}{n}}\\ln 2 \\label{eq:k2} \\end{equation}<br>$$</p>\n<h1 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h1><p>BloomFilter 由于并不存储元素，而是用位的01来表示元素是否存在，并且很有可能一个位时被多个元素同时使用。所以无法通过将某元素对应的位置为0来删除元素。</p>\n<p>幸运的是，目前学术界和工业界都有很多方法扩展已解决以上问题。具体可以参考本文第三部分 <strong>BloomFilter的优化和扩展</strong></p>\n<h1 id=\"Guava’s-BloomFilter源码剖析\"><a href=\"#Guava’s-BloomFilter源码剖析\" class=\"headerlink\" title=\"Guava’s BloomFilter源码剖析\"></a>Guava’s BloomFilter源码剖析</h1><p>Guava引入了一个叫做<code>Funnel</code>的类，Funnel类定义了如何把一个具体的对象类型分解为原生字段值，从而将值分解为Byte以供后面BloomFilter进行hash运算。通过使用这个类，我们可以自己定义一个属于自己类的Funnel。如下代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> StringFunnel implements Funnel&lt;String&gt; &#123;    </span><br><span class=\"line\">    INSTANCE;   </span><br><span class=\"line\">    <span class=\"meta\">@Override</span>    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">funnel</span><span class=\"params\">(String from, PrimitiveSink into)</span> </span>&#123;        \t\t</span><br><span class=\"line\">    \tinto.putString(from,Charset.defaultCharset());    </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此外，Guava预定义了一些原生类型的Funnel，如String、Long、Integer。具体代码可以在<a href=\"https://github.com/google/guava/blob/master/guava/src/com/google/common/hash/Funnels.java\" target=\"_blank\" rel=\"noopener\">这里看到</a>。当我们的BloomFilter存储的是这些原生类型时，不用再额外自行写Funnel，直接使用Guava预定义的这些即可。</p>\n<p>以下是整个代码调用的流程</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BloomFilterSamle</span> </span>&#123;                                                                                             </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;    </span><br><span class=\"line\">\t<span class=\"comment\">// 创建一个BloomFilter，其预计插入的个数为10，误判率大约为0.01</span></span><br><span class=\"line\">    BloomFilter&lt;String&gt; bloomFilter = BloomFilter.create(StringFunnel.INSTANCE, <span class=\"number\">10</span>, <span class=\"number\">0.01</span>);                              </span><br><span class=\"line\">    <span class=\"comment\">// 查询www.google.com是否存在                                                                                                                   </span></span><br><span class=\"line\">    System.out.println(bloomFilter.mightContain(<span class=\"string\">\"www.google.com\"</span>));</span><br><span class=\"line\">     <span class=\"comment\">// 将www.google.com对象放入BloomFilter中</span></span><br><span class=\"line\">    bloomFilter.put(<span class=\"string\">\"www.google.com\"</span>);  </span><br><span class=\"line\">    <span class=\"comment\">// 再次查询www.google.com是否存在</span></span><br><span class=\"line\">    System.out.println(bloomFilter.mightContain(<span class=\"string\">\"www.google.com\"</span>));                                                     </span><br><span class=\"line\">\t&#125;    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"源码解读\"><a href=\"#源码解读\" class=\"headerlink\" title=\"源码解读\"></a>源码解读</h1><p>在例子中，我们通过调用<code>BloomFilter.create</code>工厂方法来生成一个BloomFilter</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;T&gt; <span class=\"function\">BloomFilter&lt;T&gt; <span class=\"title\">create</span><span class=\"params\">(Funnel&lt;? <span class=\"keyword\">super</span> T&gt; funnel, </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          <span class=\"keyword\">long</span> expectedInsertions,  //预期会插入多少元素</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          <span class=\"keyword\">double</span> fpp, //自定义误判率</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          Strategy strategy //Hash策略 </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          )</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (expectedInsertions == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      expectedInsertions = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">//根据插入的数量和误判率来得出位向量应有的长度,这里使用的算法就是公式 2</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> numBits = optimalNumOfBits(expectedInsertions, fpp);</span><br><span class=\"line\">    <span class=\"comment\">//根据插入的数量和位向量的长度来得出应该用多少个Hash函数，这里使用的算法是公式 4</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> numHashFunctions = optimalNumOfHashFunctions(expectedInsertions, numBits);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> BloomFilter&lt;T&gt;(<span class=\"keyword\">new</span> BitArray(numBits), numHashFunctions, funnel, strategy);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>整个创建流程非常清晰，如果看懂了本文的算法描述部分，应该不难理解该段代码。整个初始化流程的目的主要有两个：根据参数计算出位向量的长度以及Hash函数的个数</p>\n<ul>\n<li><p>根据预期插入的数量expectedInsertions和自定义的误判率fpp来得到位向量的长度numBits，其中optimalNumOfBits的实现如下</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 根据插入的数量和误判率来得出位向量应有的长度</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">long</span> <span class=\"title\">optimalNumOfBits</span><span class=\"params\">(<span class=\"keyword\">long</span> n, <span class=\"keyword\">double</span> p)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      p = Double.MIN_VALUE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (<span class=\"keyword\">long</span>) (-n * Math.log(p) / (Math.log(<span class=\"number\">2</span>) * Math.log(<span class=\"number\">2</span>)));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>  可以很明显看出，optimalNumOfBits的源码，其实就是对公式(1)的实现</p>\n</li>\n<li><p>根据插入的数量expectedInsertions和位向量的长度numBits来得出应该用多少个Hash函数，其中optimalNumOfHashFunctions的实现如下</p>\n   <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">optimalNumOfHashFunctions</span><span class=\"params\">(<span class=\"keyword\">long</span> n, <span class=\"keyword\">long</span> m)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// (m / n) * log(2), but avoid truncation due to division!</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> Math.max(<span class=\"number\">1</span>, (<span class=\"keyword\">int</span>) Math.round((<span class=\"keyword\">double</span>) m / n * Math.log(<span class=\"number\">2</span>)));</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>   同样，optimalNumOfHashFunctions也对应了我们算法中公式(4) </p>\n</li>\n<li><p>根据numBits生成BitArray</p>\n<p>   BitArray是Guava中位向量的表示，具体的实现细节</p>\n<h1 id=\"位向量的表示\"><a href=\"#位向量的表示\" class=\"headerlink\" title=\"位向量的表示\"></a>位向量的表示</h1></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BitArray</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">final</span> <span class=\"keyword\">long</span>[] data;</span><br><span class=\"line\">   <span class=\"keyword\">long</span> bitCount;</span><br><span class=\"line\"></span><br><span class=\"line\">   BitArray(<span class=\"keyword\">long</span> bits) &#123;</span><br><span class=\"line\">     <span class=\"comment\">//对于长度为m的位向量来说，对应的long数组的长度应为m/64向上取整。</span></span><br><span class=\"line\">     <span class=\"keyword\">this</span>(<span class=\"keyword\">new</span> <span class=\"keyword\">long</span>[Ints.checkedCast(LongMath.divide(bits, <span class=\"number\">64</span>, RoundingMode.CEILING))]);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// Used by serialization</span></span><br><span class=\"line\">   BitArray(<span class=\"keyword\">long</span>[] data) &#123;</span><br><span class=\"line\">     checkArgument(data.length &gt; <span class=\"number\">0</span>, <span class=\"string\">\"data length is zero!\"</span>);</span><br><span class=\"line\">     <span class=\"keyword\">this</span>.data = data;</span><br><span class=\"line\">     <span class=\"keyword\">long</span> bitCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">     <span class=\"keyword\">for</span> (<span class=\"keyword\">long</span> value : data) &#123;</span><br><span class=\"line\">       bitCount += Long.bitCount(value);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"keyword\">this</span>.bitCount = bitCount;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">/** Returns true if the bit changed value. */</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">set</span><span class=\"params\">(<span class=\"keyword\">long</span> index)</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (!get(index)) &#123;</span><br><span class=\"line\">       data[(<span class=\"keyword\">int</span>) (index &gt;&gt;&gt; <span class=\"number\">6</span>)] |= (<span class=\"number\">1L</span> &lt;&lt; index);</span><br><span class=\"line\">       bitCount++;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">long</span> index)</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> (data[(<span class=\"keyword\">int</span>) (index &gt;&gt;&gt; <span class=\"number\">6</span>)] &amp; (<span class=\"number\">1L</span> &lt;&lt; index)) != <span class=\"number\">0</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">/** Number of bits */</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">long</span> <span class=\"title\">bitSize</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> (<span class=\"keyword\">long</span>) data.length * Long.SIZE;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">/** Number of set bits (1s) */</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">long</span> <span class=\"title\">bitCount</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> bitCount;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\">BitArray <span class=\"title\">copy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> BitArray(data.clone());</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">/** Combines the two BitArrays using bitwise OR. */</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">putAll</span><span class=\"params\">(BitArray array)</span> </span>&#123;</span><br><span class=\"line\">     checkArgument(</span><br><span class=\"line\">         data.length == array.data.length,</span><br><span class=\"line\">         <span class=\"string\">\"BitArrays must be of equal length (%s != %s)\"</span>,</span><br><span class=\"line\">         data.length,</span><br><span class=\"line\">         array.data.length);</span><br><span class=\"line\">     bitCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">     <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; data.length; i++) &#123;</span><br><span class=\"line\">       data[i] |= array.data[i];</span><br><span class=\"line\">       bitCount += Long.bitCount(data[i]);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (o <span class=\"keyword\">instanceof</span> BitArray) &#123;</span><br><span class=\"line\">       BitArray bitArray = (BitArray) o;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> Arrays.equals(data, bitArray.data);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> Arrays.hashCode(data);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>在BitArray中，使用long数组来表示位向量，一个数组元素对应位向量的64位，所以对于长度为m的位向量来说，对应的long数组的长度应为m/64向上取整。</p>\n<p>即</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"keyword\">long</span>[Ints.checkedCast(LongMath.divide(bits, <span class=\"number\">64</span>, RoundingMode.CEILING))]</span><br></pre></td></tr></table></figure>\n<p>在BloomFilter算法讲解部分，我们可以看到，对于位向量的常用操作主要有两个，将位向量某一位置为1以及查看位向量某一位是否为1。分别对应源码中得set操作和get操作 本文只讲下get方法的源码部分，set方法与get方法类似，不再累述。</p>\n<p>get方法大致可以分为两部分</p>\n<ul>\n<li><p>data[(int) (index &gt;&gt;&gt; 6)] 定位到元素</p>\n<p>上面讲到long数组的每一个元素都包含位向量其中的64位，如果想要找出某个位的bit，那么首先第一步就是定位到该bit所在的元素编号。我们一般的做法是<code>index/64</code>。 而源码中使用了<code>index &gt;&gt;&gt; 6</code>,逻辑右移6位，$2^6 = 64$,其效果与除以64相同。采用位运算的速度比普通的除法要快很多。</p>\n</li>\n<li><p>… &amp; (1L &lt;&lt; index) 获取位的状态</p>\n<p>源码中直接将要查看的bit以及同一数组元素块的64位bits一起取出，将1L左移index位后求且运算，最终即可得出该位的值。</p>\n</li>\n</ul>\n<h1 id=\"BloomFilter的优化和扩展\"><a href=\"#BloomFilter的优化和扩展\" class=\"headerlink\" title=\"BloomFilter的优化和扩展\"></a>BloomFilter的优化和扩展</h1><p>上文提到布隆过滤器无法支持元素的删除操作,Counting BloomFilter通过存储位元素每一位的置为1的数量，使得布隆过滤器可以支持删除操作。 但是这样会数倍地增加布隆过滤器的存储空间。</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><blockquote>\n<p><a href=\"https://en.wikipedia.org/wiki/Bloom_filter\" target=\"_blank\" rel=\"noopener\">维基百科</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://www.cs.dal.ca/research/techreports/cs-2002-10\" target=\"_blank\" rel=\"noopener\">Dalhousie University</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"http://leadtoit.iteye.com/blog/1961751\" target=\"_blank\" rel=\"noopener\">Guava笔记</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://blog.csdn.net/jiaomeng/article/details/1498283\" target=\"_blank\" rel=\"noopener\">Counting Bloom Filter</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"http://ifeve.com/google-guava-hashing/\" target=\"_blank\" rel=\"noopener\">http://ifeve.com/google-guava-hashing/</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><p>BloomFilter（布隆过滤器）是一种可以高效地判断元素是否在某个集合中的算法。</p>\n<p>在很多日常场景中，都大量存在着布隆过滤器的应用。例如：检查单词是否拼写正确、网络爬虫的URL去重、黑名单检验，微博中昵称不能重复的检测。Google Chrome浏览器使用BloomFilter来判断一个网站是否为恶意网站。</p>\n<p>对于以上场景，可能很多人会说，用HashSet甚至简单的链表、数组做存储，然后判断是否存在不就可以了吗？</p>\n<p>当然，对于少量数据来说，HashSet是很好的选择。但是对于海量数据来说，BloomFilter相比于其他数据结构在空间效率和时间效率方面都有着明显的优势。</p>\n<p>但是，布隆过滤器具有一定的误判率，有可能会将本不存在的元素判定为存在。因此，对于那些需要“零错误”的应用场景，布隆过滤器将不太适用。具体的原因将会在第二部分中介绍。  </p>\n<p>在本文的第二部分，本文将会介绍BloomFilter的基本算法思想；第三部分将会基于Google开源库Guava来讲解BloomFilter的具体实现；在第四部分中，将会介绍一些开源的BloomFilter的扩展，以解决目前BloomFilter的不足。</p>\n<h1 id=\"算法讲述\"><a href=\"#算法讲述\" class=\"headerlink\" title=\"算法讲述\"></a>算法讲述</h1><p>布隆过滤器是基于Hash来实现的，在学习BloomFilter之前，也需要对Hash的原理有基本的了解。个人认为，BloomFilter的总体思想实际上和bitmap很像，但是比bitmap更节省空间，误判率也更低。</p>\n<p>BloomFilter的整体思想并不复杂，主要是使用k个Hash函数将元素映射到位向量的k个位置上面，并将这k个位置全部置为1。当查找某元素是否存在时，查找该元素所对应的k位是否全部为1即可说明该元素是否存在。</p>\n<h1 id=\"算法流程\"><a href=\"#算法流程\" class=\"headerlink\" title=\"算法流程\"></a>算法流程</h1><p><strong>BloomFilter的整体算法流程可总结为如下步骤：</strong></p>\n<ol>\n<li><p>BloomFilter初始化为m位长度的位向量，每一位均初始化为<img src=\"http://epoch-night.oss-cn-hangzhou.aliyuncs.com/PostImg/bf1.jpg\" alt=\"bf1\"></p>\n</li>\n<li><p>使用k个相互独立的Hash函数，每个Hash函数将元素映射到{1..m}的范围内，并将对应的位置为1。<img src=\"http://epoch-night.oss-cn-hangzhou.aliyuncs.com/PostImg/bf2.jpg\" alt=\"bf2\">如上图所示，元素x分别被三个Hash函数映射到了三个位置8、1、14，并将这三个位置从0变为1。</p>\n</li>\n<li><p>若检查一个元素y是否存在，首先第一步使用k个Hash函数将元素y映射到k位。分别检测每一位是否为0。若某一位为0，则元素y一定不存在，若全部为1，则有可能存在。</p>\n</li>\n</ol>\n<p><strong>空间复杂度</strong></p>\n<p>BloomFilter 使用位向量来表示元素，而不存储本身，这样极大压缩了元素的存储空间。其空间复杂度为O(m)，m是位向量的长度。而m与插入总数量n的关系如公式（1）所示：</p>\n<p>$$<br>\\begin{equation} \\label{euler}  m=-{\\frac {n\\ln p}{(\\ln 2)^{2}}}   \\end{equation}<br>$$<br>我们可以利用这个公式来算一下需要抓取100万个URL时BloomFilter所占据的空间。</p>\n<p>假设要求误判率为1%，因此该公式可转化为m=9.6∗nm=9.6∗n。故此时BloomFilter位向量的大小为100w∗9.6=960wbit100w∗9.6=960wbit，约1.1M内存空间。<br>只需要1.1M的内存空间，就可满足100万个url的去重需求，这个空间复杂度之低不可谓不惊人。<br>实际上，哪怕是1亿个URL，也仅需100M左右的内存空间即可满足BloomFilter的空间需求，这对于绝大部分爬虫的体量来说，是完全可行的。</p>\n<p><strong>时间复杂度</strong><br>时间复杂度方面 BloomFilter的时间复杂度仅与Hash函数的个数k有关，即O(k)</p>\n<h1 id=\"误判率\"><a href=\"#误判率\" class=\"headerlink\" title=\"误判率\"></a>误判率</h1><p>为什么说，在查找元素时，即使某个元素所映射的k位全部位1，依然无法确定它一定存在？</p>\n<p>这是因为当插入的元素很多的情况下，某个元素即使之前不存在，但是它所映射的k位已经被之前其他的元素置为1了，这样就会出现误判，BloomFilter会认为它已经存在了。但是这个概率是非常小的。根据维基百科的推导公式来说，误判率的大小p满足以下公式（2）</p>\n<p>$$<br>\\begin{equation}   \\ln p = -{\\frac {m}{n}}\\left(\\ln 2\\right)^{2} \\label{eq:p} \\end{equation}<br>$$<br>其中m为位向量的长度，n为要插入元素的总数。当误判率为1%时,mn=9.6mn=9.6即每个元素仅需要9.6个字节存储即可</p>\n<p>Hash函数的个数k，与误判率大小p的关系为公式（3） 所示</p>\n<p>$$<br>\\begin{equation}   k = {-{\\ln p} \\over {\\ln 2}} \\label{eq:k1} \\end{equation}<br>$$<br>当误判率大小为0.1时，k为3。当误判率大小为0.01时，k为7</p>\n<p>与位向量的长度m和插入元素的总数n的关系为公式（4）</p>\n<p>$$<br>\\begin{equation}   k = {\\frac {m}{n}}\\ln 2 \\label{eq:k2} \\end{equation}<br>$$</p>\n<h1 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h1><p>BloomFilter 由于并不存储元素，而是用位的01来表示元素是否存在，并且很有可能一个位时被多个元素同时使用。所以无法通过将某元素对应的位置为0来删除元素。</p>\n<p>幸运的是，目前学术界和工业界都有很多方法扩展已解决以上问题。具体可以参考本文第三部分 <strong>BloomFilter的优化和扩展</strong></p>\n<h1 id=\"Guava’s-BloomFilter源码剖析\"><a href=\"#Guava’s-BloomFilter源码剖析\" class=\"headerlink\" title=\"Guava’s BloomFilter源码剖析\"></a>Guava’s BloomFilter源码剖析</h1><p>Guava引入了一个叫做<code>Funnel</code>的类，Funnel类定义了如何把一个具体的对象类型分解为原生字段值，从而将值分解为Byte以供后面BloomFilter进行hash运算。通过使用这个类，我们可以自己定义一个属于自己类的Funnel。如下代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> StringFunnel implements Funnel&lt;String&gt; &#123;    </span><br><span class=\"line\">    INSTANCE;   </span><br><span class=\"line\">    <span class=\"meta\">@Override</span>    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">funnel</span><span class=\"params\">(String from, PrimitiveSink into)</span> </span>&#123;        \t\t</span><br><span class=\"line\">    \tinto.putString(from,Charset.defaultCharset());    </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此外，Guava预定义了一些原生类型的Funnel，如String、Long、Integer。具体代码可以在<a href=\"https://github.com/google/guava/blob/master/guava/src/com/google/common/hash/Funnels.java\" target=\"_blank\" rel=\"noopener\">这里看到</a>。当我们的BloomFilter存储的是这些原生类型时，不用再额外自行写Funnel，直接使用Guava预定义的这些即可。</p>\n<p>以下是整个代码调用的流程</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BloomFilterSamle</span> </span>&#123;                                                                                             </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;    </span><br><span class=\"line\">\t<span class=\"comment\">// 创建一个BloomFilter，其预计插入的个数为10，误判率大约为0.01</span></span><br><span class=\"line\">    BloomFilter&lt;String&gt; bloomFilter = BloomFilter.create(StringFunnel.INSTANCE, <span class=\"number\">10</span>, <span class=\"number\">0.01</span>);                              </span><br><span class=\"line\">    <span class=\"comment\">// 查询www.google.com是否存在                                                                                                                   </span></span><br><span class=\"line\">    System.out.println(bloomFilter.mightContain(<span class=\"string\">\"www.google.com\"</span>));</span><br><span class=\"line\">     <span class=\"comment\">// 将www.google.com对象放入BloomFilter中</span></span><br><span class=\"line\">    bloomFilter.put(<span class=\"string\">\"www.google.com\"</span>);  </span><br><span class=\"line\">    <span class=\"comment\">// 再次查询www.google.com是否存在</span></span><br><span class=\"line\">    System.out.println(bloomFilter.mightContain(<span class=\"string\">\"www.google.com\"</span>));                                                     </span><br><span class=\"line\">\t&#125;    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"源码解读\"><a href=\"#源码解读\" class=\"headerlink\" title=\"源码解读\"></a>源码解读</h1><p>在例子中，我们通过调用<code>BloomFilter.create</code>工厂方法来生成一个BloomFilter</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;T&gt; <span class=\"function\">BloomFilter&lt;T&gt; <span class=\"title\">create</span><span class=\"params\">(Funnel&lt;? <span class=\"keyword\">super</span> T&gt; funnel, </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          <span class=\"keyword\">long</span> expectedInsertions,  //预期会插入多少元素</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          <span class=\"keyword\">double</span> fpp, //自定义误判率</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          Strategy strategy //Hash策略 </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          )</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (expectedInsertions == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      expectedInsertions = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">//根据插入的数量和误判率来得出位向量应有的长度,这里使用的算法就是公式 2</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> numBits = optimalNumOfBits(expectedInsertions, fpp);</span><br><span class=\"line\">    <span class=\"comment\">//根据插入的数量和位向量的长度来得出应该用多少个Hash函数，这里使用的算法是公式 4</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> numHashFunctions = optimalNumOfHashFunctions(expectedInsertions, numBits);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> BloomFilter&lt;T&gt;(<span class=\"keyword\">new</span> BitArray(numBits), numHashFunctions, funnel, strategy);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>整个创建流程非常清晰，如果看懂了本文的算法描述部分，应该不难理解该段代码。整个初始化流程的目的主要有两个：根据参数计算出位向量的长度以及Hash函数的个数</p>\n<ul>\n<li><p>根据预期插入的数量expectedInsertions和自定义的误判率fpp来得到位向量的长度numBits，其中optimalNumOfBits的实现如下</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 根据插入的数量和误判率来得出位向量应有的长度</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">long</span> <span class=\"title\">optimalNumOfBits</span><span class=\"params\">(<span class=\"keyword\">long</span> n, <span class=\"keyword\">double</span> p)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      p = Double.MIN_VALUE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (<span class=\"keyword\">long</span>) (-n * Math.log(p) / (Math.log(<span class=\"number\">2</span>) * Math.log(<span class=\"number\">2</span>)));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>  可以很明显看出，optimalNumOfBits的源码，其实就是对公式(1)的实现</p>\n</li>\n<li><p>根据插入的数量expectedInsertions和位向量的长度numBits来得出应该用多少个Hash函数，其中optimalNumOfHashFunctions的实现如下</p>\n   <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">optimalNumOfHashFunctions</span><span class=\"params\">(<span class=\"keyword\">long</span> n, <span class=\"keyword\">long</span> m)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// (m / n) * log(2), but avoid truncation due to division!</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> Math.max(<span class=\"number\">1</span>, (<span class=\"keyword\">int</span>) Math.round((<span class=\"keyword\">double</span>) m / n * Math.log(<span class=\"number\">2</span>)));</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>   同样，optimalNumOfHashFunctions也对应了我们算法中公式(4) </p>\n</li>\n<li><p>根据numBits生成BitArray</p>\n<p>   BitArray是Guava中位向量的表示，具体的实现细节</p>\n<h1 id=\"位向量的表示\"><a href=\"#位向量的表示\" class=\"headerlink\" title=\"位向量的表示\"></a>位向量的表示</h1></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BitArray</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">final</span> <span class=\"keyword\">long</span>[] data;</span><br><span class=\"line\">   <span class=\"keyword\">long</span> bitCount;</span><br><span class=\"line\"></span><br><span class=\"line\">   BitArray(<span class=\"keyword\">long</span> bits) &#123;</span><br><span class=\"line\">     <span class=\"comment\">//对于长度为m的位向量来说，对应的long数组的长度应为m/64向上取整。</span></span><br><span class=\"line\">     <span class=\"keyword\">this</span>(<span class=\"keyword\">new</span> <span class=\"keyword\">long</span>[Ints.checkedCast(LongMath.divide(bits, <span class=\"number\">64</span>, RoundingMode.CEILING))]);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// Used by serialization</span></span><br><span class=\"line\">   BitArray(<span class=\"keyword\">long</span>[] data) &#123;</span><br><span class=\"line\">     checkArgument(data.length &gt; <span class=\"number\">0</span>, <span class=\"string\">\"data length is zero!\"</span>);</span><br><span class=\"line\">     <span class=\"keyword\">this</span>.data = data;</span><br><span class=\"line\">     <span class=\"keyword\">long</span> bitCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">     <span class=\"keyword\">for</span> (<span class=\"keyword\">long</span> value : data) &#123;</span><br><span class=\"line\">       bitCount += Long.bitCount(value);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"keyword\">this</span>.bitCount = bitCount;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">/** Returns true if the bit changed value. */</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">set</span><span class=\"params\">(<span class=\"keyword\">long</span> index)</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (!get(index)) &#123;</span><br><span class=\"line\">       data[(<span class=\"keyword\">int</span>) (index &gt;&gt;&gt; <span class=\"number\">6</span>)] |= (<span class=\"number\">1L</span> &lt;&lt; index);</span><br><span class=\"line\">       bitCount++;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">long</span> index)</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> (data[(<span class=\"keyword\">int</span>) (index &gt;&gt;&gt; <span class=\"number\">6</span>)] &amp; (<span class=\"number\">1L</span> &lt;&lt; index)) != <span class=\"number\">0</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">/** Number of bits */</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">long</span> <span class=\"title\">bitSize</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> (<span class=\"keyword\">long</span>) data.length * Long.SIZE;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">/** Number of set bits (1s) */</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">long</span> <span class=\"title\">bitCount</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> bitCount;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\">BitArray <span class=\"title\">copy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> BitArray(data.clone());</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">/** Combines the two BitArrays using bitwise OR. */</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">putAll</span><span class=\"params\">(BitArray array)</span> </span>&#123;</span><br><span class=\"line\">     checkArgument(</span><br><span class=\"line\">         data.length == array.data.length,</span><br><span class=\"line\">         <span class=\"string\">\"BitArrays must be of equal length (%s != %s)\"</span>,</span><br><span class=\"line\">         data.length,</span><br><span class=\"line\">         array.data.length);</span><br><span class=\"line\">     bitCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">     <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; data.length; i++) &#123;</span><br><span class=\"line\">       data[i] |= array.data[i];</span><br><span class=\"line\">       bitCount += Long.bitCount(data[i]);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (o <span class=\"keyword\">instanceof</span> BitArray) &#123;</span><br><span class=\"line\">       BitArray bitArray = (BitArray) o;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> Arrays.equals(data, bitArray.data);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> Arrays.hashCode(data);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>在BitArray中，使用long数组来表示位向量，一个数组元素对应位向量的64位，所以对于长度为m的位向量来说，对应的long数组的长度应为m/64向上取整。</p>\n<p>即</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"keyword\">long</span>[Ints.checkedCast(LongMath.divide(bits, <span class=\"number\">64</span>, RoundingMode.CEILING))]</span><br></pre></td></tr></table></figure>\n<p>在BloomFilter算法讲解部分，我们可以看到，对于位向量的常用操作主要有两个，将位向量某一位置为1以及查看位向量某一位是否为1。分别对应源码中得set操作和get操作 本文只讲下get方法的源码部分，set方法与get方法类似，不再累述。</p>\n<p>get方法大致可以分为两部分</p>\n<ul>\n<li><p>data[(int) (index &gt;&gt;&gt; 6)] 定位到元素</p>\n<p>上面讲到long数组的每一个元素都包含位向量其中的64位，如果想要找出某个位的bit，那么首先第一步就是定位到该bit所在的元素编号。我们一般的做法是<code>index/64</code>。 而源码中使用了<code>index &gt;&gt;&gt; 6</code>,逻辑右移6位，$2^6 = 64$,其效果与除以64相同。采用位运算的速度比普通的除法要快很多。</p>\n</li>\n<li><p>… &amp; (1L &lt;&lt; index) 获取位的状态</p>\n<p>源码中直接将要查看的bit以及同一数组元素块的64位bits一起取出，将1L左移index位后求且运算，最终即可得出该位的值。</p>\n</li>\n</ul>\n<h1 id=\"BloomFilter的优化和扩展\"><a href=\"#BloomFilter的优化和扩展\" class=\"headerlink\" title=\"BloomFilter的优化和扩展\"></a>BloomFilter的优化和扩展</h1><p>上文提到布隆过滤器无法支持元素的删除操作,Counting BloomFilter通过存储位元素每一位的置为1的数量，使得布隆过滤器可以支持删除操作。 但是这样会数倍地增加布隆过滤器的存储空间。</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><blockquote>\n<p><a href=\"https://en.wikipedia.org/wiki/Bloom_filter\" target=\"_blank\" rel=\"noopener\">维基百科</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://www.cs.dal.ca/research/techreports/cs-2002-10\" target=\"_blank\" rel=\"noopener\">Dalhousie University</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"http://leadtoit.iteye.com/blog/1961751\" target=\"_blank\" rel=\"noopener\">Guava笔记</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://blog.csdn.net/jiaomeng/article/details/1498283\" target=\"_blank\" rel=\"noopener\">Counting Bloom Filter</a></p>\n</blockquote>\n<blockquote>\n<p><a href=\"http://ifeve.com/google-guava-hashing/\" target=\"_blank\" rel=\"noopener\">http://ifeve.com/google-guava-hashing/</a></p>\n</blockquote>\n"},{"layout":"post","title":"Java String.indexOf对比KMP","date":"2017-09-03T06:10:00.000Z","author":"Gubaidan","header-img":"/Header/lake.jpg","cdn":"header-on","_content":"#  说明\n\nKmp和indexOf 都是用于匹配字符串，如果匹配到目标字符串则返回首个字符下标，如果匹配到则返回-1\n\n之前偶然打开Java String.indexOf的源码以为会很高大上，结果发现indexOf中的源码是暴力匹配字符串的...\n\n所以准备对比一下这两个方法，不过还是先梳理一下这两个算法的源码。\n\n## KMP\n\n举例来说，有一个字符串\"BBC ABCDAB ABCDABCDABDE\"，我想知道，里面是否包含另一个字符串\"ABCDABD\"\n\n### KMP算法流程：\n\n1、首先，字符串\"BBC ABCDAB ABCDABCDABDE\"的第一个字符与搜索词\"ABCDABD\"的第一个字符，进行比较。因为B与A不匹配，所以搜索词整体后移一位，因为B与A不匹配，搜索词整体再往后移\n\n2、直到字符串有一个字符，与搜索词的第一个字符相同为止。\n\n3、接着比较字符串和搜索词的下一个字符，一只比对到搜索词最后一个字符完成。\n\n* 如果全部匹配，则返回搜索词第一个字符对应的字符串中字符的下标。(下图index)\n* 如果某个字符不匹配，执行下一步。\n\n![kmp](http://epoch-night.oss-cn-hangzhou.aliyuncs.com/PostImg/kmp-accept.png)\n\n4、这时，最自然的反应是，将搜索词整个后移一位，再从头逐个比较。这样做虽然可行，但是效率很差，因为你要把\"搜索位置\"移到已经比较过的位置，重比一遍。\n\n一个基本事实是，当空格与D不匹配时，你其实知道前面六个字符是\"ABCDAB\"。KMP算法的想法是，设法利用这个已知信息，不要把\"搜索位置\"移回已经比较过的位置，继续把它向后移，这样就提高了效率。\n\n5、怎么做到这一点呢？可以针对搜索词，算出一张《部分匹配表》（Partial Match Table）。这张表是如何产生的，后面再介绍，这里知道如何使用即可。\n\n6、已知空格与D不匹配时，前面六个字符\"ABCDAB\"是匹配的。查表可知，最后一个匹配字符B对应的\"部分匹配值\"为2，因此按照下面的公式算出向后移动的位数：\n\n> 移动位数 = 已匹配的字符数 - 对应的部分匹配值\n\n因为 6 - 2 等于4，所以将搜索词向后移动4位。\n\n7、逐位比较，直到搜索词的最后一位，发现完全匹配，于是搜索完成。\n\n### 部分匹配表（next数组）：\n\n首先，要了解两个概念：\"前缀\"和\"后缀\"。 \"前缀\"指除了最后一个字符以外，一个字符串的全部头部组合；\"后缀\"指除了第一个字符以外，一个字符串的全部尾部组合。\n\n\"部分匹配值\"就是\"前缀\"和\"后缀\"的最长的共有元素的长度。以\"ABCDABD\"为例\n\n```sh\n－　\"A\"的前缀和后缀都为空集，共有元素的长度为0；\n\n－　\"AB\"的前缀为[A]，后缀为[B]，共有元素的长度为0；\n\n－　\"ABC\"的前缀为[A, AB]，后缀为[BC, C]，共有元素的长度0；\n\n－　\"ABCD\"的前缀为[A, AB, ABC]，后缀为[BCD, CD, D]，共有元素的长度为0；\n\n－　\"ABCDA\"的前缀为[A, AB, ABC, ABCD]，后缀为[BCDA, CDA, DA, A]，共有元素为\"A\"，长度为1；\n\n－　\"ABCDAB\"的前缀为[A, AB, ABC, ABCD, ABCDA]，后缀为[BCDAB, CDAB, DAB, AB, B]，共有元素为\"AB\"，长度为2；\n\n－　\"ABCDABD\"的前缀为[A, AB, ABC, ABCD, ABCDA, ABCDAB]，后缀为[BCDABD, CDABD, DABD, ABD, BD, D]，共有元素的长度为0。\n```\n\n\n　　\n\n\"部分匹配\"的实质是，有时候，字符串头部和尾部会有重复。比如，\"ABCDAB\"之中有两个\"AB\"，那么它的\"部分匹配值\"就是2（\"AB\"的长度）。搜索词移动的时候，第一个\"AB\"向后移动4位（字符串长度-部分匹配值），就可以来到第二个\"AB\"的位置。\n\n### 求解Next数组\n\n```java\npublic static void cal_next(char[] str, int[] next) {\n    int len = str.length;\n    next[0] = -1;         //next[0]初始化为-1，-1表示不存在相同的最大前缀和最大后缀\n    int k = -1;           //k初始化为-1\n    \n    //如果下一个不同，那么k就变成next[k]，注意next[k]\n    for (int q = 1; q <= len - 1; q++) {\n        while (k > -1 && str[k + 1] != str[q]) { //是小于k的，无论k取任何值。\n            k = next[k];                         //往前回溯\n        }\n        if (str[k + 1] == str[q]) {              //如果相同，k++\n            k ++;\n        }\n        next[q] = k;      //这个是把算的k的值（就是相同的最大前缀和最大后缀长）赋给next[q]\n\t}\n}\n```\n\n\n\n首先我们看第一个while循环，它到底干了什么。\n\n在此之前，我们先回到原程序。原程序里有一个大的**for()**循环，那这个for()循环是干嘛的？\n\n这个for循环就是计算next[0]，next[1],…next[q]…的值。\n\n里面最后一句next[q]=k就是说明每次循环结束，我们已经计算了ptr的前(q+1)个字母组成的子串的“**相同的最长前缀和最长后缀的长度**”。（这句话前面已经解释了！） 这个“**长度**”就是k。\n\n好，到此为止，假设循环进行到 第 q 次，即已经计算了next[q]，我们是怎么计算next[q+1]呢？\n\n比如我们已经知道**ababab**，q=4时，next[4]=2（k=2，表示该字符串的前5个字母组成的子串**ababa**存在**相同的最长前缀和最长后缀的长度**是3，所以k=2,next[4]=2。这个结果可以理解成我们自己观察算的，也可以理解成程序自己算的，这不是重点，重点是程序根据目前的结果怎么算next[5]的）.，那么对于字符串**ababab**，我们计算next[5]的时候，此时q=5, k=2（上一步循环结束后的结果）。那么我们需要比较的是str[k+1]和str[q]是否相等，其实就是str[1]和str[5]是否相等！，为啥从k+1比较呢，因为上一次循环中，**我们已经保证了str[k]和str[q] (注意这个q是上次循环的q)是相等的**（这句话自己想想，很容易理解），所以到本次循环，我们直接比较str[k+1]和str[q]是否相等（这个q是本次循环的q）。 \n\n\n如果相等，那么跳出while()，进入if()，k=k+1，接着next[q]=k。即对于**ababab**，我们会得出next[5]=3。 这是程序自己算的，和我们观察的是一样的。 \n\n\n如果不等，我们可以用”**ababac**“描述这种情况。 不等，进入while()里面，进行k=next[k]，这句话是说，在str[k + 1] != str[q]的情况下，我们往前找一个k，使str[k + 1]==str[q]，是往前一个一个找呢，还是有更快的找法呢？。程序给出了一种更快的找法，那就是 k = next[k]。 程序的意思是说，一旦str[k + 1] != str[q]，即在后缀里面找不到时，我是可以直接跳过中间一段，跑到前缀里面找，**next[k]**就是**相同的最长前缀和最长后缀的长度**。所以，k=next[k]就变成，k=next[2]，即k=0。此时再比较str[0+1]和str[5]是否相等，不等，则k=next[0]=-1。跳出循环。\n\n### 完整的KMP代码\n\n```java\npublic static int KMP(String s, String p) {\n    int slen = s.length();\n    int plen = p.length();\n    char[] str = s.toCharArray();\n    char[] ptr = p.toCharArray();\n    int[] next = new int[plen];\n    cal_next(ptr, next);\n    int k = -1;\n    for (int i = 0; i < slen; i++) {\n        while (k > -1 && ptr[k + 1] != str[i])  //ptr和str不匹配，且k>-1（表示ptr和str有部分匹配）\n            k = next[k];                        //往前回溯\n        if (ptr[k + 1] == str[i])\n            k ++;\n        if (k == plen - 1) {            //说明k移动到ptr的最末端\n            return i - plen + 1;        //返回相应的位置\n        }\n    }\n    return -1;\n}\n\npublic static void cal_next(char[] str, int[] next) {\n    int len = str.length;\n    next[0] = -1;         //next[0]初始化为-1，-1表示不存在相同的最大前缀和最大后缀\n    int k = -1;           //k初始化为-1\n    \n    //如果下一个不同，那么k就变成next[k]，注意next[k]\n    for (int q = 1; q <= len - 1; q++) {\n        while (k > -1 && str[k + 1] != str[q]) { //是小于k的，无论k取任何值。\n            k = next[k];                         //往前回溯\n        }\n        if (str[k + 1] == str[q]) {              //如果相同，k++\n            k ++;\n        }\n        next[q] = k;      //这个是把算的k的值（就是相同的最大前缀和最大后缀长）赋给next[q]\n}\n\npublic static void main(String[] args) {\n    long start = System.currentTimeMillis();\n    String full = \"BBC ABCDAB ABCDABCDABDE\";\n    String par = \"ABCDABD\";\n    int res = KMP(full,par);\n    //int res = full.indexOf(par);\n    System.out.println(res+\",\"+(System.currentTimeMillis() - start)+\"ms\");\n}\n```\n\n时间复杂度O(n)\n\n## indexOf（）\n\n流程：\n\n1、首先，字符串\"BBC ABCDAB ABCDABCDABDE\"的第一个字符与搜索词\"ABCDABD\"的第一个字符，进行比较。因为B与A不匹配，所以搜索词整体后移一位，因为B与A不匹配，搜索词整体再往后移\n\n2、直到字符串有一个字符，与搜索词的第一个字符相同为止。\n\n3、接着比较字符串和搜索词的下一个字符，一只比对到搜索词最后一个字符完成。\n\n- 如果全部匹配，则返回搜索词第一个字符对应的字符串中字符的下标。\n- 如果某个字符不匹配，执行下一步。\n\n4、这时，和KMP不同的是，不再利用Next数组，而是将搜索词整个后移一位，再从头逐个比较。\n\nindexOf和KMP实现同样的功能，但是用原始暴力的方法求解，所以直接来看看源码：\n\n\n```java\n/**\n* Code shared by String and StringBuffer to do searches. The\n* source is the character array being searched, and the target\n* is the string being searched for.\n*\n* @param   source       the characters being searched.\n* @param   sourceOffset offset of the source string.\n* @param   sourceCount  count of the source string.\n* @param   target       the characters being searched for.\n* @param   targetOffset offset of the target string.\n* @param   targetCount  count of the target string.\n* @param   fromIndex    the index to begin searching from.\n*/\nstatic int indexOf(char[] source, int sourceOffset, int sourceCount,\n        char[] target, int targetOffset, int targetCount,\n        int fromIndex) {\n    if (fromIndex >= sourceCount) {\n        return (targetCount == 0 ? sourceCount : -1);\n    }\n    if (fromIndex < 0) {\n        fromIndex = 0;\n    }\n    if (targetCount == 0) {\n        return fromIndex;\n    }\n\n    char first = target[targetOffset];\n    //找到遍历的最大位置\n    int max = sourceOffset + (sourceCount - targetCount);\n\n    for (int i = sourceOffset + fromIndex; i <= max; i++) {\n        /* Look for first character. */\n        if (source[i] != first) {\n            while (++i <= max && source[i] != first);\n        }\n\n        /* Found first character, now look at the rest of v2 */\n        if (i <= max) {\n            int j = i + 1;\n            int end = j + targetCount - 1;\n            for (int k = targetOffset + 1; j < end && source[j]\n                    == target[k]; j++, k++);\n\t\t\t//完全符合时返回坐标\n            if (j == end) {\n                /* Found whole string. */\n                return i - sourceOffset;\n            }\n        }\n    }\n    return -1;\n}\n```\n时间复杂度O(n*m)\n\n### 总结：\n\n可能是JDK的编写者们认为大多数情况下，字符串都不长，使用原始实现可能代价更低。在我测试过程中，使用indexOf方法时要比KMP算法要快一点。KMP算法对与超长字符串子匹配速度上是优于IndexOf的。\n\n因为KMP算法需要预先计算处理来获得辅助数组，需要一定的时间和空间，这可能在短字符串查找中相比较原始实现耗费更大的代价。而且一般大字符串查找时，程序员们也会使用其它特定的数据结构，查找起来更简单。这有点类似于排除特定情况下的快速排序了。不同环境选择不同算法。\n\n> 参考：[经典算法-KMP](https://blog.csdn.net/starstar1992/article/details/54913261/)","source":"_posts/2017-09-03-kmp.markdown","raw":"---\nlayout: post\ntitle: \"Java String.indexOf对比KMP\"\ndate: 2017-09-03 14:10\nauthor: \"Gubaidan\"\nheader-img: \"/Header/lake.jpg\"\ncdn: 'header-on'\ntags:\n\t- 算法\n---\n#  说明\n\nKmp和indexOf 都是用于匹配字符串，如果匹配到目标字符串则返回首个字符下标，如果匹配到则返回-1\n\n之前偶然打开Java String.indexOf的源码以为会很高大上，结果发现indexOf中的源码是暴力匹配字符串的...\n\n所以准备对比一下这两个方法，不过还是先梳理一下这两个算法的源码。\n\n## KMP\n\n举例来说，有一个字符串\"BBC ABCDAB ABCDABCDABDE\"，我想知道，里面是否包含另一个字符串\"ABCDABD\"\n\n### KMP算法流程：\n\n1、首先，字符串\"BBC ABCDAB ABCDABCDABDE\"的第一个字符与搜索词\"ABCDABD\"的第一个字符，进行比较。因为B与A不匹配，所以搜索词整体后移一位，因为B与A不匹配，搜索词整体再往后移\n\n2、直到字符串有一个字符，与搜索词的第一个字符相同为止。\n\n3、接着比较字符串和搜索词的下一个字符，一只比对到搜索词最后一个字符完成。\n\n* 如果全部匹配，则返回搜索词第一个字符对应的字符串中字符的下标。(下图index)\n* 如果某个字符不匹配，执行下一步。\n\n![kmp](http://epoch-night.oss-cn-hangzhou.aliyuncs.com/PostImg/kmp-accept.png)\n\n4、这时，最自然的反应是，将搜索词整个后移一位，再从头逐个比较。这样做虽然可行，但是效率很差，因为你要把\"搜索位置\"移到已经比较过的位置，重比一遍。\n\n一个基本事实是，当空格与D不匹配时，你其实知道前面六个字符是\"ABCDAB\"。KMP算法的想法是，设法利用这个已知信息，不要把\"搜索位置\"移回已经比较过的位置，继续把它向后移，这样就提高了效率。\n\n5、怎么做到这一点呢？可以针对搜索词，算出一张《部分匹配表》（Partial Match Table）。这张表是如何产生的，后面再介绍，这里知道如何使用即可。\n\n6、已知空格与D不匹配时，前面六个字符\"ABCDAB\"是匹配的。查表可知，最后一个匹配字符B对应的\"部分匹配值\"为2，因此按照下面的公式算出向后移动的位数：\n\n> 移动位数 = 已匹配的字符数 - 对应的部分匹配值\n\n因为 6 - 2 等于4，所以将搜索词向后移动4位。\n\n7、逐位比较，直到搜索词的最后一位，发现完全匹配，于是搜索完成。\n\n### 部分匹配表（next数组）：\n\n首先，要了解两个概念：\"前缀\"和\"后缀\"。 \"前缀\"指除了最后一个字符以外，一个字符串的全部头部组合；\"后缀\"指除了第一个字符以外，一个字符串的全部尾部组合。\n\n\"部分匹配值\"就是\"前缀\"和\"后缀\"的最长的共有元素的长度。以\"ABCDABD\"为例\n\n```sh\n－　\"A\"的前缀和后缀都为空集，共有元素的长度为0；\n\n－　\"AB\"的前缀为[A]，后缀为[B]，共有元素的长度为0；\n\n－　\"ABC\"的前缀为[A, AB]，后缀为[BC, C]，共有元素的长度0；\n\n－　\"ABCD\"的前缀为[A, AB, ABC]，后缀为[BCD, CD, D]，共有元素的长度为0；\n\n－　\"ABCDA\"的前缀为[A, AB, ABC, ABCD]，后缀为[BCDA, CDA, DA, A]，共有元素为\"A\"，长度为1；\n\n－　\"ABCDAB\"的前缀为[A, AB, ABC, ABCD, ABCDA]，后缀为[BCDAB, CDAB, DAB, AB, B]，共有元素为\"AB\"，长度为2；\n\n－　\"ABCDABD\"的前缀为[A, AB, ABC, ABCD, ABCDA, ABCDAB]，后缀为[BCDABD, CDABD, DABD, ABD, BD, D]，共有元素的长度为0。\n```\n\n\n　　\n\n\"部分匹配\"的实质是，有时候，字符串头部和尾部会有重复。比如，\"ABCDAB\"之中有两个\"AB\"，那么它的\"部分匹配值\"就是2（\"AB\"的长度）。搜索词移动的时候，第一个\"AB\"向后移动4位（字符串长度-部分匹配值），就可以来到第二个\"AB\"的位置。\n\n### 求解Next数组\n\n```java\npublic static void cal_next(char[] str, int[] next) {\n    int len = str.length;\n    next[0] = -1;         //next[0]初始化为-1，-1表示不存在相同的最大前缀和最大后缀\n    int k = -1;           //k初始化为-1\n    \n    //如果下一个不同，那么k就变成next[k]，注意next[k]\n    for (int q = 1; q <= len - 1; q++) {\n        while (k > -1 && str[k + 1] != str[q]) { //是小于k的，无论k取任何值。\n            k = next[k];                         //往前回溯\n        }\n        if (str[k + 1] == str[q]) {              //如果相同，k++\n            k ++;\n        }\n        next[q] = k;      //这个是把算的k的值（就是相同的最大前缀和最大后缀长）赋给next[q]\n\t}\n}\n```\n\n\n\n首先我们看第一个while循环，它到底干了什么。\n\n在此之前，我们先回到原程序。原程序里有一个大的**for()**循环，那这个for()循环是干嘛的？\n\n这个for循环就是计算next[0]，next[1],…next[q]…的值。\n\n里面最后一句next[q]=k就是说明每次循环结束，我们已经计算了ptr的前(q+1)个字母组成的子串的“**相同的最长前缀和最长后缀的长度**”。（这句话前面已经解释了！） 这个“**长度**”就是k。\n\n好，到此为止，假设循环进行到 第 q 次，即已经计算了next[q]，我们是怎么计算next[q+1]呢？\n\n比如我们已经知道**ababab**，q=4时，next[4]=2（k=2，表示该字符串的前5个字母组成的子串**ababa**存在**相同的最长前缀和最长后缀的长度**是3，所以k=2,next[4]=2。这个结果可以理解成我们自己观察算的，也可以理解成程序自己算的，这不是重点，重点是程序根据目前的结果怎么算next[5]的）.，那么对于字符串**ababab**，我们计算next[5]的时候，此时q=5, k=2（上一步循环结束后的结果）。那么我们需要比较的是str[k+1]和str[q]是否相等，其实就是str[1]和str[5]是否相等！，为啥从k+1比较呢，因为上一次循环中，**我们已经保证了str[k]和str[q] (注意这个q是上次循环的q)是相等的**（这句话自己想想，很容易理解），所以到本次循环，我们直接比较str[k+1]和str[q]是否相等（这个q是本次循环的q）。 \n\n\n如果相等，那么跳出while()，进入if()，k=k+1，接着next[q]=k。即对于**ababab**，我们会得出next[5]=3。 这是程序自己算的，和我们观察的是一样的。 \n\n\n如果不等，我们可以用”**ababac**“描述这种情况。 不等，进入while()里面，进行k=next[k]，这句话是说，在str[k + 1] != str[q]的情况下，我们往前找一个k，使str[k + 1]==str[q]，是往前一个一个找呢，还是有更快的找法呢？。程序给出了一种更快的找法，那就是 k = next[k]。 程序的意思是说，一旦str[k + 1] != str[q]，即在后缀里面找不到时，我是可以直接跳过中间一段，跑到前缀里面找，**next[k]**就是**相同的最长前缀和最长后缀的长度**。所以，k=next[k]就变成，k=next[2]，即k=0。此时再比较str[0+1]和str[5]是否相等，不等，则k=next[0]=-1。跳出循环。\n\n### 完整的KMP代码\n\n```java\npublic static int KMP(String s, String p) {\n    int slen = s.length();\n    int plen = p.length();\n    char[] str = s.toCharArray();\n    char[] ptr = p.toCharArray();\n    int[] next = new int[plen];\n    cal_next(ptr, next);\n    int k = -1;\n    for (int i = 0; i < slen; i++) {\n        while (k > -1 && ptr[k + 1] != str[i])  //ptr和str不匹配，且k>-1（表示ptr和str有部分匹配）\n            k = next[k];                        //往前回溯\n        if (ptr[k + 1] == str[i])\n            k ++;\n        if (k == plen - 1) {            //说明k移动到ptr的最末端\n            return i - plen + 1;        //返回相应的位置\n        }\n    }\n    return -1;\n}\n\npublic static void cal_next(char[] str, int[] next) {\n    int len = str.length;\n    next[0] = -1;         //next[0]初始化为-1，-1表示不存在相同的最大前缀和最大后缀\n    int k = -1;           //k初始化为-1\n    \n    //如果下一个不同，那么k就变成next[k]，注意next[k]\n    for (int q = 1; q <= len - 1; q++) {\n        while (k > -1 && str[k + 1] != str[q]) { //是小于k的，无论k取任何值。\n            k = next[k];                         //往前回溯\n        }\n        if (str[k + 1] == str[q]) {              //如果相同，k++\n            k ++;\n        }\n        next[q] = k;      //这个是把算的k的值（就是相同的最大前缀和最大后缀长）赋给next[q]\n}\n\npublic static void main(String[] args) {\n    long start = System.currentTimeMillis();\n    String full = \"BBC ABCDAB ABCDABCDABDE\";\n    String par = \"ABCDABD\";\n    int res = KMP(full,par);\n    //int res = full.indexOf(par);\n    System.out.println(res+\",\"+(System.currentTimeMillis() - start)+\"ms\");\n}\n```\n\n时间复杂度O(n)\n\n## indexOf（）\n\n流程：\n\n1、首先，字符串\"BBC ABCDAB ABCDABCDABDE\"的第一个字符与搜索词\"ABCDABD\"的第一个字符，进行比较。因为B与A不匹配，所以搜索词整体后移一位，因为B与A不匹配，搜索词整体再往后移\n\n2、直到字符串有一个字符，与搜索词的第一个字符相同为止。\n\n3、接着比较字符串和搜索词的下一个字符，一只比对到搜索词最后一个字符完成。\n\n- 如果全部匹配，则返回搜索词第一个字符对应的字符串中字符的下标。\n- 如果某个字符不匹配，执行下一步。\n\n4、这时，和KMP不同的是，不再利用Next数组，而是将搜索词整个后移一位，再从头逐个比较。\n\nindexOf和KMP实现同样的功能，但是用原始暴力的方法求解，所以直接来看看源码：\n\n\n```java\n/**\n* Code shared by String and StringBuffer to do searches. The\n* source is the character array being searched, and the target\n* is the string being searched for.\n*\n* @param   source       the characters being searched.\n* @param   sourceOffset offset of the source string.\n* @param   sourceCount  count of the source string.\n* @param   target       the characters being searched for.\n* @param   targetOffset offset of the target string.\n* @param   targetCount  count of the target string.\n* @param   fromIndex    the index to begin searching from.\n*/\nstatic int indexOf(char[] source, int sourceOffset, int sourceCount,\n        char[] target, int targetOffset, int targetCount,\n        int fromIndex) {\n    if (fromIndex >= sourceCount) {\n        return (targetCount == 0 ? sourceCount : -1);\n    }\n    if (fromIndex < 0) {\n        fromIndex = 0;\n    }\n    if (targetCount == 0) {\n        return fromIndex;\n    }\n\n    char first = target[targetOffset];\n    //找到遍历的最大位置\n    int max = sourceOffset + (sourceCount - targetCount);\n\n    for (int i = sourceOffset + fromIndex; i <= max; i++) {\n        /* Look for first character. */\n        if (source[i] != first) {\n            while (++i <= max && source[i] != first);\n        }\n\n        /* Found first character, now look at the rest of v2 */\n        if (i <= max) {\n            int j = i + 1;\n            int end = j + targetCount - 1;\n            for (int k = targetOffset + 1; j < end && source[j]\n                    == target[k]; j++, k++);\n\t\t\t//完全符合时返回坐标\n            if (j == end) {\n                /* Found whole string. */\n                return i - sourceOffset;\n            }\n        }\n    }\n    return -1;\n}\n```\n时间复杂度O(n*m)\n\n### 总结：\n\n可能是JDK的编写者们认为大多数情况下，字符串都不长，使用原始实现可能代价更低。在我测试过程中，使用indexOf方法时要比KMP算法要快一点。KMP算法对与超长字符串子匹配速度上是优于IndexOf的。\n\n因为KMP算法需要预先计算处理来获得辅助数组，需要一定的时间和空间，这可能在短字符串查找中相比较原始实现耗费更大的代价。而且一般大字符串查找时，程序员们也会使用其它特定的数据结构，查找起来更简单。这有点类似于排除特定情况下的快速排序了。不同环境选择不同算法。\n\n> 参考：[经典算法-KMP](https://blog.csdn.net/starstar1992/article/details/54913261/)","slug":"2017-09-03-kmp","published":1,"updated":"2019-05-05T12:31:03.453Z","comments":1,"photos":[],"link":"","_id":"cjvayvwg7001sm46aj5y7ilbl","content":"<h1 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h1><p>Kmp和indexOf 都是用于匹配字符串，如果匹配到目标字符串则返回首个字符下标，如果匹配到则返回-1</p>\n<p>之前偶然打开Java String.indexOf的源码以为会很高大上，结果发现indexOf中的源码是暴力匹配字符串的…</p>\n<p>所以准备对比一下这两个方法，不过还是先梳理一下这两个算法的源码。</p>\n<h2 id=\"KMP\"><a href=\"#KMP\" class=\"headerlink\" title=\"KMP\"></a>KMP</h2><p>举例来说，有一个字符串”BBC ABCDAB ABCDABCDABDE”，我想知道，里面是否包含另一个字符串”ABCDABD”</p>\n<h3 id=\"KMP算法流程：\"><a href=\"#KMP算法流程：\" class=\"headerlink\" title=\"KMP算法流程：\"></a>KMP算法流程：</h3><p>1、首先，字符串”BBC ABCDAB ABCDABCDABDE”的第一个字符与搜索词”ABCDABD”的第一个字符，进行比较。因为B与A不匹配，所以搜索词整体后移一位，因为B与A不匹配，搜索词整体再往后移</p>\n<p>2、直到字符串有一个字符，与搜索词的第一个字符相同为止。</p>\n<p>3、接着比较字符串和搜索词的下一个字符，一只比对到搜索词最后一个字符完成。</p>\n<ul>\n<li>如果全部匹配，则返回搜索词第一个字符对应的字符串中字符的下标。(下图index)</li>\n<li>如果某个字符不匹配，执行下一步。</li>\n</ul>\n<p><img src=\"http://epoch-night.oss-cn-hangzhou.aliyuncs.com/PostImg/kmp-accept.png\" alt=\"kmp\"></p>\n<p>4、这时，最自然的反应是，将搜索词整个后移一位，再从头逐个比较。这样做虽然可行，但是效率很差，因为你要把”搜索位置”移到已经比较过的位置，重比一遍。</p>\n<p>一个基本事实是，当空格与D不匹配时，你其实知道前面六个字符是”ABCDAB”。KMP算法的想法是，设法利用这个已知信息，不要把”搜索位置”移回已经比较过的位置，继续把它向后移，这样就提高了效率。</p>\n<p>5、怎么做到这一点呢？可以针对搜索词，算出一张《部分匹配表》（Partial Match Table）。这张表是如何产生的，后面再介绍，这里知道如何使用即可。</p>\n<p>6、已知空格与D不匹配时，前面六个字符”ABCDAB”是匹配的。查表可知，最后一个匹配字符B对应的”部分匹配值”为2，因此按照下面的公式算出向后移动的位数：</p>\n<blockquote>\n<p>移动位数 = 已匹配的字符数 - 对应的部分匹配值</p>\n</blockquote>\n<p>因为 6 - 2 等于4，所以将搜索词向后移动4位。</p>\n<p>7、逐位比较，直到搜索词的最后一位，发现完全匹配，于是搜索完成。</p>\n<h3 id=\"部分匹配表（next数组）：\"><a href=\"#部分匹配表（next数组）：\" class=\"headerlink\" title=\"部分匹配表（next数组）：\"></a>部分匹配表（next数组）：</h3><p>首先，要了解两个概念：”前缀”和”后缀”。 “前缀”指除了最后一个字符以外，一个字符串的全部头部组合；”后缀”指除了第一个字符以外，一个字符串的全部尾部组合。</p>\n<p>“部分匹配值”就是”前缀”和”后缀”的最长的共有元素的长度。以”ABCDABD”为例</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">－　<span class=\"string\">\"A\"</span>的前缀和后缀都为空集，共有元素的长度为0；</span><br><span class=\"line\"></span><br><span class=\"line\">－　<span class=\"string\">\"AB\"</span>的前缀为[A]，后缀为[B]，共有元素的长度为0；</span><br><span class=\"line\"></span><br><span class=\"line\">－　<span class=\"string\">\"ABC\"</span>的前缀为[A, AB]，后缀为[BC, C]，共有元素的长度0；</span><br><span class=\"line\"></span><br><span class=\"line\">－　<span class=\"string\">\"ABCD\"</span>的前缀为[A, AB, ABC]，后缀为[BCD, CD, D]，共有元素的长度为0；</span><br><span class=\"line\"></span><br><span class=\"line\">－　<span class=\"string\">\"ABCDA\"</span>的前缀为[A, AB, ABC, ABCD]，后缀为[BCDA, CDA, DA, A]，共有元素为<span class=\"string\">\"A\"</span>，长度为1；</span><br><span class=\"line\"></span><br><span class=\"line\">－　<span class=\"string\">\"ABCDAB\"</span>的前缀为[A, AB, ABC, ABCD, ABCDA]，后缀为[BCDAB, CDAB, DAB, AB, B]，共有元素为<span class=\"string\">\"AB\"</span>，长度为2；</span><br><span class=\"line\"></span><br><span class=\"line\">－　<span class=\"string\">\"ABCDABD\"</span>的前缀为[A, AB, ABC, ABCD, ABCDA, ABCDAB]，后缀为[BCDABD, CDABD, DABD, ABD, BD, D]，共有元素的长度为0。</span><br></pre></td></tr></table></figure>\n<p>　　</p>\n<p>“部分匹配”的实质是，有时候，字符串头部和尾部会有重复。比如，”ABCDAB”之中有两个”AB”，那么它的”部分匹配值”就是2（”AB”的长度）。搜索词移动的时候，第一个”AB”向后移动4位（字符串长度-部分匹配值），就可以来到第二个”AB”的位置。</p>\n<h3 id=\"求解Next数组\"><a href=\"#求解Next数组\" class=\"headerlink\" title=\"求解Next数组\"></a>求解Next数组</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">cal_next</span><span class=\"params\">(<span class=\"keyword\">char</span>[] str, <span class=\"keyword\">int</span>[] next)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = str.length;</span><br><span class=\"line\">    next[<span class=\"number\">0</span>] = -<span class=\"number\">1</span>;         <span class=\"comment\">//next[0]初始化为-1，-1表示不存在相同的最大前缀和最大后缀</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> k = -<span class=\"number\">1</span>;           <span class=\"comment\">//k初始化为-1</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//如果下一个不同，那么k就变成next[k]，注意next[k]</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> q = <span class=\"number\">1</span>; q &lt;= len - <span class=\"number\">1</span>; q++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (k &gt; -<span class=\"number\">1</span> &amp;&amp; str[k + <span class=\"number\">1</span>] != str[q]) &#123; <span class=\"comment\">//是小于k的，无论k取任何值。</span></span><br><span class=\"line\">            k = next[k];                         <span class=\"comment\">//往前回溯</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (str[k + <span class=\"number\">1</span>] == str[q]) &#123;              <span class=\"comment\">//如果相同，k++</span></span><br><span class=\"line\">            k ++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        next[q] = k;      <span class=\"comment\">//这个是把算的k的值（就是相同的最大前缀和最大后缀长）赋给next[q]</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先我们看第一个while循环，它到底干了什么。</p>\n<p>在此之前，我们先回到原程序。原程序里有一个大的<strong>for()</strong>循环，那这个for()循环是干嘛的？</p>\n<p>这个for循环就是计算next[0]，next[1],…next[q]…的值。</p>\n<p>里面最后一句next[q]=k就是说明每次循环结束，我们已经计算了ptr的前(q+1)个字母组成的子串的“<strong>相同的最长前缀和最长后缀的长度</strong>”。（这句话前面已经解释了！） 这个“<strong>长度</strong>”就是k。</p>\n<p>好，到此为止，假设循环进行到 第 q 次，即已经计算了next[q]，我们是怎么计算next[q+1]呢？</p>\n<p>比如我们已经知道<strong>ababab</strong>，q=4时，next[4]=2（k=2，表示该字符串的前5个字母组成的子串<strong>ababa</strong>存在<strong>相同的最长前缀和最长后缀的长度</strong>是3，所以k=2,next[4]=2。这个结果可以理解成我们自己观察算的，也可以理解成程序自己算的，这不是重点，重点是程序根据目前的结果怎么算next[5]的）.，那么对于字符串<strong>ababab</strong>，我们计算next[5]的时候，此时q=5, k=2（上一步循环结束后的结果）。那么我们需要比较的是str[k+1]和str[q]是否相等，其实就是str[1]和str[5]是否相等！，为啥从k+1比较呢，因为上一次循环中，<strong>我们已经保证了str[k]和str[q] (注意这个q是上次循环的q)是相等的</strong>（这句话自己想想，很容易理解），所以到本次循环，我们直接比较str[k+1]和str[q]是否相等（这个q是本次循环的q）。 </p>\n<p>如果相等，那么跳出while()，进入if()，k=k+1，接着next[q]=k。即对于<strong>ababab</strong>，我们会得出next[5]=3。 这是程序自己算的，和我们观察的是一样的。 </p>\n<p>如果不等，我们可以用”<strong>ababac</strong>“描述这种情况。 不等，进入while()里面，进行k=next[k]，这句话是说，在str[k + 1] != str[q]的情况下，我们往前找一个k，使str[k + 1]==str[q]，是往前一个一个找呢，还是有更快的找法呢？。程序给出了一种更快的找法，那就是 k = next[k]。 程序的意思是说，一旦str[k + 1] != str[q]，即在后缀里面找不到时，我是可以直接跳过中间一段，跑到前缀里面找，<strong>next[k]</strong>就是<strong>相同的最长前缀和最长后缀的长度</strong>。所以，k=next[k]就变成，k=next[2]，即k=0。此时再比较str[0+1]和str[5]是否相等，不等，则k=next[0]=-1。跳出循环。</p>\n<h3 id=\"完整的KMP代码\"><a href=\"#完整的KMP代码\" class=\"headerlink\" title=\"完整的KMP代码\"></a>完整的KMP代码</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">KMP</span><span class=\"params\">(String s, String p)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> slen = s.length();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> plen = p.length();</span><br><span class=\"line\">    <span class=\"keyword\">char</span>[] str = s.toCharArray();</span><br><span class=\"line\">    <span class=\"keyword\">char</span>[] ptr = p.toCharArray();</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] next = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[plen];</span><br><span class=\"line\">    cal_next(ptr, next);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> k = -<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; slen; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (k &gt; -<span class=\"number\">1</span> &amp;&amp; ptr[k + <span class=\"number\">1</span>] != str[i])  <span class=\"comment\">//ptr和str不匹配，且k&gt;-1（表示ptr和str有部分匹配）</span></span><br><span class=\"line\">            k = next[k];                        <span class=\"comment\">//往前回溯</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ptr[k + <span class=\"number\">1</span>] == str[i])</span><br><span class=\"line\">            k ++;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (k == plen - <span class=\"number\">1</span>) &#123;            <span class=\"comment\">//说明k移动到ptr的最末端</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> i - plen + <span class=\"number\">1</span>;        <span class=\"comment\">//返回相应的位置</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">cal_next</span><span class=\"params\">(<span class=\"keyword\">char</span>[] str, <span class=\"keyword\">int</span>[] next)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = str.length;</span><br><span class=\"line\">    next[<span class=\"number\">0</span>] = -<span class=\"number\">1</span>;         <span class=\"comment\">//next[0]初始化为-1，-1表示不存在相同的最大前缀和最大后缀</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> k = -<span class=\"number\">1</span>;           <span class=\"comment\">//k初始化为-1</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//如果下一个不同，那么k就变成next[k]，注意next[k]</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> q = <span class=\"number\">1</span>; q &lt;= len - <span class=\"number\">1</span>; q++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (k &gt; -<span class=\"number\">1</span> &amp;&amp; str[k + <span class=\"number\">1</span>] != str[q]) &#123; <span class=\"comment\">//是小于k的，无论k取任何值。</span></span><br><span class=\"line\">            k = next[k];                         <span class=\"comment\">//往前回溯</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (str[k + <span class=\"number\">1</span>] == str[q]) &#123;              <span class=\"comment\">//如果相同，k++</span></span><br><span class=\"line\">            k ++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        next[q] = k;      <span class=\"comment\">//这个是把算的k的值（就是相同的最大前缀和最大后缀长）赋给next[q]</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> start = System.currentTimeMillis();</span><br><span class=\"line\">    String full = <span class=\"string\">\"BBC ABCDAB ABCDABCDABDE\"</span>;</span><br><span class=\"line\">    String par = <span class=\"string\">\"ABCDABD\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = KMP(full,par);</span><br><span class=\"line\">    <span class=\"comment\">//int res = full.indexOf(par);</span></span><br><span class=\"line\">    System.out.println(res+<span class=\"string\">\",\"</span>+(System.currentTimeMillis() - start)+<span class=\"string\">\"ms\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>时间复杂度O(n)</p>\n<h2 id=\"indexOf（）\"><a href=\"#indexOf（）\" class=\"headerlink\" title=\"indexOf（）\"></a>indexOf（）</h2><p>流程：</p>\n<p>1、首先，字符串”BBC ABCDAB ABCDABCDABDE”的第一个字符与搜索词”ABCDABD”的第一个字符，进行比较。因为B与A不匹配，所以搜索词整体后移一位，因为B与A不匹配，搜索词整体再往后移</p>\n<p>2、直到字符串有一个字符，与搜索词的第一个字符相同为止。</p>\n<p>3、接着比较字符串和搜索词的下一个字符，一只比对到搜索词最后一个字符完成。</p>\n<ul>\n<li>如果全部匹配，则返回搜索词第一个字符对应的字符串中字符的下标。</li>\n<li>如果某个字符不匹配，执行下一步。</li>\n</ul>\n<p>4、这时，和KMP不同的是，不再利用Next数组，而是将搜索词整个后移一位，再从头逐个比较。</p>\n<p>indexOf和KMP实现同样的功能，但是用原始暴力的方法求解，所以直接来看看源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* Code shared by String and StringBuffer to do searches. The</span></span><br><span class=\"line\"><span class=\"comment\">* source is the character array being searched, and the target</span></span><br><span class=\"line\"><span class=\"comment\">* is the string being searched for.</span></span><br><span class=\"line\"><span class=\"comment\">*</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@param</span>   source       the characters being searched.</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@param</span>   sourceOffset offset of the source string.</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@param</span>   sourceCount  count of the source string.</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@param</span>   target       the characters being searched for.</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@param</span>   targetOffset offset of the target string.</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@param</span>   targetCount  count of the target string.</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@param</span>   fromIndex    the index to begin searching from.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">indexOf</span><span class=\"params\">(<span class=\"keyword\">char</span>[] source, <span class=\"keyword\">int</span> sourceOffset, <span class=\"keyword\">int</span> sourceCount,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        <span class=\"keyword\">char</span>[] target, <span class=\"keyword\">int</span> targetOffset, <span class=\"keyword\">int</span> targetCount,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        <span class=\"keyword\">int</span> fromIndex)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fromIndex &gt;= sourceCount) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (targetCount == <span class=\"number\">0</span> ? sourceCount : -<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fromIndex &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        fromIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (targetCount == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fromIndex;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">char</span> first = target[targetOffset];</span><br><span class=\"line\">    <span class=\"comment\">//找到遍历的最大位置</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> max = sourceOffset + (sourceCount - targetCount);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = sourceOffset + fromIndex; i &lt;= max; i++) &#123;</span><br><span class=\"line\">        <span class=\"comment\">/* Look for first character. */</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (source[i] != first) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (++i &lt;= max &amp;&amp; source[i] != first);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/* Found first character, now look at the rest of v2 */</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i &lt;= max) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> j = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> end = j + targetCount - <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = targetOffset + <span class=\"number\">1</span>; j &lt; end &amp;&amp; source[j]</span><br><span class=\"line\">                    == target[k]; j++, k++);</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//完全符合时返回坐标</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (j == end) &#123;</span><br><span class=\"line\">                <span class=\"comment\">/* Found whole string. */</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> i - sourceOffset;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>时间复杂度O(n*m)</p>\n<h3 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h3><p>可能是JDK的编写者们认为大多数情况下，字符串都不长，使用原始实现可能代价更低。在我测试过程中，使用indexOf方法时要比KMP算法要快一点。KMP算法对与超长字符串子匹配速度上是优于IndexOf的。</p>\n<p>因为KMP算法需要预先计算处理来获得辅助数组，需要一定的时间和空间，这可能在短字符串查找中相比较原始实现耗费更大的代价。而且一般大字符串查找时，程序员们也会使用其它特定的数据结构，查找起来更简单。这有点类似于排除特定情况下的快速排序了。不同环境选择不同算法。</p>\n<blockquote>\n<p>参考：<a href=\"https://blog.csdn.net/starstar1992/article/details/54913261/\" target=\"_blank\" rel=\"noopener\">经典算法-KMP</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h1><p>Kmp和indexOf 都是用于匹配字符串，如果匹配到目标字符串则返回首个字符下标，如果匹配到则返回-1</p>\n<p>之前偶然打开Java String.indexOf的源码以为会很高大上，结果发现indexOf中的源码是暴力匹配字符串的…</p>\n<p>所以准备对比一下这两个方法，不过还是先梳理一下这两个算法的源码。</p>\n<h2 id=\"KMP\"><a href=\"#KMP\" class=\"headerlink\" title=\"KMP\"></a>KMP</h2><p>举例来说，有一个字符串”BBC ABCDAB ABCDABCDABDE”，我想知道，里面是否包含另一个字符串”ABCDABD”</p>\n<h3 id=\"KMP算法流程：\"><a href=\"#KMP算法流程：\" class=\"headerlink\" title=\"KMP算法流程：\"></a>KMP算法流程：</h3><p>1、首先，字符串”BBC ABCDAB ABCDABCDABDE”的第一个字符与搜索词”ABCDABD”的第一个字符，进行比较。因为B与A不匹配，所以搜索词整体后移一位，因为B与A不匹配，搜索词整体再往后移</p>\n<p>2、直到字符串有一个字符，与搜索词的第一个字符相同为止。</p>\n<p>3、接着比较字符串和搜索词的下一个字符，一只比对到搜索词最后一个字符完成。</p>\n<ul>\n<li>如果全部匹配，则返回搜索词第一个字符对应的字符串中字符的下标。(下图index)</li>\n<li>如果某个字符不匹配，执行下一步。</li>\n</ul>\n<p><img src=\"http://epoch-night.oss-cn-hangzhou.aliyuncs.com/PostImg/kmp-accept.png\" alt=\"kmp\"></p>\n<p>4、这时，最自然的反应是，将搜索词整个后移一位，再从头逐个比较。这样做虽然可行，但是效率很差，因为你要把”搜索位置”移到已经比较过的位置，重比一遍。</p>\n<p>一个基本事实是，当空格与D不匹配时，你其实知道前面六个字符是”ABCDAB”。KMP算法的想法是，设法利用这个已知信息，不要把”搜索位置”移回已经比较过的位置，继续把它向后移，这样就提高了效率。</p>\n<p>5、怎么做到这一点呢？可以针对搜索词，算出一张《部分匹配表》（Partial Match Table）。这张表是如何产生的，后面再介绍，这里知道如何使用即可。</p>\n<p>6、已知空格与D不匹配时，前面六个字符”ABCDAB”是匹配的。查表可知，最后一个匹配字符B对应的”部分匹配值”为2，因此按照下面的公式算出向后移动的位数：</p>\n<blockquote>\n<p>移动位数 = 已匹配的字符数 - 对应的部分匹配值</p>\n</blockquote>\n<p>因为 6 - 2 等于4，所以将搜索词向后移动4位。</p>\n<p>7、逐位比较，直到搜索词的最后一位，发现完全匹配，于是搜索完成。</p>\n<h3 id=\"部分匹配表（next数组）：\"><a href=\"#部分匹配表（next数组）：\" class=\"headerlink\" title=\"部分匹配表（next数组）：\"></a>部分匹配表（next数组）：</h3><p>首先，要了解两个概念：”前缀”和”后缀”。 “前缀”指除了最后一个字符以外，一个字符串的全部头部组合；”后缀”指除了第一个字符以外，一个字符串的全部尾部组合。</p>\n<p>“部分匹配值”就是”前缀”和”后缀”的最长的共有元素的长度。以”ABCDABD”为例</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">－　<span class=\"string\">\"A\"</span>的前缀和后缀都为空集，共有元素的长度为0；</span><br><span class=\"line\"></span><br><span class=\"line\">－　<span class=\"string\">\"AB\"</span>的前缀为[A]，后缀为[B]，共有元素的长度为0；</span><br><span class=\"line\"></span><br><span class=\"line\">－　<span class=\"string\">\"ABC\"</span>的前缀为[A, AB]，后缀为[BC, C]，共有元素的长度0；</span><br><span class=\"line\"></span><br><span class=\"line\">－　<span class=\"string\">\"ABCD\"</span>的前缀为[A, AB, ABC]，后缀为[BCD, CD, D]，共有元素的长度为0；</span><br><span class=\"line\"></span><br><span class=\"line\">－　<span class=\"string\">\"ABCDA\"</span>的前缀为[A, AB, ABC, ABCD]，后缀为[BCDA, CDA, DA, A]，共有元素为<span class=\"string\">\"A\"</span>，长度为1；</span><br><span class=\"line\"></span><br><span class=\"line\">－　<span class=\"string\">\"ABCDAB\"</span>的前缀为[A, AB, ABC, ABCD, ABCDA]，后缀为[BCDAB, CDAB, DAB, AB, B]，共有元素为<span class=\"string\">\"AB\"</span>，长度为2；</span><br><span class=\"line\"></span><br><span class=\"line\">－　<span class=\"string\">\"ABCDABD\"</span>的前缀为[A, AB, ABC, ABCD, ABCDA, ABCDAB]，后缀为[BCDABD, CDABD, DABD, ABD, BD, D]，共有元素的长度为0。</span><br></pre></td></tr></table></figure>\n<p>　　</p>\n<p>“部分匹配”的实质是，有时候，字符串头部和尾部会有重复。比如，”ABCDAB”之中有两个”AB”，那么它的”部分匹配值”就是2（”AB”的长度）。搜索词移动的时候，第一个”AB”向后移动4位（字符串长度-部分匹配值），就可以来到第二个”AB”的位置。</p>\n<h3 id=\"求解Next数组\"><a href=\"#求解Next数组\" class=\"headerlink\" title=\"求解Next数组\"></a>求解Next数组</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">cal_next</span><span class=\"params\">(<span class=\"keyword\">char</span>[] str, <span class=\"keyword\">int</span>[] next)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = str.length;</span><br><span class=\"line\">    next[<span class=\"number\">0</span>] = -<span class=\"number\">1</span>;         <span class=\"comment\">//next[0]初始化为-1，-1表示不存在相同的最大前缀和最大后缀</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> k = -<span class=\"number\">1</span>;           <span class=\"comment\">//k初始化为-1</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//如果下一个不同，那么k就变成next[k]，注意next[k]</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> q = <span class=\"number\">1</span>; q &lt;= len - <span class=\"number\">1</span>; q++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (k &gt; -<span class=\"number\">1</span> &amp;&amp; str[k + <span class=\"number\">1</span>] != str[q]) &#123; <span class=\"comment\">//是小于k的，无论k取任何值。</span></span><br><span class=\"line\">            k = next[k];                         <span class=\"comment\">//往前回溯</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (str[k + <span class=\"number\">1</span>] == str[q]) &#123;              <span class=\"comment\">//如果相同，k++</span></span><br><span class=\"line\">            k ++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        next[q] = k;      <span class=\"comment\">//这个是把算的k的值（就是相同的最大前缀和最大后缀长）赋给next[q]</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先我们看第一个while循环，它到底干了什么。</p>\n<p>在此之前，我们先回到原程序。原程序里有一个大的<strong>for()</strong>循环，那这个for()循环是干嘛的？</p>\n<p>这个for循环就是计算next[0]，next[1],…next[q]…的值。</p>\n<p>里面最后一句next[q]=k就是说明每次循环结束，我们已经计算了ptr的前(q+1)个字母组成的子串的“<strong>相同的最长前缀和最长后缀的长度</strong>”。（这句话前面已经解释了！） 这个“<strong>长度</strong>”就是k。</p>\n<p>好，到此为止，假设循环进行到 第 q 次，即已经计算了next[q]，我们是怎么计算next[q+1]呢？</p>\n<p>比如我们已经知道<strong>ababab</strong>，q=4时，next[4]=2（k=2，表示该字符串的前5个字母组成的子串<strong>ababa</strong>存在<strong>相同的最长前缀和最长后缀的长度</strong>是3，所以k=2,next[4]=2。这个结果可以理解成我们自己观察算的，也可以理解成程序自己算的，这不是重点，重点是程序根据目前的结果怎么算next[5]的）.，那么对于字符串<strong>ababab</strong>，我们计算next[5]的时候，此时q=5, k=2（上一步循环结束后的结果）。那么我们需要比较的是str[k+1]和str[q]是否相等，其实就是str[1]和str[5]是否相等！，为啥从k+1比较呢，因为上一次循环中，<strong>我们已经保证了str[k]和str[q] (注意这个q是上次循环的q)是相等的</strong>（这句话自己想想，很容易理解），所以到本次循环，我们直接比较str[k+1]和str[q]是否相等（这个q是本次循环的q）。 </p>\n<p>如果相等，那么跳出while()，进入if()，k=k+1，接着next[q]=k。即对于<strong>ababab</strong>，我们会得出next[5]=3。 这是程序自己算的，和我们观察的是一样的。 </p>\n<p>如果不等，我们可以用”<strong>ababac</strong>“描述这种情况。 不等，进入while()里面，进行k=next[k]，这句话是说，在str[k + 1] != str[q]的情况下，我们往前找一个k，使str[k + 1]==str[q]，是往前一个一个找呢，还是有更快的找法呢？。程序给出了一种更快的找法，那就是 k = next[k]。 程序的意思是说，一旦str[k + 1] != str[q]，即在后缀里面找不到时，我是可以直接跳过中间一段，跑到前缀里面找，<strong>next[k]</strong>就是<strong>相同的最长前缀和最长后缀的长度</strong>。所以，k=next[k]就变成，k=next[2]，即k=0。此时再比较str[0+1]和str[5]是否相等，不等，则k=next[0]=-1。跳出循环。</p>\n<h3 id=\"完整的KMP代码\"><a href=\"#完整的KMP代码\" class=\"headerlink\" title=\"完整的KMP代码\"></a>完整的KMP代码</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">KMP</span><span class=\"params\">(String s, String p)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> slen = s.length();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> plen = p.length();</span><br><span class=\"line\">    <span class=\"keyword\">char</span>[] str = s.toCharArray();</span><br><span class=\"line\">    <span class=\"keyword\">char</span>[] ptr = p.toCharArray();</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] next = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[plen];</span><br><span class=\"line\">    cal_next(ptr, next);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> k = -<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; slen; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (k &gt; -<span class=\"number\">1</span> &amp;&amp; ptr[k + <span class=\"number\">1</span>] != str[i])  <span class=\"comment\">//ptr和str不匹配，且k&gt;-1（表示ptr和str有部分匹配）</span></span><br><span class=\"line\">            k = next[k];                        <span class=\"comment\">//往前回溯</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ptr[k + <span class=\"number\">1</span>] == str[i])</span><br><span class=\"line\">            k ++;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (k == plen - <span class=\"number\">1</span>) &#123;            <span class=\"comment\">//说明k移动到ptr的最末端</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> i - plen + <span class=\"number\">1</span>;        <span class=\"comment\">//返回相应的位置</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">cal_next</span><span class=\"params\">(<span class=\"keyword\">char</span>[] str, <span class=\"keyword\">int</span>[] next)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = str.length;</span><br><span class=\"line\">    next[<span class=\"number\">0</span>] = -<span class=\"number\">1</span>;         <span class=\"comment\">//next[0]初始化为-1，-1表示不存在相同的最大前缀和最大后缀</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> k = -<span class=\"number\">1</span>;           <span class=\"comment\">//k初始化为-1</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//如果下一个不同，那么k就变成next[k]，注意next[k]</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> q = <span class=\"number\">1</span>; q &lt;= len - <span class=\"number\">1</span>; q++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (k &gt; -<span class=\"number\">1</span> &amp;&amp; str[k + <span class=\"number\">1</span>] != str[q]) &#123; <span class=\"comment\">//是小于k的，无论k取任何值。</span></span><br><span class=\"line\">            k = next[k];                         <span class=\"comment\">//往前回溯</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (str[k + <span class=\"number\">1</span>] == str[q]) &#123;              <span class=\"comment\">//如果相同，k++</span></span><br><span class=\"line\">            k ++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        next[q] = k;      <span class=\"comment\">//这个是把算的k的值（就是相同的最大前缀和最大后缀长）赋给next[q]</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> start = System.currentTimeMillis();</span><br><span class=\"line\">    String full = <span class=\"string\">\"BBC ABCDAB ABCDABCDABDE\"</span>;</span><br><span class=\"line\">    String par = <span class=\"string\">\"ABCDABD\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> res = KMP(full,par);</span><br><span class=\"line\">    <span class=\"comment\">//int res = full.indexOf(par);</span></span><br><span class=\"line\">    System.out.println(res+<span class=\"string\">\",\"</span>+(System.currentTimeMillis() - start)+<span class=\"string\">\"ms\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>时间复杂度O(n)</p>\n<h2 id=\"indexOf（）\"><a href=\"#indexOf（）\" class=\"headerlink\" title=\"indexOf（）\"></a>indexOf（）</h2><p>流程：</p>\n<p>1、首先，字符串”BBC ABCDAB ABCDABCDABDE”的第一个字符与搜索词”ABCDABD”的第一个字符，进行比较。因为B与A不匹配，所以搜索词整体后移一位，因为B与A不匹配，搜索词整体再往后移</p>\n<p>2、直到字符串有一个字符，与搜索词的第一个字符相同为止。</p>\n<p>3、接着比较字符串和搜索词的下一个字符，一只比对到搜索词最后一个字符完成。</p>\n<ul>\n<li>如果全部匹配，则返回搜索词第一个字符对应的字符串中字符的下标。</li>\n<li>如果某个字符不匹配，执行下一步。</li>\n</ul>\n<p>4、这时，和KMP不同的是，不再利用Next数组，而是将搜索词整个后移一位，再从头逐个比较。</p>\n<p>indexOf和KMP实现同样的功能，但是用原始暴力的方法求解，所以直接来看看源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* Code shared by String and StringBuffer to do searches. The</span></span><br><span class=\"line\"><span class=\"comment\">* source is the character array being searched, and the target</span></span><br><span class=\"line\"><span class=\"comment\">* is the string being searched for.</span></span><br><span class=\"line\"><span class=\"comment\">*</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@param</span>   source       the characters being searched.</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@param</span>   sourceOffset offset of the source string.</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@param</span>   sourceCount  count of the source string.</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@param</span>   target       the characters being searched for.</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@param</span>   targetOffset offset of the target string.</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@param</span>   targetCount  count of the target string.</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@param</span>   fromIndex    the index to begin searching from.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">indexOf</span><span class=\"params\">(<span class=\"keyword\">char</span>[] source, <span class=\"keyword\">int</span> sourceOffset, <span class=\"keyword\">int</span> sourceCount,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        <span class=\"keyword\">char</span>[] target, <span class=\"keyword\">int</span> targetOffset, <span class=\"keyword\">int</span> targetCount,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        <span class=\"keyword\">int</span> fromIndex)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fromIndex &gt;= sourceCount) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (targetCount == <span class=\"number\">0</span> ? sourceCount : -<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fromIndex &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        fromIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (targetCount == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fromIndex;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">char</span> first = target[targetOffset];</span><br><span class=\"line\">    <span class=\"comment\">//找到遍历的最大位置</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> max = sourceOffset + (sourceCount - targetCount);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = sourceOffset + fromIndex; i &lt;= max; i++) &#123;</span><br><span class=\"line\">        <span class=\"comment\">/* Look for first character. */</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (source[i] != first) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (++i &lt;= max &amp;&amp; source[i] != first);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/* Found first character, now look at the rest of v2 */</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i &lt;= max) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> j = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> end = j + targetCount - <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = targetOffset + <span class=\"number\">1</span>; j &lt; end &amp;&amp; source[j]</span><br><span class=\"line\">                    == target[k]; j++, k++);</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//完全符合时返回坐标</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (j == end) &#123;</span><br><span class=\"line\">                <span class=\"comment\">/* Found whole string. */</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> i - sourceOffset;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>时间复杂度O(n*m)</p>\n<h3 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h3><p>可能是JDK的编写者们认为大多数情况下，字符串都不长，使用原始实现可能代价更低。在我测试过程中，使用indexOf方法时要比KMP算法要快一点。KMP算法对与超长字符串子匹配速度上是优于IndexOf的。</p>\n<p>因为KMP算法需要预先计算处理来获得辅助数组，需要一定的时间和空间，这可能在短字符串查找中相比较原始实现耗费更大的代价。而且一般大字符串查找时，程序员们也会使用其它特定的数据结构，查找起来更简单。这有点类似于排除特定情况下的快速排序了。不同环境选择不同算法。</p>\n<blockquote>\n<p>参考：<a href=\"https://blog.csdn.net/starstar1992/article/details/54913261/\" target=\"_blank\" rel=\"noopener\">经典算法-KMP</a></p>\n</blockquote>\n"},{"layout":"post","title":"Spring | AbstractApplicationContext refresh()方法源码解析","date":"2017-11-06T13:13:00.000Z","author":"Gubaidan","header-img":"/Header/hero@2x.jpg","cdn":"header-on","_content":"\n# 内部工作机制\n\nSpring的 AbstractApplicationContext 是ApplicationContext 接口的抽象实现类，该抽象类中的refresh（）方法定义了Spring容器在加载配置文件之后的处理过程。即整个IOC容器的启动过程。\n\n```java\npublic void refresh() throws BeansException, IllegalStateException {\n\tsynchronized (this.startupShutdownMonitor) {\n\t// 准备上下文刷新，准备此上下文以进行刷新，设置其启动日期和是否正在刷新的,\n\t//标志以及验证标记为必需的所有属性是否可解析等。\n\tprepareRefresh();\n\n\t// 告诉子类刷新内部bean工厂，并返回一个ConfigurableListableBeanFactory实例,\n\t//在这一步里，Spring将配置文件的信息装入容器的BeanDefintion，此时Bean还未初始化。\n\tConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();\n\n\t// 让当前这个beanfactory接手当前上下文，包括设置类加载器（setBeanClassLoader）,\n\t//设置后置处理器（addBeanPostProcessor），BeanFactory接口不在普通工厂中注册为可解析类型。\n\tprepareBeanFactory(beanFactory);\n\n\ttry {\n\t\t// 允许在上下文子类中对bean工厂进行后处理。\n\t\tpostProcessBeanFactory(beanFactory);\n\n\t\t//调用工厂后置处理器\n\t\tinvokeBeanFactoryPostProcessors(beanFactory);\n\n\t\t// 注册后置处理器\n\t\tregisterBeanPostProcessors(beanFactory);\n\n\t\t// 初始化消息源\n\t\tinitMessageSource();\n\n\t\t// 初始化上下文事件广播器.\n\t\tinitApplicationEventMulticaster();\n\n\t\t// 初始化其他特殊的Bean，由具体子类实现\n\t\tonRefresh();\n\n\t\t// 检查并注册事件监听器\n\t\tregisterListeners();\n\n\t\t// 除了懒加载模式的Bean，其他的Bean全部初始化并且单实例化\n\t\tfinishBeanFactoryInitialization(beanFactory);\n\n\t\t// 发布事件公高，完成容器刷新.\n\t\tfinishRefresh();\n\t}\n\n\tcatch (BeansException ex) {\n\t\tif (logger.isWarnEnabled()) {\n\t\tlogger.warn(\"Exception encountered during context initialization - \" +\n\t\t\t\"cancelling refresh attempt: \" + ex);\n\t\t}\n\n\t\t// 清除已经加载的Bean，避免资源浪费\n\t\tdestroyBeans();\n\n\t\t// 重置刷新标志为false（active = false）\n\t\tcancelRefresh(ex);\n\n\t\t// 发布异常\n\t\tthrow ex;\n\t}\n\n\tfinally {\n\t\t//重置Spring在初始化IOC容器过程中的缓存\n\t\tresetCommonCaches();\n\t}\n\t}\n}\n```\n\n## 相对重要的方法：\n\n### prepareRefresh \n\n```java\nprotected void prepareRefresh() {\n\t// 表示在真正做refresh操作之前需要准备做的事情：\n \n\t// 设置Spring容器的启动时间，撤销关闭状态，开启活跃状态。\n\tthis.startupDate = System.currentTimeMillis();\n\tthis.closed.set(false);\n\tthis.active.set(true);\n \n\tif (logger.isInfoEnabled()) {\n\t\tlogger.info(\"Refreshing \" + this);\n\t}\n \n\t// Initialize any placeholder property sources in the context environment\n\t// 初始化属性源信息,初始化占位符\n\tinitPropertySources();\n \n\t// Validate that all properties marked as required are resolvable\n\t// see ConfigurablePropertyResolver#setRequiredProperties\n\t// 验证环境信息里一些必须存在的属性\n\tgetEnvironment().validateRequiredProperties();\n \n\t// Allow for the collection of early ApplicationEvents,\n\t// to be published once the multicaster is available...\n\tthis.earlyApplicationEvents = new LinkedHashSet<>();\n}\n\n```\n\n### obtainFreshBeanFactory\n\n**ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory()**：初始化BeanFactory: 根据配置文件实例化BeanFactory, 在obtainFreshBeanFactory0方法中，首先调用refreshBeanFactory0方法 刷新BeanFactory, 然后调用getBeanFactory0方法获取BeanFactory, 这两个方法都是由具体子类实现的。在这一一步目，Spring将配置文件的信息装入容器的Bean定义注册表(BeanDefinitionRegistry)中，但此时Bean还未初始化。\n\n```java\nprotected ConfigurableListableBeanFactory obtainFreshBeanFactory() {\n\t// 获取刷新Spring上下文的Bean工厂\n\trefreshBeanFactory();\n\tConfigurableListableBeanFactory beanFactory = getBeanFactory();\n\tif (logger.isDebugEnabled()) {\n\t\tlogger.debug(\"Bean factory for \" + getDisplayName() + \": \" + beanFactory);\n\t}\n\treturn beanFactory;\n}\n\n```\n\n因为在一个web项目中测试，所有BeanDefintion 中已经包含了一些基本的Bean，当前classLoader为WebAppClassoader\n\n![beanfactory](http://epoch-night.oss-cn-hangzhou.aliyuncs.com/PostImg/Beanfactory.png)\n\n\n\n### prepareBeanFactory\n\n\n```java\nprotected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) {\n\t// Tell the internal bean factory to use the context's class loader etc.\n\t// 设置classloader(用于加载bean)，设置表达式解析器(解析bean定义中的一些表达式)，添加属性编辑注册器(注册属性编辑器)\n\tbeanFactory.setBeanClassLoader(getClassLoader());\n\tbeanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));\n\tbeanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()));\n \n\t// Configure the bean factory with context callbacks.\n\t// 添加ApplicationContextAwareProcessor这个BeanPostProcessor。取消ResourceLoaderAware、ApplicationEventPublisherAware、MessageSourceAware、ApplicationContextAware、EnvironmentAware这5个接口的自动注入。\n\t// 因为ApplicationContextAwareProcessor把这6个接口的实现工作做了\n\tbeanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));\n\tbeanFactory.ignoreDependencyInterface(EnvironmentAware.class);\n\tbeanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);\n\tbeanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);\n\tbeanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);\n\tbeanFactory.ignoreDependencyInterface(MessageSourceAware.class);\n\tbeanFactory.ignoreDependencyInterface(ApplicationContextAware.class);\n \n\t// BeanFactory interface not registered as resolvable type in a plain factory.\n\t// MessageSource registered (and found for autowiring) as a bean.\n\t// 设置特殊的类型对应的bean。BeanFactory对应刚刚获取的BeanFactory；\n\t// ResourceLoader、ApplicationEventPublisher、ApplicationContext这3个接口对应的bean都设置为当前的Spring容器\n\tbeanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);\n\tbeanFactory.registerResolvableDependency(ResourceLoader.class, this);\n\tbeanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);\n\tbeanFactory.registerResolvableDependency(ApplicationContext.class, this);\n \n\t// Register early post-processor for detecting inner beans as ApplicationListeners.\n\tbeanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));\n \n\t// Detect a LoadTimeWeaver and prepare for weaving, if found.\n\tif (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {\n\t\tbeanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));\n\t\t// Set a temporary ClassLoader for type matching.\n\t\tbeanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));\n\t}\n \n\t// Register default environment beans.\n\t// 注入一些其它信息的bean实例，比如environment、systemProperties等\n\tif (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) {\n\t\tbeanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());\n\t}\n\tif (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) {\n\t\tbeanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());\n\t}\n\tif (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) {\n\t\tbeanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());\n\t}\n}\t\n```\n\n\n\n### invokeBeanFactoryPostProcessors\n\n```java\nprotected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) {\n\tPostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());\n \n\t// Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime\n\t// (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)\n\tif (beanFactory.getTempClassLoader() == null && beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {\n\t\tbeanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));\n\t\tbeanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));\n\t}\n}\n\n```\n\n### invokeBeanFactoryPostProcessors(beanFactory)\n\n调用工厂后处理器:根据反射机制从BeanDefinitionRegistry 中找出所有实现了BeanFactoryPostProcessor接口的Bean,并调用其postProcessBeanFactory0接口方法。\n\n### registerBeanPostProcessors(beanFactory)\n注册Bean后处理器:根据反射机制从BeanDefinitionRegistry 中找出所有实现了BeanPostProcessor 接口的Bean,并将它们注册到容器Bean后处理器的注册表中。\n\n在Spring容器中找出实现了BeanFactoryPostProcessor接口的processor并执行。Spring容器会委托给PostProcessorRegistrationDelegate的invokeBeanFactoryPostProcessors方法执行。\n\n介绍两个接口：\n\n1. BeanFactoryPostProcessor：用来修改Spring容器中已经存在的bean的定义，使用ConfigurableListableBeanFactory对bean进行处理\n2. BeanDefinitionRegistryPostProcessor：继承BeanFactoryPostProcessor，作用跟BeanFactoryPostProcessor一样，只不过是使用BeanDefinitionRegistry对bean进行处理\n\n基于web程序的Spring容器AnnotationConfigEmbeddedWebApplicationContext构造的时候，会初始化内部属性AnnotatedBeanDefinitionReader reader，这个reader构造的时候会在BeanFactory中注册一些post processor，包括BeanPostProcessor和BeanFactoryPostProcessor(比如ConfigurationClassPostProcessor、AutowiredAnnotationBeanPostProcessor)：\n\n```java\nAnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry);\n```\n\n接下来从Spring容器内查找BeanFactoryPostProcessor接口的实现类，然后执行(如果processor已经执行过，则忽略)，这里的查找规则跟上面查找BeanDefinitionRegistryPostProcessor一样，先找PriorityOrdered，然后是Ordered，最后是两者都没。\n\n这里需要说明的是**ConfigurationClassPostProcessor**这个processor是**优先级最高**的被执行的processor(实现了PriorityOrdered接口)。这个ConfigurationClassPostProcessor会去BeanFactory中找出所有有@Configuration注解的bean，然后使用**ConfigurationClassParser**去解析这个类。**ConfigurationClassParser内部有个Map类型的configurationClasses属性用于保存解析的类，ConfigurationClass是一个对要解析的配置类的封装，内部存储了配置类的注解信息、被@Bean注解修饰的方法、@ImportResource注解修饰的信息、ImportBeanDefinitionRegistrar等都存储在这个封装类中**。\n\n这里ConfigurationClassPostProcessor最先被处理还有另外一个原因是如果程序中有自定义的BeanFactoryPostProcessor，那么这个PostProcessor首先得通过ConfigurationClassPostProcessor被解析出来，然后才能被Spring容器找到并执行。(ConfigurationClassPostProcessor不先执行的话，这个Processor是不会被解析的，不会被解析的话也就不会执行了)。\n\n在我们的程序中，只有主类CoreApplication有@Configuration注解(@SpringBootApplication注解带有@Configuration注解)，所以这个配置类会被ConfigurationClassParser的parse(set<BeanDefinitionHolder>)方法解析,这个方法又会递归调用parse(AnnotationMetadate,String)，调用processConfigurationClass(ConfigurationClass)   ConfigurationClass可以有多种创建方法，最终实际调用doProcessConfigurationClass（ConfigurationClass,SourceClass）方法。\n\n\n\n### initMessageSource()\n\n\n初始化消息源:初始化容器的国际化消息资源。初始化应用上下文事件广播器。\n\n\n\n### onRefresh()\n\n\n\n初始化其他特殊的Bean: 这是一个钩子方法，子类可以借助这个方法执行一些特殊的操作，如AbstractRefreshableWebApplicationContext 就使用该方法执行初始化ThemeSource的操作。\n\n\n\n### registerListeners()\n\n\n\n注册事件监听器。\n\n\n\n### finishBeanFactoryInitialization(beanFactory)\n\n\n\n初始化所有单实例的Bean,使用懒加载模式的Bean除外:初始化Bean后，将它们放入Spring容器的缓存池中。\n\n\n\n### finishRefresh()\n\n\n\n发布上下文刷新事件:创建上下文刷新事件，事件广播器负责将这些事件广播到每个注册的事件监听器中。\n\n\n\n### resetCommonCaches()\n\n\n\n重置Spring在初始化IOC容器过程中的缓存。\n\n\n\nresfresh（）方法在一个项目启动时会启动2次，第二次加载时加载Serlvet相关bean和Web监听器等。\n\n\n\n# 流程整理\n\n![process](http://epoch-night.oss-cn-hangzhou.aliyuncs.com/PostImg/process.png)\n\nSpring协调多个组件共同完成整个IOC启动，上图描述了从加载配置文件到实例化一个Bean的过程。\n\n1. Rourelade从存储介质中加载sping配置信息并使用Rsouce表示这个配置文件资源。\n\n2. BeanDeinitionReader 读取Resource所指向的配置文件资源，然后解析配置文件。配置文件中的每个bean解析成一个 BeanDefinition 对象，并保存到BeanDefinitionRegistry中。\n\n3. 容器扫描BeanDefinitionRegistry中的BeanDefinition, 使用Java反射机制自动识别出Bean工厂后处理器( 实现BeanFactoryPostProcessor接口的Bean)，然后调用这些Bean工厂后处理器对BeanDefinitionRegstry中的BeanDefinition 进行加工处理。主要总结完成以下两项工作:\n\n   ①对使用占位符的-bean元素标签进行解析，得到最终的配置值。 这意味着对一些半成品式的BeanDefinition对象进行加工处理并得到成品的BeanDefnition对象。\n\n   ②对BeanDefnitionRegisty中的BeanDefnition进行扫描，通过Java反射机制找出所有属性编辑器的Bean (实现jabcans PopertyEditor接口的Bean),并自动将它们注册到Spring容器的属性编辑器注册表中(ProetyEdiorRegisty)\n\n4. Spring 容器从BeanDefnitionRegistry中取出加工后的BeanDeinition,并调用InstantiationStrategy着手进行Bean实例化的工作。\n\n5. 在实例化Bean时，Spring容器使用BeanWrapper对Bean进行封装。BeanWrapper提供了很多以Java反射机制操作Bean的方法，它将结合该Bean的BeanDefnition及容器中的属性编辑器，完成Bean属性注入工作。\n\n6. 利用容器中注册的Bean后处理器(实现BeanPstProcessor接口的Bean)对已经完成属性设置工作的Bean进行后续加工，直接装配出一个准备就绪的Bean。\n\n  Spring容器堪称部设计精密的机器， 其内部拥有众多的组件和装置。Spring 的高明之处在于，它使用众多接口描绘出了所有装置的协作蓝图，构建好Spring的骨架，继而通过继承体系层层推演、不断丰富，最终让Spring成为有血有肉的完整的框架。所以在查看Spring框架的源码时，有两条清晰可见的脉络:\n\n1. 接口层描述了容器的重要组件及组件间的协作关系。\n2. 继承体系逐步实现组件的各项功能。\n\n接口层清晰地勾勒出Spring框架的高层功能，框架整体结构非常清晰。有了接口层抽象的描述后，不但Spring自己可以提供具体的实现，任何第三方组织也可以提供不同的实现，可以说Spring完善的接口层使框架的扩展性得到了很好的保证。纵向继承体系的逐步扩展，分步骤地实现框架的功能，这种实现方案保证了框架功能不会堆积在某些类身上，从而造成过重的代码逻辑负载，框架的复杂度被完美地分解开了。\n\n# 总结\n\n整个Spring的启动还是非常复杂，这里只是大概的介绍一下整体流程，具体的细节还需要继续研磨观看。\n\n> 参考: 《Spring技术内幕》、《精通Spring 4.x 企业应用开发实战》\n>\n> [SpringBoot源码分析之Spring容器的refresh过程](http://fangjian0423.github.io/2017/05/10/springboot-context-refresh/)\n>\n> [[Spring]容器刷新](http://zhangh.tk/2017/07/16/%E3%80%90Spring%E3%80%91%E5%AE%B9%E5%99%A8%E5%88%B7%E6%96%B0/#initMessageSource)\n\n","source":"_posts/2017-11-06-refresh.markdown","raw":"---\nlayout: post\ntitle: \"Spring | AbstractApplicationContext refresh()方法源码解析\"\ndate: 2017-11-06 21:13\nauthor: \"Gubaidan\"\nheader-img: \"/Header/hero@2x.jpg\"\ncdn: 'header-on'\ntags:\n\t- Spring\n---\n\n# 内部工作机制\n\nSpring的 AbstractApplicationContext 是ApplicationContext 接口的抽象实现类，该抽象类中的refresh（）方法定义了Spring容器在加载配置文件之后的处理过程。即整个IOC容器的启动过程。\n\n```java\npublic void refresh() throws BeansException, IllegalStateException {\n\tsynchronized (this.startupShutdownMonitor) {\n\t// 准备上下文刷新，准备此上下文以进行刷新，设置其启动日期和是否正在刷新的,\n\t//标志以及验证标记为必需的所有属性是否可解析等。\n\tprepareRefresh();\n\n\t// 告诉子类刷新内部bean工厂，并返回一个ConfigurableListableBeanFactory实例,\n\t//在这一步里，Spring将配置文件的信息装入容器的BeanDefintion，此时Bean还未初始化。\n\tConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();\n\n\t// 让当前这个beanfactory接手当前上下文，包括设置类加载器（setBeanClassLoader）,\n\t//设置后置处理器（addBeanPostProcessor），BeanFactory接口不在普通工厂中注册为可解析类型。\n\tprepareBeanFactory(beanFactory);\n\n\ttry {\n\t\t// 允许在上下文子类中对bean工厂进行后处理。\n\t\tpostProcessBeanFactory(beanFactory);\n\n\t\t//调用工厂后置处理器\n\t\tinvokeBeanFactoryPostProcessors(beanFactory);\n\n\t\t// 注册后置处理器\n\t\tregisterBeanPostProcessors(beanFactory);\n\n\t\t// 初始化消息源\n\t\tinitMessageSource();\n\n\t\t// 初始化上下文事件广播器.\n\t\tinitApplicationEventMulticaster();\n\n\t\t// 初始化其他特殊的Bean，由具体子类实现\n\t\tonRefresh();\n\n\t\t// 检查并注册事件监听器\n\t\tregisterListeners();\n\n\t\t// 除了懒加载模式的Bean，其他的Bean全部初始化并且单实例化\n\t\tfinishBeanFactoryInitialization(beanFactory);\n\n\t\t// 发布事件公高，完成容器刷新.\n\t\tfinishRefresh();\n\t}\n\n\tcatch (BeansException ex) {\n\t\tif (logger.isWarnEnabled()) {\n\t\tlogger.warn(\"Exception encountered during context initialization - \" +\n\t\t\t\"cancelling refresh attempt: \" + ex);\n\t\t}\n\n\t\t// 清除已经加载的Bean，避免资源浪费\n\t\tdestroyBeans();\n\n\t\t// 重置刷新标志为false（active = false）\n\t\tcancelRefresh(ex);\n\n\t\t// 发布异常\n\t\tthrow ex;\n\t}\n\n\tfinally {\n\t\t//重置Spring在初始化IOC容器过程中的缓存\n\t\tresetCommonCaches();\n\t}\n\t}\n}\n```\n\n## 相对重要的方法：\n\n### prepareRefresh \n\n```java\nprotected void prepareRefresh() {\n\t// 表示在真正做refresh操作之前需要准备做的事情：\n \n\t// 设置Spring容器的启动时间，撤销关闭状态，开启活跃状态。\n\tthis.startupDate = System.currentTimeMillis();\n\tthis.closed.set(false);\n\tthis.active.set(true);\n \n\tif (logger.isInfoEnabled()) {\n\t\tlogger.info(\"Refreshing \" + this);\n\t}\n \n\t// Initialize any placeholder property sources in the context environment\n\t// 初始化属性源信息,初始化占位符\n\tinitPropertySources();\n \n\t// Validate that all properties marked as required are resolvable\n\t// see ConfigurablePropertyResolver#setRequiredProperties\n\t// 验证环境信息里一些必须存在的属性\n\tgetEnvironment().validateRequiredProperties();\n \n\t// Allow for the collection of early ApplicationEvents,\n\t// to be published once the multicaster is available...\n\tthis.earlyApplicationEvents = new LinkedHashSet<>();\n}\n\n```\n\n### obtainFreshBeanFactory\n\n**ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory()**：初始化BeanFactory: 根据配置文件实例化BeanFactory, 在obtainFreshBeanFactory0方法中，首先调用refreshBeanFactory0方法 刷新BeanFactory, 然后调用getBeanFactory0方法获取BeanFactory, 这两个方法都是由具体子类实现的。在这一一步目，Spring将配置文件的信息装入容器的Bean定义注册表(BeanDefinitionRegistry)中，但此时Bean还未初始化。\n\n```java\nprotected ConfigurableListableBeanFactory obtainFreshBeanFactory() {\n\t// 获取刷新Spring上下文的Bean工厂\n\trefreshBeanFactory();\n\tConfigurableListableBeanFactory beanFactory = getBeanFactory();\n\tif (logger.isDebugEnabled()) {\n\t\tlogger.debug(\"Bean factory for \" + getDisplayName() + \": \" + beanFactory);\n\t}\n\treturn beanFactory;\n}\n\n```\n\n因为在一个web项目中测试，所有BeanDefintion 中已经包含了一些基本的Bean，当前classLoader为WebAppClassoader\n\n![beanfactory](http://epoch-night.oss-cn-hangzhou.aliyuncs.com/PostImg/Beanfactory.png)\n\n\n\n### prepareBeanFactory\n\n\n```java\nprotected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) {\n\t// Tell the internal bean factory to use the context's class loader etc.\n\t// 设置classloader(用于加载bean)，设置表达式解析器(解析bean定义中的一些表达式)，添加属性编辑注册器(注册属性编辑器)\n\tbeanFactory.setBeanClassLoader(getClassLoader());\n\tbeanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));\n\tbeanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()));\n \n\t// Configure the bean factory with context callbacks.\n\t// 添加ApplicationContextAwareProcessor这个BeanPostProcessor。取消ResourceLoaderAware、ApplicationEventPublisherAware、MessageSourceAware、ApplicationContextAware、EnvironmentAware这5个接口的自动注入。\n\t// 因为ApplicationContextAwareProcessor把这6个接口的实现工作做了\n\tbeanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));\n\tbeanFactory.ignoreDependencyInterface(EnvironmentAware.class);\n\tbeanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);\n\tbeanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);\n\tbeanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);\n\tbeanFactory.ignoreDependencyInterface(MessageSourceAware.class);\n\tbeanFactory.ignoreDependencyInterface(ApplicationContextAware.class);\n \n\t// BeanFactory interface not registered as resolvable type in a plain factory.\n\t// MessageSource registered (and found for autowiring) as a bean.\n\t// 设置特殊的类型对应的bean。BeanFactory对应刚刚获取的BeanFactory；\n\t// ResourceLoader、ApplicationEventPublisher、ApplicationContext这3个接口对应的bean都设置为当前的Spring容器\n\tbeanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);\n\tbeanFactory.registerResolvableDependency(ResourceLoader.class, this);\n\tbeanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);\n\tbeanFactory.registerResolvableDependency(ApplicationContext.class, this);\n \n\t// Register early post-processor for detecting inner beans as ApplicationListeners.\n\tbeanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));\n \n\t// Detect a LoadTimeWeaver and prepare for weaving, if found.\n\tif (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {\n\t\tbeanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));\n\t\t// Set a temporary ClassLoader for type matching.\n\t\tbeanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));\n\t}\n \n\t// Register default environment beans.\n\t// 注入一些其它信息的bean实例，比如environment、systemProperties等\n\tif (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) {\n\t\tbeanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());\n\t}\n\tif (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) {\n\t\tbeanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());\n\t}\n\tif (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) {\n\t\tbeanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());\n\t}\n}\t\n```\n\n\n\n### invokeBeanFactoryPostProcessors\n\n```java\nprotected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) {\n\tPostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());\n \n\t// Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime\n\t// (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)\n\tif (beanFactory.getTempClassLoader() == null && beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {\n\t\tbeanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));\n\t\tbeanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));\n\t}\n}\n\n```\n\n### invokeBeanFactoryPostProcessors(beanFactory)\n\n调用工厂后处理器:根据反射机制从BeanDefinitionRegistry 中找出所有实现了BeanFactoryPostProcessor接口的Bean,并调用其postProcessBeanFactory0接口方法。\n\n### registerBeanPostProcessors(beanFactory)\n注册Bean后处理器:根据反射机制从BeanDefinitionRegistry 中找出所有实现了BeanPostProcessor 接口的Bean,并将它们注册到容器Bean后处理器的注册表中。\n\n在Spring容器中找出实现了BeanFactoryPostProcessor接口的processor并执行。Spring容器会委托给PostProcessorRegistrationDelegate的invokeBeanFactoryPostProcessors方法执行。\n\n介绍两个接口：\n\n1. BeanFactoryPostProcessor：用来修改Spring容器中已经存在的bean的定义，使用ConfigurableListableBeanFactory对bean进行处理\n2. BeanDefinitionRegistryPostProcessor：继承BeanFactoryPostProcessor，作用跟BeanFactoryPostProcessor一样，只不过是使用BeanDefinitionRegistry对bean进行处理\n\n基于web程序的Spring容器AnnotationConfigEmbeddedWebApplicationContext构造的时候，会初始化内部属性AnnotatedBeanDefinitionReader reader，这个reader构造的时候会在BeanFactory中注册一些post processor，包括BeanPostProcessor和BeanFactoryPostProcessor(比如ConfigurationClassPostProcessor、AutowiredAnnotationBeanPostProcessor)：\n\n```java\nAnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry);\n```\n\n接下来从Spring容器内查找BeanFactoryPostProcessor接口的实现类，然后执行(如果processor已经执行过，则忽略)，这里的查找规则跟上面查找BeanDefinitionRegistryPostProcessor一样，先找PriorityOrdered，然后是Ordered，最后是两者都没。\n\n这里需要说明的是**ConfigurationClassPostProcessor**这个processor是**优先级最高**的被执行的processor(实现了PriorityOrdered接口)。这个ConfigurationClassPostProcessor会去BeanFactory中找出所有有@Configuration注解的bean，然后使用**ConfigurationClassParser**去解析这个类。**ConfigurationClassParser内部有个Map类型的configurationClasses属性用于保存解析的类，ConfigurationClass是一个对要解析的配置类的封装，内部存储了配置类的注解信息、被@Bean注解修饰的方法、@ImportResource注解修饰的信息、ImportBeanDefinitionRegistrar等都存储在这个封装类中**。\n\n这里ConfigurationClassPostProcessor最先被处理还有另外一个原因是如果程序中有自定义的BeanFactoryPostProcessor，那么这个PostProcessor首先得通过ConfigurationClassPostProcessor被解析出来，然后才能被Spring容器找到并执行。(ConfigurationClassPostProcessor不先执行的话，这个Processor是不会被解析的，不会被解析的话也就不会执行了)。\n\n在我们的程序中，只有主类CoreApplication有@Configuration注解(@SpringBootApplication注解带有@Configuration注解)，所以这个配置类会被ConfigurationClassParser的parse(set<BeanDefinitionHolder>)方法解析,这个方法又会递归调用parse(AnnotationMetadate,String)，调用processConfigurationClass(ConfigurationClass)   ConfigurationClass可以有多种创建方法，最终实际调用doProcessConfigurationClass（ConfigurationClass,SourceClass）方法。\n\n\n\n### initMessageSource()\n\n\n初始化消息源:初始化容器的国际化消息资源。初始化应用上下文事件广播器。\n\n\n\n### onRefresh()\n\n\n\n初始化其他特殊的Bean: 这是一个钩子方法，子类可以借助这个方法执行一些特殊的操作，如AbstractRefreshableWebApplicationContext 就使用该方法执行初始化ThemeSource的操作。\n\n\n\n### registerListeners()\n\n\n\n注册事件监听器。\n\n\n\n### finishBeanFactoryInitialization(beanFactory)\n\n\n\n初始化所有单实例的Bean,使用懒加载模式的Bean除外:初始化Bean后，将它们放入Spring容器的缓存池中。\n\n\n\n### finishRefresh()\n\n\n\n发布上下文刷新事件:创建上下文刷新事件，事件广播器负责将这些事件广播到每个注册的事件监听器中。\n\n\n\n### resetCommonCaches()\n\n\n\n重置Spring在初始化IOC容器过程中的缓存。\n\n\n\nresfresh（）方法在一个项目启动时会启动2次，第二次加载时加载Serlvet相关bean和Web监听器等。\n\n\n\n# 流程整理\n\n![process](http://epoch-night.oss-cn-hangzhou.aliyuncs.com/PostImg/process.png)\n\nSpring协调多个组件共同完成整个IOC启动，上图描述了从加载配置文件到实例化一个Bean的过程。\n\n1. Rourelade从存储介质中加载sping配置信息并使用Rsouce表示这个配置文件资源。\n\n2. BeanDeinitionReader 读取Resource所指向的配置文件资源，然后解析配置文件。配置文件中的每个bean解析成一个 BeanDefinition 对象，并保存到BeanDefinitionRegistry中。\n\n3. 容器扫描BeanDefinitionRegistry中的BeanDefinition, 使用Java反射机制自动识别出Bean工厂后处理器( 实现BeanFactoryPostProcessor接口的Bean)，然后调用这些Bean工厂后处理器对BeanDefinitionRegstry中的BeanDefinition 进行加工处理。主要总结完成以下两项工作:\n\n   ①对使用占位符的-bean元素标签进行解析，得到最终的配置值。 这意味着对一些半成品式的BeanDefinition对象进行加工处理并得到成品的BeanDefnition对象。\n\n   ②对BeanDefnitionRegisty中的BeanDefnition进行扫描，通过Java反射机制找出所有属性编辑器的Bean (实现jabcans PopertyEditor接口的Bean),并自动将它们注册到Spring容器的属性编辑器注册表中(ProetyEdiorRegisty)\n\n4. Spring 容器从BeanDefnitionRegistry中取出加工后的BeanDeinition,并调用InstantiationStrategy着手进行Bean实例化的工作。\n\n5. 在实例化Bean时，Spring容器使用BeanWrapper对Bean进行封装。BeanWrapper提供了很多以Java反射机制操作Bean的方法，它将结合该Bean的BeanDefnition及容器中的属性编辑器，完成Bean属性注入工作。\n\n6. 利用容器中注册的Bean后处理器(实现BeanPstProcessor接口的Bean)对已经完成属性设置工作的Bean进行后续加工，直接装配出一个准备就绪的Bean。\n\n  Spring容器堪称部设计精密的机器， 其内部拥有众多的组件和装置。Spring 的高明之处在于，它使用众多接口描绘出了所有装置的协作蓝图，构建好Spring的骨架，继而通过继承体系层层推演、不断丰富，最终让Spring成为有血有肉的完整的框架。所以在查看Spring框架的源码时，有两条清晰可见的脉络:\n\n1. 接口层描述了容器的重要组件及组件间的协作关系。\n2. 继承体系逐步实现组件的各项功能。\n\n接口层清晰地勾勒出Spring框架的高层功能，框架整体结构非常清晰。有了接口层抽象的描述后，不但Spring自己可以提供具体的实现，任何第三方组织也可以提供不同的实现，可以说Spring完善的接口层使框架的扩展性得到了很好的保证。纵向继承体系的逐步扩展，分步骤地实现框架的功能，这种实现方案保证了框架功能不会堆积在某些类身上，从而造成过重的代码逻辑负载，框架的复杂度被完美地分解开了。\n\n# 总结\n\n整个Spring的启动还是非常复杂，这里只是大概的介绍一下整体流程，具体的细节还需要继续研磨观看。\n\n> 参考: 《Spring技术内幕》、《精通Spring 4.x 企业应用开发实战》\n>\n> [SpringBoot源码分析之Spring容器的refresh过程](http://fangjian0423.github.io/2017/05/10/springboot-context-refresh/)\n>\n> [[Spring]容器刷新](http://zhangh.tk/2017/07/16/%E3%80%90Spring%E3%80%91%E5%AE%B9%E5%99%A8%E5%88%B7%E6%96%B0/#initMessageSource)\n\n","slug":"2017-11-06-refresh","published":1,"updated":"2019-05-05T12:33:40.941Z","comments":1,"photos":[],"link":"","_id":"cjvayvwg8001um46a0rz4htw8","content":"<h1 id=\"内部工作机制\"><a href=\"#内部工作机制\" class=\"headerlink\" title=\"内部工作机制\"></a>内部工作机制</h1><p>Spring的 AbstractApplicationContext 是ApplicationContext 接口的抽象实现类，该抽象类中的refresh（）方法定义了Spring容器在加载配置文件之后的处理过程。即整个IOC容器的启动过程。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">refresh</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>.startupShutdownMonitor) &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 准备上下文刷新，准备此上下文以进行刷新，设置其启动日期和是否正在刷新的,</span></span><br><span class=\"line\">\t<span class=\"comment\">//标志以及验证标记为必需的所有属性是否可解析等。</span></span><br><span class=\"line\">\tprepareRefresh();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 告诉子类刷新内部bean工厂，并返回一个ConfigurableListableBeanFactory实例,</span></span><br><span class=\"line\">\t<span class=\"comment\">//在这一步里，Spring将配置文件的信息装入容器的BeanDefintion，此时Bean还未初始化。</span></span><br><span class=\"line\">\tConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 让当前这个beanfactory接手当前上下文，包括设置类加载器（setBeanClassLoader）,</span></span><br><span class=\"line\">\t<span class=\"comment\">//设置后置处理器（addBeanPostProcessor），BeanFactory接口不在普通工厂中注册为可解析类型。</span></span><br><span class=\"line\">\tprepareBeanFactory(beanFactory);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 允许在上下文子类中对bean工厂进行后处理。</span></span><br><span class=\"line\">\t\tpostProcessBeanFactory(beanFactory);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//调用工厂后置处理器</span></span><br><span class=\"line\">\t\tinvokeBeanFactoryPostProcessors(beanFactory);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 注册后置处理器</span></span><br><span class=\"line\">\t\tregisterBeanPostProcessors(beanFactory);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 初始化消息源</span></span><br><span class=\"line\">\t\tinitMessageSource();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 初始化上下文事件广播器.</span></span><br><span class=\"line\">\t\tinitApplicationEventMulticaster();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 初始化其他特殊的Bean，由具体子类实现</span></span><br><span class=\"line\">\t\tonRefresh();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 检查并注册事件监听器</span></span><br><span class=\"line\">\t\tregisterListeners();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 除了懒加载模式的Bean，其他的Bean全部初始化并且单实例化</span></span><br><span class=\"line\">\t\tfinishBeanFactoryInitialization(beanFactory);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 发布事件公高，完成容器刷新.</span></span><br><span class=\"line\">\t\tfinishRefresh();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">catch</span> (BeansException ex) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class=\"line\">\t\tlogger.warn(<span class=\"string\">\"Exception encountered during context initialization - \"</span> +</span><br><span class=\"line\">\t\t\t<span class=\"string\">\"cancelling refresh attempt: \"</span> + ex);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 清除已经加载的Bean，避免资源浪费</span></span><br><span class=\"line\">\t\tdestroyBeans();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 重置刷新标志为false（active = false）</span></span><br><span class=\"line\">\t\tcancelRefresh(ex);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 发布异常</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> ex;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//重置Spring在初始化IOC容器过程中的缓存</span></span><br><span class=\"line\">\t\tresetCommonCaches();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"相对重要的方法：\"><a href=\"#相对重要的方法：\" class=\"headerlink\" title=\"相对重要的方法：\"></a>相对重要的方法：</h2><h3 id=\"prepareRefresh\"><a href=\"#prepareRefresh\" class=\"headerlink\" title=\"prepareRefresh\"></a>prepareRefresh</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">prepareRefresh</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 表示在真正做refresh操作之前需要准备做的事情：</span></span><br><span class=\"line\"> </span><br><span class=\"line\">\t<span class=\"comment\">// 设置Spring容器的启动时间，撤销关闭状态，开启活跃状态。</span></span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.startupDate = System.currentTimeMillis();</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.closed.set(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.active.set(<span class=\"keyword\">true</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class=\"line\">\t\tlogger.info(<span class=\"string\">\"Refreshing \"</span> + <span class=\"keyword\">this</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t<span class=\"comment\">// Initialize any placeholder property sources in the context environment</span></span><br><span class=\"line\">\t<span class=\"comment\">// 初始化属性源信息,初始化占位符</span></span><br><span class=\"line\">\tinitPropertySources();</span><br><span class=\"line\"> </span><br><span class=\"line\">\t<span class=\"comment\">// Validate that all properties marked as required are resolvable</span></span><br><span class=\"line\">\t<span class=\"comment\">// see ConfigurablePropertyResolver#setRequiredProperties</span></span><br><span class=\"line\">\t<span class=\"comment\">// 验证环境信息里一些必须存在的属性</span></span><br><span class=\"line\">\tgetEnvironment().validateRequiredProperties();</span><br><span class=\"line\"> </span><br><span class=\"line\">\t<span class=\"comment\">// Allow for the collection of early ApplicationEvents,</span></span><br><span class=\"line\">\t<span class=\"comment\">// to be published once the multicaster is available...</span></span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.earlyApplicationEvents = <span class=\"keyword\">new</span> LinkedHashSet&lt;&gt;();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"obtainFreshBeanFactory\"><a href=\"#obtainFreshBeanFactory\" class=\"headerlink\" title=\"obtainFreshBeanFactory\"></a>obtainFreshBeanFactory</h3><p><strong>ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory()</strong>：初始化BeanFactory: 根据配置文件实例化BeanFactory, 在obtainFreshBeanFactory0方法中，首先调用refreshBeanFactory0方法 刷新BeanFactory, 然后调用getBeanFactory0方法获取BeanFactory, 这两个方法都是由具体子类实现的。在这一一步目，Spring将配置文件的信息装入容器的Bean定义注册表(BeanDefinitionRegistry)中，但此时Bean还未初始化。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> ConfigurableListableBeanFactory <span class=\"title\">obtainFreshBeanFactory</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 获取刷新Spring上下文的Bean工厂</span></span><br><span class=\"line\">\trefreshBeanFactory();</span><br><span class=\"line\">\tConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">\t\tlogger.debug(<span class=\"string\">\"Bean factory for \"</span> + getDisplayName() + <span class=\"string\">\": \"</span> + beanFactory);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> beanFactory;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>因为在一个web项目中测试，所有BeanDefintion 中已经包含了一些基本的Bean，当前classLoader为WebAppClassoader</p>\n<p><img src=\"http://epoch-night.oss-cn-hangzhou.aliyuncs.com/PostImg/Beanfactory.png\" alt=\"beanfactory\"></p>\n<h3 id=\"prepareBeanFactory\"><a href=\"#prepareBeanFactory\" class=\"headerlink\" title=\"prepareBeanFactory\"></a>prepareBeanFactory</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">prepareBeanFactory</span><span class=\"params\">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// Tell the internal bean factory to use the context's class loader etc.</span></span><br><span class=\"line\">\t<span class=\"comment\">// 设置classloader(用于加载bean)，设置表达式解析器(解析bean定义中的一些表达式)，添加属性编辑注册器(注册属性编辑器)</span></span><br><span class=\"line\">\tbeanFactory.setBeanClassLoader(getClassLoader());</span><br><span class=\"line\">\tbeanFactory.setBeanExpressionResolver(<span class=\"keyword\">new</span> StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));</span><br><span class=\"line\">\tbeanFactory.addPropertyEditorRegistrar(<span class=\"keyword\">new</span> ResourceEditorRegistrar(<span class=\"keyword\">this</span>, getEnvironment()));</span><br><span class=\"line\"> </span><br><span class=\"line\">\t<span class=\"comment\">// Configure the bean factory with context callbacks.</span></span><br><span class=\"line\">\t<span class=\"comment\">// 添加ApplicationContextAwareProcessor这个BeanPostProcessor。取消ResourceLoaderAware、ApplicationEventPublisherAware、MessageSourceAware、ApplicationContextAware、EnvironmentAware这5个接口的自动注入。</span></span><br><span class=\"line\">\t<span class=\"comment\">// 因为ApplicationContextAwareProcessor把这6个接口的实现工作做了</span></span><br><span class=\"line\">\tbeanFactory.addBeanPostProcessor(<span class=\"keyword\">new</span> ApplicationContextAwareProcessor(<span class=\"keyword\">this</span>));</span><br><span class=\"line\">\tbeanFactory.ignoreDependencyInterface(EnvironmentAware.class);</span><br><span class=\"line\">\tbeanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);</span><br><span class=\"line\">\tbeanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);</span><br><span class=\"line\">\tbeanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);</span><br><span class=\"line\">\tbeanFactory.ignoreDependencyInterface(MessageSourceAware.class);</span><br><span class=\"line\">\tbeanFactory.ignoreDependencyInterface(ApplicationContextAware.class);</span><br><span class=\"line\"> </span><br><span class=\"line\">\t<span class=\"comment\">// BeanFactory interface not registered as resolvable type in a plain factory.</span></span><br><span class=\"line\">\t<span class=\"comment\">// MessageSource registered (and found for autowiring) as a bean.</span></span><br><span class=\"line\">\t<span class=\"comment\">// 设置特殊的类型对应的bean。BeanFactory对应刚刚获取的BeanFactory；</span></span><br><span class=\"line\">\t<span class=\"comment\">// ResourceLoader、ApplicationEventPublisher、ApplicationContext这3个接口对应的bean都设置为当前的Spring容器</span></span><br><span class=\"line\">\tbeanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);</span><br><span class=\"line\">\tbeanFactory.registerResolvableDependency(ResourceLoader.class, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">\tbeanFactory.registerResolvableDependency(ApplicationEventPublisher.class, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">\tbeanFactory.registerResolvableDependency(ApplicationContext.class, <span class=\"keyword\">this</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\">\t<span class=\"comment\">// Register early post-processor for detecting inner beans as ApplicationListeners.</span></span><br><span class=\"line\">\tbeanFactory.addBeanPostProcessor(<span class=\"keyword\">new</span> ApplicationListenerDetector(<span class=\"keyword\">this</span>));</span><br><span class=\"line\"> </span><br><span class=\"line\">\t<span class=\"comment\">// Detect a LoadTimeWeaver and prepare for weaving, if found.</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class=\"line\">\t\tbeanFactory.addBeanPostProcessor(<span class=\"keyword\">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class=\"line\">\t\t<span class=\"comment\">// Set a temporary ClassLoader for type matching.</span></span><br><span class=\"line\">\t\tbeanFactory.setTempClassLoader(<span class=\"keyword\">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t<span class=\"comment\">// Register default environment beans.</span></span><br><span class=\"line\">\t<span class=\"comment\">// 注入一些其它信息的bean实例，比如environment、systemProperties等</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class=\"line\">\t\tbeanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;</span><br><span class=\"line\">\t\tbeanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class=\"line\">\t\tbeanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"invokeBeanFactoryPostProcessors\"><a href=\"#invokeBeanFactoryPostProcessors\" class=\"headerlink\" title=\"invokeBeanFactoryPostProcessors\"></a>invokeBeanFactoryPostProcessors</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">invokeBeanFactoryPostProcessors</span><span class=\"params\">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class=\"line\">\tPostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());</span><br><span class=\"line\"> </span><br><span class=\"line\">\t<span class=\"comment\">// Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime</span></span><br><span class=\"line\">\t<span class=\"comment\">// (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (beanFactory.getTempClassLoader() == <span class=\"keyword\">null</span> &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class=\"line\">\t\tbeanFactory.addBeanPostProcessor(<span class=\"keyword\">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class=\"line\">\t\tbeanFactory.setTempClassLoader(<span class=\"keyword\">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"invokeBeanFactoryPostProcessors-beanFactory\"><a href=\"#invokeBeanFactoryPostProcessors-beanFactory\" class=\"headerlink\" title=\"invokeBeanFactoryPostProcessors(beanFactory)\"></a>invokeBeanFactoryPostProcessors(beanFactory)</h3><p>调用工厂后处理器:根据反射机制从BeanDefinitionRegistry 中找出所有实现了BeanFactoryPostProcessor接口的Bean,并调用其postProcessBeanFactory0接口方法。</p>\n<h3 id=\"registerBeanPostProcessors-beanFactory\"><a href=\"#registerBeanPostProcessors-beanFactory\" class=\"headerlink\" title=\"registerBeanPostProcessors(beanFactory)\"></a>registerBeanPostProcessors(beanFactory)</h3><p>注册Bean后处理器:根据反射机制从BeanDefinitionRegistry 中找出所有实现了BeanPostProcessor 接口的Bean,并将它们注册到容器Bean后处理器的注册表中。</p>\n<p>在Spring容器中找出实现了BeanFactoryPostProcessor接口的processor并执行。Spring容器会委托给PostProcessorRegistrationDelegate的invokeBeanFactoryPostProcessors方法执行。</p>\n<p>介绍两个接口：</p>\n<ol>\n<li>BeanFactoryPostProcessor：用来修改Spring容器中已经存在的bean的定义，使用ConfigurableListableBeanFactory对bean进行处理</li>\n<li>BeanDefinitionRegistryPostProcessor：继承BeanFactoryPostProcessor，作用跟BeanFactoryPostProcessor一样，只不过是使用BeanDefinitionRegistry对bean进行处理</li>\n</ol>\n<p>基于web程序的Spring容器AnnotationConfigEmbeddedWebApplicationContext构造的时候，会初始化内部属性AnnotatedBeanDefinitionReader reader，这个reader构造的时候会在BeanFactory中注册一些post processor，包括BeanPostProcessor和BeanFactoryPostProcessor(比如ConfigurationClassPostProcessor、AutowiredAnnotationBeanPostProcessor)：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">AnnotationConfigUtils.registerAnnotationConfigProcessors(<span class=\"keyword\">this</span>.registry);</span><br></pre></td></tr></table></figure>\n<p>接下来从Spring容器内查找BeanFactoryPostProcessor接口的实现类，然后执行(如果processor已经执行过，则忽略)，这里的查找规则跟上面查找BeanDefinitionRegistryPostProcessor一样，先找PriorityOrdered，然后是Ordered，最后是两者都没。</p>\n<p>这里需要说明的是<strong>ConfigurationClassPostProcessor</strong>这个processor是<strong>优先级最高</strong>的被执行的processor(实现了PriorityOrdered接口)。这个ConfigurationClassPostProcessor会去BeanFactory中找出所有有@Configuration注解的bean，然后使用<strong>ConfigurationClassParser</strong>去解析这个类。<strong>ConfigurationClassParser内部有个Map类型的configurationClasses属性用于保存解析的类，ConfigurationClass是一个对要解析的配置类的封装，内部存储了配置类的注解信息、被@Bean注解修饰的方法、@ImportResource注解修饰的信息、ImportBeanDefinitionRegistrar等都存储在这个封装类中</strong>。</p>\n<p>这里ConfigurationClassPostProcessor最先被处理还有另外一个原因是如果程序中有自定义的BeanFactoryPostProcessor，那么这个PostProcessor首先得通过ConfigurationClassPostProcessor被解析出来，然后才能被Spring容器找到并执行。(ConfigurationClassPostProcessor不先执行的话，这个Processor是不会被解析的，不会被解析的话也就不会执行了)。</p>\n<p>在我们的程序中，只有主类CoreApplication有@Configuration注解(@SpringBootApplication注解带有@Configuration注解)，所以这个配置类会被ConfigurationClassParser的parse(set<beandefinitionholder>)方法解析,这个方法又会递归调用parse(AnnotationMetadate,String)，调用processConfigurationClass(ConfigurationClass)   ConfigurationClass可以有多种创建方法，最终实际调用doProcessConfigurationClass（ConfigurationClass,SourceClass）方法。</beandefinitionholder></p>\n<h3 id=\"initMessageSource\"><a href=\"#initMessageSource\" class=\"headerlink\" title=\"initMessageSource()\"></a>initMessageSource()</h3><p>初始化消息源:初始化容器的国际化消息资源。初始化应用上下文事件广播器。</p>\n<h3 id=\"onRefresh\"><a href=\"#onRefresh\" class=\"headerlink\" title=\"onRefresh()\"></a>onRefresh()</h3><p>初始化其他特殊的Bean: 这是一个钩子方法，子类可以借助这个方法执行一些特殊的操作，如AbstractRefreshableWebApplicationContext 就使用该方法执行初始化ThemeSource的操作。</p>\n<h3 id=\"registerListeners\"><a href=\"#registerListeners\" class=\"headerlink\" title=\"registerListeners()\"></a>registerListeners()</h3><p>注册事件监听器。</p>\n<h3 id=\"finishBeanFactoryInitialization-beanFactory\"><a href=\"#finishBeanFactoryInitialization-beanFactory\" class=\"headerlink\" title=\"finishBeanFactoryInitialization(beanFactory)\"></a>finishBeanFactoryInitialization(beanFactory)</h3><p>初始化所有单实例的Bean,使用懒加载模式的Bean除外:初始化Bean后，将它们放入Spring容器的缓存池中。</p>\n<h3 id=\"finishRefresh\"><a href=\"#finishRefresh\" class=\"headerlink\" title=\"finishRefresh()\"></a>finishRefresh()</h3><p>发布上下文刷新事件:创建上下文刷新事件，事件广播器负责将这些事件广播到每个注册的事件监听器中。</p>\n<h3 id=\"resetCommonCaches\"><a href=\"#resetCommonCaches\" class=\"headerlink\" title=\"resetCommonCaches()\"></a>resetCommonCaches()</h3><p>重置Spring在初始化IOC容器过程中的缓存。</p>\n<p>resfresh（）方法在一个项目启动时会启动2次，第二次加载时加载Serlvet相关bean和Web监听器等。</p>\n<h1 id=\"流程整理\"><a href=\"#流程整理\" class=\"headerlink\" title=\"流程整理\"></a>流程整理</h1><p><img src=\"http://epoch-night.oss-cn-hangzhou.aliyuncs.com/PostImg/process.png\" alt=\"process\"></p>\n<p>Spring协调多个组件共同完成整个IOC启动，上图描述了从加载配置文件到实例化一个Bean的过程。</p>\n<ol>\n<li><p>Rourelade从存储介质中加载sping配置信息并使用Rsouce表示这个配置文件资源。</p>\n</li>\n<li><p>BeanDeinitionReader 读取Resource所指向的配置文件资源，然后解析配置文件。配置文件中的每个bean解析成一个 BeanDefinition 对象，并保存到BeanDefinitionRegistry中。</p>\n</li>\n<li><p>容器扫描BeanDefinitionRegistry中的BeanDefinition, 使用Java反射机制自动识别出Bean工厂后处理器( 实现BeanFactoryPostProcessor接口的Bean)，然后调用这些Bean工厂后处理器对BeanDefinitionRegstry中的BeanDefinition 进行加工处理。主要总结完成以下两项工作:</p>\n<p>①对使用占位符的-bean元素标签进行解析，得到最终的配置值。 这意味着对一些半成品式的BeanDefinition对象进行加工处理并得到成品的BeanDefnition对象。</p>\n<p>②对BeanDefnitionRegisty中的BeanDefnition进行扫描，通过Java反射机制找出所有属性编辑器的Bean (实现jabcans PopertyEditor接口的Bean),并自动将它们注册到Spring容器的属性编辑器注册表中(ProetyEdiorRegisty)</p>\n</li>\n<li><p>Spring 容器从BeanDefnitionRegistry中取出加工后的BeanDeinition,并调用InstantiationStrategy着手进行Bean实例化的工作。</p>\n</li>\n<li><p>在实例化Bean时，Spring容器使用BeanWrapper对Bean进行封装。BeanWrapper提供了很多以Java反射机制操作Bean的方法，它将结合该Bean的BeanDefnition及容器中的属性编辑器，完成Bean属性注入工作。</p>\n</li>\n<li><p>利用容器中注册的Bean后处理器(实现BeanPstProcessor接口的Bean)对已经完成属性设置工作的Bean进行后续加工，直接装配出一个准备就绪的Bean。</p>\n<p>Spring容器堪称部设计精密的机器， 其内部拥有众多的组件和装置。Spring 的高明之处在于，它使用众多接口描绘出了所有装置的协作蓝图，构建好Spring的骨架，继而通过继承体系层层推演、不断丰富，最终让Spring成为有血有肉的完整的框架。所以在查看Spring框架的源码时，有两条清晰可见的脉络:</p>\n</li>\n<li><p>接口层描述了容器的重要组件及组件间的协作关系。</p>\n</li>\n<li>继承体系逐步实现组件的各项功能。</li>\n</ol>\n<p>接口层清晰地勾勒出Spring框架的高层功能，框架整体结构非常清晰。有了接口层抽象的描述后，不但Spring自己可以提供具体的实现，任何第三方组织也可以提供不同的实现，可以说Spring完善的接口层使框架的扩展性得到了很好的保证。纵向继承体系的逐步扩展，分步骤地实现框架的功能，这种实现方案保证了框架功能不会堆积在某些类身上，从而造成过重的代码逻辑负载，框架的复杂度被完美地分解开了。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>整个Spring的启动还是非常复杂，这里只是大概的介绍一下整体流程，具体的细节还需要继续研磨观看。</p>\n<blockquote>\n<p>参考: 《Spring技术内幕》、《精通Spring 4.x 企业应用开发实战》</p>\n<p><a href=\"http://fangjian0423.github.io/2017/05/10/springboot-context-refresh/\" target=\"_blank\" rel=\"noopener\">SpringBoot源码分析之Spring容器的refresh过程</a></p>\n<p><a href=\"http://zhangh.tk/2017/07/16/%E3%80%90Spring%E3%80%91%E5%AE%B9%E5%99%A8%E5%88%B7%E6%96%B0/#initMessageSource\" target=\"_blank\" rel=\"noopener\">[Spring]容器刷新</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"内部工作机制\"><a href=\"#内部工作机制\" class=\"headerlink\" title=\"内部工作机制\"></a>内部工作机制</h1><p>Spring的 AbstractApplicationContext 是ApplicationContext 接口的抽象实现类，该抽象类中的refresh（）方法定义了Spring容器在加载配置文件之后的处理过程。即整个IOC容器的启动过程。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">refresh</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>.startupShutdownMonitor) &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 准备上下文刷新，准备此上下文以进行刷新，设置其启动日期和是否正在刷新的,</span></span><br><span class=\"line\">\t<span class=\"comment\">//标志以及验证标记为必需的所有属性是否可解析等。</span></span><br><span class=\"line\">\tprepareRefresh();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 告诉子类刷新内部bean工厂，并返回一个ConfigurableListableBeanFactory实例,</span></span><br><span class=\"line\">\t<span class=\"comment\">//在这一步里，Spring将配置文件的信息装入容器的BeanDefintion，此时Bean还未初始化。</span></span><br><span class=\"line\">\tConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 让当前这个beanfactory接手当前上下文，包括设置类加载器（setBeanClassLoader）,</span></span><br><span class=\"line\">\t<span class=\"comment\">//设置后置处理器（addBeanPostProcessor），BeanFactory接口不在普通工厂中注册为可解析类型。</span></span><br><span class=\"line\">\tprepareBeanFactory(beanFactory);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 允许在上下文子类中对bean工厂进行后处理。</span></span><br><span class=\"line\">\t\tpostProcessBeanFactory(beanFactory);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//调用工厂后置处理器</span></span><br><span class=\"line\">\t\tinvokeBeanFactoryPostProcessors(beanFactory);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 注册后置处理器</span></span><br><span class=\"line\">\t\tregisterBeanPostProcessors(beanFactory);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 初始化消息源</span></span><br><span class=\"line\">\t\tinitMessageSource();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 初始化上下文事件广播器.</span></span><br><span class=\"line\">\t\tinitApplicationEventMulticaster();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 初始化其他特殊的Bean，由具体子类实现</span></span><br><span class=\"line\">\t\tonRefresh();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 检查并注册事件监听器</span></span><br><span class=\"line\">\t\tregisterListeners();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 除了懒加载模式的Bean，其他的Bean全部初始化并且单实例化</span></span><br><span class=\"line\">\t\tfinishBeanFactoryInitialization(beanFactory);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 发布事件公高，完成容器刷新.</span></span><br><span class=\"line\">\t\tfinishRefresh();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">catch</span> (BeansException ex) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class=\"line\">\t\tlogger.warn(<span class=\"string\">\"Exception encountered during context initialization - \"</span> +</span><br><span class=\"line\">\t\t\t<span class=\"string\">\"cancelling refresh attempt: \"</span> + ex);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 清除已经加载的Bean，避免资源浪费</span></span><br><span class=\"line\">\t\tdestroyBeans();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 重置刷新标志为false（active = false）</span></span><br><span class=\"line\">\t\tcancelRefresh(ex);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// 发布异常</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> ex;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//重置Spring在初始化IOC容器过程中的缓存</span></span><br><span class=\"line\">\t\tresetCommonCaches();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"相对重要的方法：\"><a href=\"#相对重要的方法：\" class=\"headerlink\" title=\"相对重要的方法：\"></a>相对重要的方法：</h2><h3 id=\"prepareRefresh\"><a href=\"#prepareRefresh\" class=\"headerlink\" title=\"prepareRefresh\"></a>prepareRefresh</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">prepareRefresh</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 表示在真正做refresh操作之前需要准备做的事情：</span></span><br><span class=\"line\"> </span><br><span class=\"line\">\t<span class=\"comment\">// 设置Spring容器的启动时间，撤销关闭状态，开启活跃状态。</span></span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.startupDate = System.currentTimeMillis();</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.closed.set(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.active.set(<span class=\"keyword\">true</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class=\"line\">\t\tlogger.info(<span class=\"string\">\"Refreshing \"</span> + <span class=\"keyword\">this</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t<span class=\"comment\">// Initialize any placeholder property sources in the context environment</span></span><br><span class=\"line\">\t<span class=\"comment\">// 初始化属性源信息,初始化占位符</span></span><br><span class=\"line\">\tinitPropertySources();</span><br><span class=\"line\"> </span><br><span class=\"line\">\t<span class=\"comment\">// Validate that all properties marked as required are resolvable</span></span><br><span class=\"line\">\t<span class=\"comment\">// see ConfigurablePropertyResolver#setRequiredProperties</span></span><br><span class=\"line\">\t<span class=\"comment\">// 验证环境信息里一些必须存在的属性</span></span><br><span class=\"line\">\tgetEnvironment().validateRequiredProperties();</span><br><span class=\"line\"> </span><br><span class=\"line\">\t<span class=\"comment\">// Allow for the collection of early ApplicationEvents,</span></span><br><span class=\"line\">\t<span class=\"comment\">// to be published once the multicaster is available...</span></span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.earlyApplicationEvents = <span class=\"keyword\">new</span> LinkedHashSet&lt;&gt;();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"obtainFreshBeanFactory\"><a href=\"#obtainFreshBeanFactory\" class=\"headerlink\" title=\"obtainFreshBeanFactory\"></a>obtainFreshBeanFactory</h3><p><strong>ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory()</strong>：初始化BeanFactory: 根据配置文件实例化BeanFactory, 在obtainFreshBeanFactory0方法中，首先调用refreshBeanFactory0方法 刷新BeanFactory, 然后调用getBeanFactory0方法获取BeanFactory, 这两个方法都是由具体子类实现的。在这一一步目，Spring将配置文件的信息装入容器的Bean定义注册表(BeanDefinitionRegistry)中，但此时Bean还未初始化。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> ConfigurableListableBeanFactory <span class=\"title\">obtainFreshBeanFactory</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 获取刷新Spring上下文的Bean工厂</span></span><br><span class=\"line\">\trefreshBeanFactory();</span><br><span class=\"line\">\tConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">\t\tlogger.debug(<span class=\"string\">\"Bean factory for \"</span> + getDisplayName() + <span class=\"string\">\": \"</span> + beanFactory);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> beanFactory;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>因为在一个web项目中测试，所有BeanDefintion 中已经包含了一些基本的Bean，当前classLoader为WebAppClassoader</p>\n<p><img src=\"http://epoch-night.oss-cn-hangzhou.aliyuncs.com/PostImg/Beanfactory.png\" alt=\"beanfactory\"></p>\n<h3 id=\"prepareBeanFactory\"><a href=\"#prepareBeanFactory\" class=\"headerlink\" title=\"prepareBeanFactory\"></a>prepareBeanFactory</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">prepareBeanFactory</span><span class=\"params\">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// Tell the internal bean factory to use the context's class loader etc.</span></span><br><span class=\"line\">\t<span class=\"comment\">// 设置classloader(用于加载bean)，设置表达式解析器(解析bean定义中的一些表达式)，添加属性编辑注册器(注册属性编辑器)</span></span><br><span class=\"line\">\tbeanFactory.setBeanClassLoader(getClassLoader());</span><br><span class=\"line\">\tbeanFactory.setBeanExpressionResolver(<span class=\"keyword\">new</span> StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));</span><br><span class=\"line\">\tbeanFactory.addPropertyEditorRegistrar(<span class=\"keyword\">new</span> ResourceEditorRegistrar(<span class=\"keyword\">this</span>, getEnvironment()));</span><br><span class=\"line\"> </span><br><span class=\"line\">\t<span class=\"comment\">// Configure the bean factory with context callbacks.</span></span><br><span class=\"line\">\t<span class=\"comment\">// 添加ApplicationContextAwareProcessor这个BeanPostProcessor。取消ResourceLoaderAware、ApplicationEventPublisherAware、MessageSourceAware、ApplicationContextAware、EnvironmentAware这5个接口的自动注入。</span></span><br><span class=\"line\">\t<span class=\"comment\">// 因为ApplicationContextAwareProcessor把这6个接口的实现工作做了</span></span><br><span class=\"line\">\tbeanFactory.addBeanPostProcessor(<span class=\"keyword\">new</span> ApplicationContextAwareProcessor(<span class=\"keyword\">this</span>));</span><br><span class=\"line\">\tbeanFactory.ignoreDependencyInterface(EnvironmentAware.class);</span><br><span class=\"line\">\tbeanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);</span><br><span class=\"line\">\tbeanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);</span><br><span class=\"line\">\tbeanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);</span><br><span class=\"line\">\tbeanFactory.ignoreDependencyInterface(MessageSourceAware.class);</span><br><span class=\"line\">\tbeanFactory.ignoreDependencyInterface(ApplicationContextAware.class);</span><br><span class=\"line\"> </span><br><span class=\"line\">\t<span class=\"comment\">// BeanFactory interface not registered as resolvable type in a plain factory.</span></span><br><span class=\"line\">\t<span class=\"comment\">// MessageSource registered (and found for autowiring) as a bean.</span></span><br><span class=\"line\">\t<span class=\"comment\">// 设置特殊的类型对应的bean。BeanFactory对应刚刚获取的BeanFactory；</span></span><br><span class=\"line\">\t<span class=\"comment\">// ResourceLoader、ApplicationEventPublisher、ApplicationContext这3个接口对应的bean都设置为当前的Spring容器</span></span><br><span class=\"line\">\tbeanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);</span><br><span class=\"line\">\tbeanFactory.registerResolvableDependency(ResourceLoader.class, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">\tbeanFactory.registerResolvableDependency(ApplicationEventPublisher.class, <span class=\"keyword\">this</span>);</span><br><span class=\"line\">\tbeanFactory.registerResolvableDependency(ApplicationContext.class, <span class=\"keyword\">this</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\">\t<span class=\"comment\">// Register early post-processor for detecting inner beans as ApplicationListeners.</span></span><br><span class=\"line\">\tbeanFactory.addBeanPostProcessor(<span class=\"keyword\">new</span> ApplicationListenerDetector(<span class=\"keyword\">this</span>));</span><br><span class=\"line\"> </span><br><span class=\"line\">\t<span class=\"comment\">// Detect a LoadTimeWeaver and prepare for weaving, if found.</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class=\"line\">\t\tbeanFactory.addBeanPostProcessor(<span class=\"keyword\">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class=\"line\">\t\t<span class=\"comment\">// Set a temporary ClassLoader for type matching.</span></span><br><span class=\"line\">\t\tbeanFactory.setTempClassLoader(<span class=\"keyword\">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t<span class=\"comment\">// Register default environment beans.</span></span><br><span class=\"line\">\t<span class=\"comment\">// 注入一些其它信息的bean实例，比如environment、systemProperties等</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class=\"line\">\t\tbeanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;</span><br><span class=\"line\">\t\tbeanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class=\"line\">\t\tbeanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"invokeBeanFactoryPostProcessors\"><a href=\"#invokeBeanFactoryPostProcessors\" class=\"headerlink\" title=\"invokeBeanFactoryPostProcessors\"></a>invokeBeanFactoryPostProcessors</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">invokeBeanFactoryPostProcessors</span><span class=\"params\">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class=\"line\">\tPostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());</span><br><span class=\"line\"> </span><br><span class=\"line\">\t<span class=\"comment\">// Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime</span></span><br><span class=\"line\">\t<span class=\"comment\">// (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (beanFactory.getTempClassLoader() == <span class=\"keyword\">null</span> &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class=\"line\">\t\tbeanFactory.addBeanPostProcessor(<span class=\"keyword\">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class=\"line\">\t\tbeanFactory.setTempClassLoader(<span class=\"keyword\">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"invokeBeanFactoryPostProcessors-beanFactory\"><a href=\"#invokeBeanFactoryPostProcessors-beanFactory\" class=\"headerlink\" title=\"invokeBeanFactoryPostProcessors(beanFactory)\"></a>invokeBeanFactoryPostProcessors(beanFactory)</h3><p>调用工厂后处理器:根据反射机制从BeanDefinitionRegistry 中找出所有实现了BeanFactoryPostProcessor接口的Bean,并调用其postProcessBeanFactory0接口方法。</p>\n<h3 id=\"registerBeanPostProcessors-beanFactory\"><a href=\"#registerBeanPostProcessors-beanFactory\" class=\"headerlink\" title=\"registerBeanPostProcessors(beanFactory)\"></a>registerBeanPostProcessors(beanFactory)</h3><p>注册Bean后处理器:根据反射机制从BeanDefinitionRegistry 中找出所有实现了BeanPostProcessor 接口的Bean,并将它们注册到容器Bean后处理器的注册表中。</p>\n<p>在Spring容器中找出实现了BeanFactoryPostProcessor接口的processor并执行。Spring容器会委托给PostProcessorRegistrationDelegate的invokeBeanFactoryPostProcessors方法执行。</p>\n<p>介绍两个接口：</p>\n<ol>\n<li>BeanFactoryPostProcessor：用来修改Spring容器中已经存在的bean的定义，使用ConfigurableListableBeanFactory对bean进行处理</li>\n<li>BeanDefinitionRegistryPostProcessor：继承BeanFactoryPostProcessor，作用跟BeanFactoryPostProcessor一样，只不过是使用BeanDefinitionRegistry对bean进行处理</li>\n</ol>\n<p>基于web程序的Spring容器AnnotationConfigEmbeddedWebApplicationContext构造的时候，会初始化内部属性AnnotatedBeanDefinitionReader reader，这个reader构造的时候会在BeanFactory中注册一些post processor，包括BeanPostProcessor和BeanFactoryPostProcessor(比如ConfigurationClassPostProcessor、AutowiredAnnotationBeanPostProcessor)：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">AnnotationConfigUtils.registerAnnotationConfigProcessors(<span class=\"keyword\">this</span>.registry);</span><br></pre></td></tr></table></figure>\n<p>接下来从Spring容器内查找BeanFactoryPostProcessor接口的实现类，然后执行(如果processor已经执行过，则忽略)，这里的查找规则跟上面查找BeanDefinitionRegistryPostProcessor一样，先找PriorityOrdered，然后是Ordered，最后是两者都没。</p>\n<p>这里需要说明的是<strong>ConfigurationClassPostProcessor</strong>这个processor是<strong>优先级最高</strong>的被执行的processor(实现了PriorityOrdered接口)。这个ConfigurationClassPostProcessor会去BeanFactory中找出所有有@Configuration注解的bean，然后使用<strong>ConfigurationClassParser</strong>去解析这个类。<strong>ConfigurationClassParser内部有个Map类型的configurationClasses属性用于保存解析的类，ConfigurationClass是一个对要解析的配置类的封装，内部存储了配置类的注解信息、被@Bean注解修饰的方法、@ImportResource注解修饰的信息、ImportBeanDefinitionRegistrar等都存储在这个封装类中</strong>。</p>\n<p>这里ConfigurationClassPostProcessor最先被处理还有另外一个原因是如果程序中有自定义的BeanFactoryPostProcessor，那么这个PostProcessor首先得通过ConfigurationClassPostProcessor被解析出来，然后才能被Spring容器找到并执行。(ConfigurationClassPostProcessor不先执行的话，这个Processor是不会被解析的，不会被解析的话也就不会执行了)。</p>\n<p>在我们的程序中，只有主类CoreApplication有@Configuration注解(@SpringBootApplication注解带有@Configuration注解)，所以这个配置类会被ConfigurationClassParser的parse(set<beandefinitionholder>)方法解析,这个方法又会递归调用parse(AnnotationMetadate,String)，调用processConfigurationClass(ConfigurationClass)   ConfigurationClass可以有多种创建方法，最终实际调用doProcessConfigurationClass（ConfigurationClass,SourceClass）方法。</beandefinitionholder></p>\n<h3 id=\"initMessageSource\"><a href=\"#initMessageSource\" class=\"headerlink\" title=\"initMessageSource()\"></a>initMessageSource()</h3><p>初始化消息源:初始化容器的国际化消息资源。初始化应用上下文事件广播器。</p>\n<h3 id=\"onRefresh\"><a href=\"#onRefresh\" class=\"headerlink\" title=\"onRefresh()\"></a>onRefresh()</h3><p>初始化其他特殊的Bean: 这是一个钩子方法，子类可以借助这个方法执行一些特殊的操作，如AbstractRefreshableWebApplicationContext 就使用该方法执行初始化ThemeSource的操作。</p>\n<h3 id=\"registerListeners\"><a href=\"#registerListeners\" class=\"headerlink\" title=\"registerListeners()\"></a>registerListeners()</h3><p>注册事件监听器。</p>\n<h3 id=\"finishBeanFactoryInitialization-beanFactory\"><a href=\"#finishBeanFactoryInitialization-beanFactory\" class=\"headerlink\" title=\"finishBeanFactoryInitialization(beanFactory)\"></a>finishBeanFactoryInitialization(beanFactory)</h3><p>初始化所有单实例的Bean,使用懒加载模式的Bean除外:初始化Bean后，将它们放入Spring容器的缓存池中。</p>\n<h3 id=\"finishRefresh\"><a href=\"#finishRefresh\" class=\"headerlink\" title=\"finishRefresh()\"></a>finishRefresh()</h3><p>发布上下文刷新事件:创建上下文刷新事件，事件广播器负责将这些事件广播到每个注册的事件监听器中。</p>\n<h3 id=\"resetCommonCaches\"><a href=\"#resetCommonCaches\" class=\"headerlink\" title=\"resetCommonCaches()\"></a>resetCommonCaches()</h3><p>重置Spring在初始化IOC容器过程中的缓存。</p>\n<p>resfresh（）方法在一个项目启动时会启动2次，第二次加载时加载Serlvet相关bean和Web监听器等。</p>\n<h1 id=\"流程整理\"><a href=\"#流程整理\" class=\"headerlink\" title=\"流程整理\"></a>流程整理</h1><p><img src=\"http://epoch-night.oss-cn-hangzhou.aliyuncs.com/PostImg/process.png\" alt=\"process\"></p>\n<p>Spring协调多个组件共同完成整个IOC启动，上图描述了从加载配置文件到实例化一个Bean的过程。</p>\n<ol>\n<li><p>Rourelade从存储介质中加载sping配置信息并使用Rsouce表示这个配置文件资源。</p>\n</li>\n<li><p>BeanDeinitionReader 读取Resource所指向的配置文件资源，然后解析配置文件。配置文件中的每个bean解析成一个 BeanDefinition 对象，并保存到BeanDefinitionRegistry中。</p>\n</li>\n<li><p>容器扫描BeanDefinitionRegistry中的BeanDefinition, 使用Java反射机制自动识别出Bean工厂后处理器( 实现BeanFactoryPostProcessor接口的Bean)，然后调用这些Bean工厂后处理器对BeanDefinitionRegstry中的BeanDefinition 进行加工处理。主要总结完成以下两项工作:</p>\n<p>①对使用占位符的-bean元素标签进行解析，得到最终的配置值。 这意味着对一些半成品式的BeanDefinition对象进行加工处理并得到成品的BeanDefnition对象。</p>\n<p>②对BeanDefnitionRegisty中的BeanDefnition进行扫描，通过Java反射机制找出所有属性编辑器的Bean (实现jabcans PopertyEditor接口的Bean),并自动将它们注册到Spring容器的属性编辑器注册表中(ProetyEdiorRegisty)</p>\n</li>\n<li><p>Spring 容器从BeanDefnitionRegistry中取出加工后的BeanDeinition,并调用InstantiationStrategy着手进行Bean实例化的工作。</p>\n</li>\n<li><p>在实例化Bean时，Spring容器使用BeanWrapper对Bean进行封装。BeanWrapper提供了很多以Java反射机制操作Bean的方法，它将结合该Bean的BeanDefnition及容器中的属性编辑器，完成Bean属性注入工作。</p>\n</li>\n<li><p>利用容器中注册的Bean后处理器(实现BeanPstProcessor接口的Bean)对已经完成属性设置工作的Bean进行后续加工，直接装配出一个准备就绪的Bean。</p>\n<p>Spring容器堪称部设计精密的机器， 其内部拥有众多的组件和装置。Spring 的高明之处在于，它使用众多接口描绘出了所有装置的协作蓝图，构建好Spring的骨架，继而通过继承体系层层推演、不断丰富，最终让Spring成为有血有肉的完整的框架。所以在查看Spring框架的源码时，有两条清晰可见的脉络:</p>\n</li>\n<li><p>接口层描述了容器的重要组件及组件间的协作关系。</p>\n</li>\n<li>继承体系逐步实现组件的各项功能。</li>\n</ol>\n<p>接口层清晰地勾勒出Spring框架的高层功能，框架整体结构非常清晰。有了接口层抽象的描述后，不但Spring自己可以提供具体的实现，任何第三方组织也可以提供不同的实现，可以说Spring完善的接口层使框架的扩展性得到了很好的保证。纵向继承体系的逐步扩展，分步骤地实现框架的功能，这种实现方案保证了框架功能不会堆积在某些类身上，从而造成过重的代码逻辑负载，框架的复杂度被完美地分解开了。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>整个Spring的启动还是非常复杂，这里只是大概的介绍一下整体流程，具体的细节还需要继续研磨观看。</p>\n<blockquote>\n<p>参考: 《Spring技术内幕》、《精通Spring 4.x 企业应用开发实战》</p>\n<p><a href=\"http://fangjian0423.github.io/2017/05/10/springboot-context-refresh/\" target=\"_blank\" rel=\"noopener\">SpringBoot源码分析之Spring容器的refresh过程</a></p>\n<p><a href=\"http://zhangh.tk/2017/07/16/%E3%80%90Spring%E3%80%91%E5%AE%B9%E5%99%A8%E5%88%B7%E6%96%B0/#initMessageSource\" target=\"_blank\" rel=\"noopener\">[Spring]容器刷新</a></p>\n</blockquote>\n"},{"layout":"post","title":"Spring | DispatcherServlet源码分析(上)","date":"2017-11-20T11:13:00.000Z","author":"Gubaidan","header-img":"/Header/l8Qo5NqYG_k.png","cdn":"header-on","_content":"\n# 说明\n\nDispatcherServlet是SpringMVC的核心分发器，它实现了请求分发，是处理请求的入口，本篇将深入源码分析它的初始化阶段。\n\n 下图为DispatcherServlet 继承关系图：\n\n<img style=\"width:90%;\" src=\"http://epoch-night.oss-cn-hangzhou.aliyuncs.com/PostImg/servlet.png\"/>\n\n既然DispatcherServlet是一个Servlet，那么初始化的时候一定会执行init方法，查看源码发现DispatcherServlet的init方法继承自HttpServletBean，具体代码如下所示。\n\n```java\n/**\n* 方法位置：HttpServletBean#init() \n*/\n@Override\npublic final void init() throws ServletException {\n\tif (logger.isDebugEnabled()) {\n\t\tlogger.debug(\"Initializing servlet '\" + getServletName() + \"'\");\n\t}\n\n\t// Set bean properties from init parameters.\n\ttry {\n\t\t//从web.xml中获取初始化参数并生成一个ServletConfigPropertyValues对象\n\t\tPropertyValues pvs = new ServletConfigPropertyValues(getServletConfig(), this.requiredProperties);\n\t\t//将当前对象封装为一个BeanWrapper，此时bena属性还未设置\n\t\tBeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(this);\n\t\tResourceLoader resourceLoader = new ServletContextResourceLoader(getServletContext());\n\t\tbw.registerCustomEditor(Resource.class, new ResourceEditor(resourceLoader, getEnvironment()));\n\t\t//初始化BeanWrapper\n\t\tinitBeanWrapper(bw);\n\t\t//将构造器的属性实例设置到BeanWrapper准备下一步包装\n\t\tbw.setPropertyValues(pvs, true);\n\t}\n\tcatch (BeansException ex) {\n\t\tif (logger.isErrorEnabled()) {\n\t\t\tlogger.error(\"Failed to set bean properties on servlet '\" + getServletName() + \"'\", ex);\n\t\t}\n\t\tthrow ex;\n\t}\n\n\t//空实现，可由子类实现\n\tinitServletBean();\n\n\tif (logger.isDebugEnabled()) {\n\t\tlogger.debug(\"Servlet '\" + getServletName() + \"' configured successfully\");\n\t}\n}\n```\n\n上述代码具体加载的web.xml初始化参数如下。\n\n```xml\n<!-- springmvc前端控制器 -->\n<servlet>\n    <servlet-name>springmvc</servlet-name>\n    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n    <!-- contextConfigLocation配置springmvc加载的配置文件（配置处理器映射器、适配器等等） 如果不配置contextConfigLocation，默认加载的是/WEB-INF/servlet名称-serlvet.xml（springmvc-servlet.xml） -->\n    <init-param>\n        <param-name>contextConfigLocation</param-name>\n        <param-value>classpath*:spring/springmvc.xml</param-value>\n    </init-param>\n</servlet>\n<servlet-mapping>\n    <servlet-name>springmvc</servlet-name>\n    <url-pattern>/</url-pattern>\n</servlet-mapping>\n```\n\n上面示例配置中，配置了一个 contextConfigLocation参数，该参数用于构造SpringMVC上下文。\n\n对于initServletBean方法，FrameworkServlet中进行了重写，具体代码如下图所示（就是init()方法中空实现的那个）。\n\n```java\n/**\n* 方法位置：FrameworkServlet#initServletBean() \n*/\n@Override\nprotected final void initServletBean() throws ServletException {\n\tgetServletContext().log(\"Initializing Spring FrameworkServlet '\" + getServletName() + \"'\");\n\tif (this.logger.isInfoEnabled()) {\n\t\tthis.logger.info(\"FrameworkServlet '\" + getServletName() + \"': initialization started\");\n\t}\n\tlong startTime = System.currentTimeMillis();\n\n\ttry {\n\t\t//初始化WebApplicationContext，此处的WebApplicationContext最终会放入一个servletcontext\n\t\tthis.webApplicationContext = initWebApplicationContext();\n            //空实现，子类可重写\n\t\t\tinitFrameworkServlet();\n\t\t}\n\tcatch (ServletException ex) {\n\t\t\tthis.logger.error(\"Context initialization failed\", ex);\n\t\t\tthrow ex;\n\t\t}\n\tcatch (RuntimeException ex) {\n\t\t\tthis.logger.error(\"Context initialization failed\", ex);\n\t\t\tthrow ex;\n\t\t}\n\n\tif (this.logger.isInfoEnabled()) {\n\t\tlong elapsedTime = System.currentTimeMillis() - startTime;\n\t\tthis.logger.info(\"FrameworkServlet '\" + getServletName() + \"': initialization completed in \" +\n\t\t\t\t\telapsedTime + \" ms\");\n\t}\n}\n```\n\ninitWebApplicationContext方法主要代码如下图所示。 \n\n```java\n/**\n* 方法位置：FrameworkServlet#initServletBean() \n*/\nprotected WebApplicationContext initWebApplicationContext() {\n    //在getServletContext 中查找WebApplicationContext，如果web.xml配置了contextLoaderListener\n    //和contetConfigLocation则rootContext 是由xml配置了contextLoaderListener 监听的上下文\n\tWebApplicationContext rootContext =\n\t\t\t\tWebApplicationContextUtils.getWebApplicationContext(getServletContext());\n\tWebApplicationContext wac = null;\n\t//DispatcherServlet的构造方法有一个是由WebApplicationContext进行创建的构造方法，如果使用这种\n    //方式，则由下面的代码生成实例\n\tif (this.webApplicationContext != null) {\n\t\t// A context instance was injected at construction time -> use it\n\t\twac = this.webApplicationContext;\n\t\tif (wac instanceof ConfigurableWebApplicationContext) {\n\t\t\tConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac;\n\t\t\tif (!cwac.isActive()) {\n\t\t\t\t// The context has not yet been refreshed -> provide services such as\n\t\t\t\t// setting the parent context, setting the application context id, etc\n\t\t\t\tif (cwac.getParent() == null) {\n\t\t\t\t\t// The context instance was injected without an explicit parent -> set\n\t\t\t\t\t// the root application context (if any; may be null) as the parent\n\t\t\t\t\tcwac.setParent(rootContext);\n\t\t\t\t}\n\t\t\t\tconfigureAndRefreshWebApplicationContext(cwac);\n\t\t\t}\n\t\t}\n\t}\n\tif (wac == null) {\n\t\t// 如果执行到这里wac还是为空，再次到ServletContext中查找，没有报错\n\t\twac = findWebApplicationContext();\n\t}\n\tif (wac == null) {\n\t\t// 如果还是为空，就创建一个局部变量\n\t\twac = createWebApplicationContext(rootContext);\n\t}\n\n\tif (!this.refreshEventReceived) {\n\t\t//这里手动刷新，交给子类实现\n\t\tonRefresh(wac);\n\t}\n\n\tif (this.publishContext) {\n\t\t// 将这里的WebApplicationContext 放入 servletContext\n\t\tString attrName = getServletContextAttributeName();\n\t\tgetServletContext().setAttribute(attrName, wac);\n\t\tif (this.logger.isDebugEnabled()) {\n\t\t\tthis.logger.debug(\"Published WebApplicationContext of servlet '\" + getServletName() +\n\t\t\t\t\t\t\"' as ServletContext attribute with name [\" + attrName + \"]\");\n\t\t}\n\t}\n\n\treturn wac;\n}\n```\n\n如果web.xml中配置了如下参数，将会在应用启动的时候初始化一个WebApplicationContext实例，并将其保存在ServletContext中。 \n\n```xml\n<listener>\n      <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>\n</listener>\n\n```\n\n上图中的代码很容易理解，接下来进入DispatcherServlet的onRefresh方法，具体代码如下图所示。\n\n```java\n/**\n* 方法位置：DispatcherServlet#onRefresh() \n*/\n@Override\nprotected void onRefresh(ApplicationContext context) {\n\tinitStrategies(context);\n}\n\n/**\n * Initialize the strategy objects that this servlet uses.\n * <p>May be overridden in subclasses in order to initialize further strategy objects.\n */\nprotected void initStrategies(ApplicationContext context) {\n\tinitMultipartResolver(context);\n\tinitLocaleResolver(context);\n\tinitThemeResolver(context);\n\tinitHandlerMappings(context);\n\tinitHandlerAdapters(context);\n\tinitHandlerExceptionResolvers(context);\n\tinitRequestToViewNameTranslator(context);\n\tinitViewResolvers(context);\n\tinitFlashMapManager(context);\n}\n```\n\ninitStrategies方法中的各个方法，从方法名上可以很容易理解其作用，大部分的执行逻辑都是先从WebApplicationContext中查找，找不到的情况下再加载和DispatcherServlet同目录下的DispatcherServlet.properties中的各个策略，如初始化HandlerMapping，具体如下图所示。 \n\n```java\nprivate void initHandlerMappings(ApplicationContext context) {\n\tthis.handlerMappings = null;\n\n\tif (this.detectAllHandlerMappings) {\n\t\t// Find all HandlerMappings in the ApplicationContext, including ancestor contexts.\n\t\tMap<String, HandlerMapping> matchingBeans =\n\t\t\t\tBeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerMapping.class, true, false);\n\t\tif (!matchingBeans.isEmpty()) {\n\t\t\tthis.handlerMappings = new ArrayList<HandlerMapping>(matchingBeans.values());\n\t\t\t// We keep HandlerMappings in sorted order.\n\t\t\tAnnotationAwareOrderComparator.sort(this.handlerMappings);\n\t\t}\n\t}\n\telse {\n\t\ttry {\n\t\t\tHandlerMapping hm = context.getBean(HANDLER_MAPPING_BEAN_NAME, HandlerMapping.class);\n\t\t\tthis.handlerMappings = Collections.singletonList(hm);\n\t\t}\n\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t// Ignore, we'll add a default HandlerMapping later.\n\t\t}\n\t}\n\n\t// 加载和DispatcherServlet同目录下的DispatcherServlet.properties中的各个策略\n\tif (this.handlerMappings == null) {\n\t\tthis.handlerMappings = getDefaultStrategies(context, HandlerMapping.class);\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"No HandlerMappings found in servlet '\" + getServletName() + \"': using default\");\n\t\t}\n\t}\n}\n```\n\n\n\n# 总结\n\n首先，Spring框架在启动的时候IOC容器会遍历IOC容器中的所有bean，对标注了@Controller或@RequestMapping注解的类中方法进行遍历，将类和方法上的@RequestMapping注解中的value值进行合并，使用@RequestMapping注解的相关参数值(如value、method等)封装一个RequestMappingInfo，将这个Controller实例、方法及方法参数信息(类型、注解等)封装到HandlerMethod中，然后以RequestMappingInfo为key，HandlerMethod为value存到一个以Map为结构的handlerMethods中。\n\n接着，将@RequestMapping注解中的value(即请求路径)值取出，即url，然后以url为key，以RequestMappingInfo为value，存到一个以Map为结构的urlMap属性中。\n\n客户端发起请求的时候，根据请求的URL到urlMap中查找，找到RequestMappingInfo，然后根据RequestMappingInfo到handlerMethods中查找，找到对应的HandlerMethod，接着将HandlerMethod封装到HandlerExecutionChain；接着遍历容器中所有HandlerAdapter实现类，找到支持这次请求的HandlerAdapter，如RequestMappingHandlerAdapter，然后执行SpringMVC拦截器的前置方法(preHandle方法)，然后对请求参数解析及转换，然后(使用反射)调用具体Controller的对应方法返回一个ModelAndView对象，执行拦截器的后置方法(postHandle方法)，然后对返回的结果进行处理，最后执行afterCompletion方法。\n\n> 参考：《Spring技术内幕》、《精通Spring 4.x 企业应用开发实战》\n\n \n\n \n\n \n\n ","source":"_posts/2017-11-20-DispatcherServlet.markdown","raw":"---\nlayout: post\ntitle: \"Spring | DispatcherServlet源码分析(上)\"\ndate: 2017-11-20 19:13\nauthor: \"Gubaidan\"\nheader-img: \"/Header/l8Qo5NqYG_k.png\"\ncdn: 'header-on'\ntags:\n\t- Spring\n---\n\n# 说明\n\nDispatcherServlet是SpringMVC的核心分发器，它实现了请求分发，是处理请求的入口，本篇将深入源码分析它的初始化阶段。\n\n 下图为DispatcherServlet 继承关系图：\n\n<img style=\"width:90%;\" src=\"http://epoch-night.oss-cn-hangzhou.aliyuncs.com/PostImg/servlet.png\"/>\n\n既然DispatcherServlet是一个Servlet，那么初始化的时候一定会执行init方法，查看源码发现DispatcherServlet的init方法继承自HttpServletBean，具体代码如下所示。\n\n```java\n/**\n* 方法位置：HttpServletBean#init() \n*/\n@Override\npublic final void init() throws ServletException {\n\tif (logger.isDebugEnabled()) {\n\t\tlogger.debug(\"Initializing servlet '\" + getServletName() + \"'\");\n\t}\n\n\t// Set bean properties from init parameters.\n\ttry {\n\t\t//从web.xml中获取初始化参数并生成一个ServletConfigPropertyValues对象\n\t\tPropertyValues pvs = new ServletConfigPropertyValues(getServletConfig(), this.requiredProperties);\n\t\t//将当前对象封装为一个BeanWrapper，此时bena属性还未设置\n\t\tBeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(this);\n\t\tResourceLoader resourceLoader = new ServletContextResourceLoader(getServletContext());\n\t\tbw.registerCustomEditor(Resource.class, new ResourceEditor(resourceLoader, getEnvironment()));\n\t\t//初始化BeanWrapper\n\t\tinitBeanWrapper(bw);\n\t\t//将构造器的属性实例设置到BeanWrapper准备下一步包装\n\t\tbw.setPropertyValues(pvs, true);\n\t}\n\tcatch (BeansException ex) {\n\t\tif (logger.isErrorEnabled()) {\n\t\t\tlogger.error(\"Failed to set bean properties on servlet '\" + getServletName() + \"'\", ex);\n\t\t}\n\t\tthrow ex;\n\t}\n\n\t//空实现，可由子类实现\n\tinitServletBean();\n\n\tif (logger.isDebugEnabled()) {\n\t\tlogger.debug(\"Servlet '\" + getServletName() + \"' configured successfully\");\n\t}\n}\n```\n\n上述代码具体加载的web.xml初始化参数如下。\n\n```xml\n<!-- springmvc前端控制器 -->\n<servlet>\n    <servlet-name>springmvc</servlet-name>\n    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n    <!-- contextConfigLocation配置springmvc加载的配置文件（配置处理器映射器、适配器等等） 如果不配置contextConfigLocation，默认加载的是/WEB-INF/servlet名称-serlvet.xml（springmvc-servlet.xml） -->\n    <init-param>\n        <param-name>contextConfigLocation</param-name>\n        <param-value>classpath*:spring/springmvc.xml</param-value>\n    </init-param>\n</servlet>\n<servlet-mapping>\n    <servlet-name>springmvc</servlet-name>\n    <url-pattern>/</url-pattern>\n</servlet-mapping>\n```\n\n上面示例配置中，配置了一个 contextConfigLocation参数，该参数用于构造SpringMVC上下文。\n\n对于initServletBean方法，FrameworkServlet中进行了重写，具体代码如下图所示（就是init()方法中空实现的那个）。\n\n```java\n/**\n* 方法位置：FrameworkServlet#initServletBean() \n*/\n@Override\nprotected final void initServletBean() throws ServletException {\n\tgetServletContext().log(\"Initializing Spring FrameworkServlet '\" + getServletName() + \"'\");\n\tif (this.logger.isInfoEnabled()) {\n\t\tthis.logger.info(\"FrameworkServlet '\" + getServletName() + \"': initialization started\");\n\t}\n\tlong startTime = System.currentTimeMillis();\n\n\ttry {\n\t\t//初始化WebApplicationContext，此处的WebApplicationContext最终会放入一个servletcontext\n\t\tthis.webApplicationContext = initWebApplicationContext();\n            //空实现，子类可重写\n\t\t\tinitFrameworkServlet();\n\t\t}\n\tcatch (ServletException ex) {\n\t\t\tthis.logger.error(\"Context initialization failed\", ex);\n\t\t\tthrow ex;\n\t\t}\n\tcatch (RuntimeException ex) {\n\t\t\tthis.logger.error(\"Context initialization failed\", ex);\n\t\t\tthrow ex;\n\t\t}\n\n\tif (this.logger.isInfoEnabled()) {\n\t\tlong elapsedTime = System.currentTimeMillis() - startTime;\n\t\tthis.logger.info(\"FrameworkServlet '\" + getServletName() + \"': initialization completed in \" +\n\t\t\t\t\telapsedTime + \" ms\");\n\t}\n}\n```\n\ninitWebApplicationContext方法主要代码如下图所示。 \n\n```java\n/**\n* 方法位置：FrameworkServlet#initServletBean() \n*/\nprotected WebApplicationContext initWebApplicationContext() {\n    //在getServletContext 中查找WebApplicationContext，如果web.xml配置了contextLoaderListener\n    //和contetConfigLocation则rootContext 是由xml配置了contextLoaderListener 监听的上下文\n\tWebApplicationContext rootContext =\n\t\t\t\tWebApplicationContextUtils.getWebApplicationContext(getServletContext());\n\tWebApplicationContext wac = null;\n\t//DispatcherServlet的构造方法有一个是由WebApplicationContext进行创建的构造方法，如果使用这种\n    //方式，则由下面的代码生成实例\n\tif (this.webApplicationContext != null) {\n\t\t// A context instance was injected at construction time -> use it\n\t\twac = this.webApplicationContext;\n\t\tif (wac instanceof ConfigurableWebApplicationContext) {\n\t\t\tConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac;\n\t\t\tif (!cwac.isActive()) {\n\t\t\t\t// The context has not yet been refreshed -> provide services such as\n\t\t\t\t// setting the parent context, setting the application context id, etc\n\t\t\t\tif (cwac.getParent() == null) {\n\t\t\t\t\t// The context instance was injected without an explicit parent -> set\n\t\t\t\t\t// the root application context (if any; may be null) as the parent\n\t\t\t\t\tcwac.setParent(rootContext);\n\t\t\t\t}\n\t\t\t\tconfigureAndRefreshWebApplicationContext(cwac);\n\t\t\t}\n\t\t}\n\t}\n\tif (wac == null) {\n\t\t// 如果执行到这里wac还是为空，再次到ServletContext中查找，没有报错\n\t\twac = findWebApplicationContext();\n\t}\n\tif (wac == null) {\n\t\t// 如果还是为空，就创建一个局部变量\n\t\twac = createWebApplicationContext(rootContext);\n\t}\n\n\tif (!this.refreshEventReceived) {\n\t\t//这里手动刷新，交给子类实现\n\t\tonRefresh(wac);\n\t}\n\n\tif (this.publishContext) {\n\t\t// 将这里的WebApplicationContext 放入 servletContext\n\t\tString attrName = getServletContextAttributeName();\n\t\tgetServletContext().setAttribute(attrName, wac);\n\t\tif (this.logger.isDebugEnabled()) {\n\t\t\tthis.logger.debug(\"Published WebApplicationContext of servlet '\" + getServletName() +\n\t\t\t\t\t\t\"' as ServletContext attribute with name [\" + attrName + \"]\");\n\t\t}\n\t}\n\n\treturn wac;\n}\n```\n\n如果web.xml中配置了如下参数，将会在应用启动的时候初始化一个WebApplicationContext实例，并将其保存在ServletContext中。 \n\n```xml\n<listener>\n      <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>\n</listener>\n\n```\n\n上图中的代码很容易理解，接下来进入DispatcherServlet的onRefresh方法，具体代码如下图所示。\n\n```java\n/**\n* 方法位置：DispatcherServlet#onRefresh() \n*/\n@Override\nprotected void onRefresh(ApplicationContext context) {\n\tinitStrategies(context);\n}\n\n/**\n * Initialize the strategy objects that this servlet uses.\n * <p>May be overridden in subclasses in order to initialize further strategy objects.\n */\nprotected void initStrategies(ApplicationContext context) {\n\tinitMultipartResolver(context);\n\tinitLocaleResolver(context);\n\tinitThemeResolver(context);\n\tinitHandlerMappings(context);\n\tinitHandlerAdapters(context);\n\tinitHandlerExceptionResolvers(context);\n\tinitRequestToViewNameTranslator(context);\n\tinitViewResolvers(context);\n\tinitFlashMapManager(context);\n}\n```\n\ninitStrategies方法中的各个方法，从方法名上可以很容易理解其作用，大部分的执行逻辑都是先从WebApplicationContext中查找，找不到的情况下再加载和DispatcherServlet同目录下的DispatcherServlet.properties中的各个策略，如初始化HandlerMapping，具体如下图所示。 \n\n```java\nprivate void initHandlerMappings(ApplicationContext context) {\n\tthis.handlerMappings = null;\n\n\tif (this.detectAllHandlerMappings) {\n\t\t// Find all HandlerMappings in the ApplicationContext, including ancestor contexts.\n\t\tMap<String, HandlerMapping> matchingBeans =\n\t\t\t\tBeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerMapping.class, true, false);\n\t\tif (!matchingBeans.isEmpty()) {\n\t\t\tthis.handlerMappings = new ArrayList<HandlerMapping>(matchingBeans.values());\n\t\t\t// We keep HandlerMappings in sorted order.\n\t\t\tAnnotationAwareOrderComparator.sort(this.handlerMappings);\n\t\t}\n\t}\n\telse {\n\t\ttry {\n\t\t\tHandlerMapping hm = context.getBean(HANDLER_MAPPING_BEAN_NAME, HandlerMapping.class);\n\t\t\tthis.handlerMappings = Collections.singletonList(hm);\n\t\t}\n\t\tcatch (NoSuchBeanDefinitionException ex) {\n\t\t\t// Ignore, we'll add a default HandlerMapping later.\n\t\t}\n\t}\n\n\t// 加载和DispatcherServlet同目录下的DispatcherServlet.properties中的各个策略\n\tif (this.handlerMappings == null) {\n\t\tthis.handlerMappings = getDefaultStrategies(context, HandlerMapping.class);\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"No HandlerMappings found in servlet '\" + getServletName() + \"': using default\");\n\t\t}\n\t}\n}\n```\n\n\n\n# 总结\n\n首先，Spring框架在启动的时候IOC容器会遍历IOC容器中的所有bean，对标注了@Controller或@RequestMapping注解的类中方法进行遍历，将类和方法上的@RequestMapping注解中的value值进行合并，使用@RequestMapping注解的相关参数值(如value、method等)封装一个RequestMappingInfo，将这个Controller实例、方法及方法参数信息(类型、注解等)封装到HandlerMethod中，然后以RequestMappingInfo为key，HandlerMethod为value存到一个以Map为结构的handlerMethods中。\n\n接着，将@RequestMapping注解中的value(即请求路径)值取出，即url，然后以url为key，以RequestMappingInfo为value，存到一个以Map为结构的urlMap属性中。\n\n客户端发起请求的时候，根据请求的URL到urlMap中查找，找到RequestMappingInfo，然后根据RequestMappingInfo到handlerMethods中查找，找到对应的HandlerMethod，接着将HandlerMethod封装到HandlerExecutionChain；接着遍历容器中所有HandlerAdapter实现类，找到支持这次请求的HandlerAdapter，如RequestMappingHandlerAdapter，然后执行SpringMVC拦截器的前置方法(preHandle方法)，然后对请求参数解析及转换，然后(使用反射)调用具体Controller的对应方法返回一个ModelAndView对象，执行拦截器的后置方法(postHandle方法)，然后对返回的结果进行处理，最后执行afterCompletion方法。\n\n> 参考：《Spring技术内幕》、《精通Spring 4.x 企业应用开发实战》\n\n \n\n \n\n \n\n ","slug":"2017-11-20-DispatcherServlet","published":1,"updated":"2019-05-05T12:34:39.755Z","comments":1,"photos":[],"link":"","_id":"cjvayvwg9001wm46aad8si4pa","content":"<h1 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h1><p>DispatcherServlet是SpringMVC的核心分发器，它实现了请求分发，是处理请求的入口，本篇将深入源码分析它的初始化阶段。</p>\n<p> 下图为DispatcherServlet 继承关系图：</p>\n<p><img style=\"width:90%;\" src=\"http://epoch-night.oss-cn-hangzhou.aliyuncs.com/PostImg/servlet.png\"></p>\n<p>既然DispatcherServlet是一个Servlet，那么初始化的时候一定会执行init方法，查看源码发现DispatcherServlet的init方法继承自HttpServletBean，具体代码如下所示。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 方法位置：HttpServletBean#init() </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> ServletException </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">\t\tlogger.debug(<span class=\"string\">\"Initializing servlet '\"</span> + getServletName() + <span class=\"string\">\"'\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Set bean properties from init parameters.</span></span><br><span class=\"line\">\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//从web.xml中获取初始化参数并生成一个ServletConfigPropertyValues对象</span></span><br><span class=\"line\">\t\tPropertyValues pvs = <span class=\"keyword\">new</span> ServletConfigPropertyValues(getServletConfig(), <span class=\"keyword\">this</span>.requiredProperties);</span><br><span class=\"line\">\t\t<span class=\"comment\">//将当前对象封装为一个BeanWrapper，此时bena属性还未设置</span></span><br><span class=\"line\">\t\tBeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">\t\tResourceLoader resourceLoader = <span class=\"keyword\">new</span> ServletContextResourceLoader(getServletContext());</span><br><span class=\"line\">\t\tbw.registerCustomEditor(Resource.class, <span class=\"keyword\">new</span> ResourceEditor(resourceLoader, getEnvironment()));</span><br><span class=\"line\">\t\t<span class=\"comment\">//初始化BeanWrapper</span></span><br><span class=\"line\">\t\tinitBeanWrapper(bw);</span><br><span class=\"line\">\t\t<span class=\"comment\">//将构造器的属性实例设置到BeanWrapper准备下一步包装</span></span><br><span class=\"line\">\t\tbw.setPropertyValues(pvs, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">catch</span> (BeansException ex) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (logger.isErrorEnabled()) &#123;</span><br><span class=\"line\">\t\t\tlogger.error(<span class=\"string\">\"Failed to set bean properties on servlet '\"</span> + getServletName() + <span class=\"string\">\"'\"</span>, ex);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> ex;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//空实现，可由子类实现</span></span><br><span class=\"line\">\tinitServletBean();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">\t\tlogger.debug(<span class=\"string\">\"Servlet '\"</span> + getServletName() + <span class=\"string\">\"' configured successfully\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码具体加载的web.xml初始化参数如下。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- springmvc前端控制器 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>springmvc<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- contextConfigLocation配置springmvc加载的配置文件（配置处理器映射器、适配器等等） 如果不配置contextConfigLocation，默认加载的是/WEB-INF/servlet名称-serlvet.xml（springmvc-servlet.xml） --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>contextConfigLocation<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>classpath*:spring/springmvc.xml<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>springmvc<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>上面示例配置中，配置了一个 contextConfigLocation参数，该参数用于构造SpringMVC上下文。</p>\n<p>对于initServletBean方法，FrameworkServlet中进行了重写，具体代码如下图所示（就是init()方法中空实现的那个）。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 方法位置：FrameworkServlet#initServletBean() </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">initServletBean</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> ServletException </span>&#123;</span><br><span class=\"line\">\tgetServletContext().log(<span class=\"string\">\"Initializing Spring FrameworkServlet '\"</span> + getServletName() + <span class=\"string\">\"'\"</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.logger.isInfoEnabled()) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.logger.info(<span class=\"string\">\"FrameworkServlet '\"</span> + getServletName() + <span class=\"string\">\"': initialization started\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">long</span> startTime = System.currentTimeMillis();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//初始化WebApplicationContext，此处的WebApplicationContext最终会放入一个servletcontext</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.webApplicationContext = initWebApplicationContext();</span><br><span class=\"line\">            <span class=\"comment\">//空实现，子类可重写</span></span><br><span class=\"line\">\t\t\tinitFrameworkServlet();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">catch</span> (ServletException ex) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>.logger.error(<span class=\"string\">\"Context initialization failed\"</span>, ex);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">throw</span> ex;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">catch</span> (RuntimeException ex) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>.logger.error(<span class=\"string\">\"Context initialization failed\"</span>, ex);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">throw</span> ex;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.logger.isInfoEnabled()) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">long</span> elapsedTime = System.currentTimeMillis() - startTime;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.logger.info(<span class=\"string\">\"FrameworkServlet '\"</span> + getServletName() + <span class=\"string\">\"': initialization completed in \"</span> +</span><br><span class=\"line\">\t\t\t\t\telapsedTime + <span class=\"string\">\" ms\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>initWebApplicationContext方法主要代码如下图所示。 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 方法位置：FrameworkServlet#initServletBean() </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> WebApplicationContext <span class=\"title\">initWebApplicationContext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//在getServletContext 中查找WebApplicationContext，如果web.xml配置了contextLoaderListener</span></span><br><span class=\"line\">    <span class=\"comment\">//和contetConfigLocation则rootContext 是由xml配置了contextLoaderListener 监听的上下文</span></span><br><span class=\"line\">\tWebApplicationContext rootContext =</span><br><span class=\"line\">\t\t\t\tWebApplicationContextUtils.getWebApplicationContext(getServletContext());</span><br><span class=\"line\">\tWebApplicationContext wac = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t<span class=\"comment\">//DispatcherServlet的构造方法有一个是由WebApplicationContext进行创建的构造方法，如果使用这种</span></span><br><span class=\"line\">    <span class=\"comment\">//方式，则由下面的代码生成实例</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.webApplicationContext != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// A context instance was injected at construction time -&gt; use it</span></span><br><span class=\"line\">\t\twac = <span class=\"keyword\">this</span>.webApplicationContext;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (wac <span class=\"keyword\">instanceof</span> ConfigurableWebApplicationContext) &#123;</span><br><span class=\"line\">\t\t\tConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!cwac.isActive()) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// The context has not yet been refreshed -&gt; provide services such as</span></span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// setting the parent context, setting the application context id, etc</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (cwac.getParent() == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// The context instance was injected without an explicit parent -&gt; set</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// the root application context (if any; may be null) as the parent</span></span><br><span class=\"line\">\t\t\t\t\tcwac.setParent(rootContext);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tconfigureAndRefreshWebApplicationContext(cwac);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (wac == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 如果执行到这里wac还是为空，再次到ServletContext中查找，没有报错</span></span><br><span class=\"line\">\t\twac = findWebApplicationContext();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (wac == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 如果还是为空，就创建一个局部变量</span></span><br><span class=\"line\">\t\twac = createWebApplicationContext(rootContext);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.refreshEventReceived) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//这里手动刷新，交给子类实现</span></span><br><span class=\"line\">\t\tonRefresh(wac);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.publishContext) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 将这里的WebApplicationContext 放入 servletContext</span></span><br><span class=\"line\">\t\tString attrName = getServletContextAttributeName();</span><br><span class=\"line\">\t\tgetServletContext().setAttribute(attrName, wac);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>.logger.debug(<span class=\"string\">\"Published WebApplicationContext of servlet '\"</span> + getServletName() +</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"string\">\"' as ServletContext attribute with name [\"</span> + attrName + <span class=\"string\">\"]\"</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> wac;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果web.xml中配置了如下参数，将会在应用启动的时候初始化一个WebApplicationContext实例，并将其保存在ServletContext中。 </p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">listener</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class=\"tag\">&lt;/<span class=\"name\">listener-class</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">listener</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>上图中的代码很容易理解，接下来进入DispatcherServlet的onRefresh方法，具体代码如下图所示。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 方法位置：DispatcherServlet#onRefresh() </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onRefresh</span><span class=\"params\">(ApplicationContext context)</span> </span>&#123;</span><br><span class=\"line\">\tinitStrategies(context);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Initialize the strategy objects that this servlet uses.</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;May be overridden in subclasses in order to initialize further strategy objects.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">initStrategies</span><span class=\"params\">(ApplicationContext context)</span> </span>&#123;</span><br><span class=\"line\">\tinitMultipartResolver(context);</span><br><span class=\"line\">\tinitLocaleResolver(context);</span><br><span class=\"line\">\tinitThemeResolver(context);</span><br><span class=\"line\">\tinitHandlerMappings(context);</span><br><span class=\"line\">\tinitHandlerAdapters(context);</span><br><span class=\"line\">\tinitHandlerExceptionResolvers(context);</span><br><span class=\"line\">\tinitRequestToViewNameTranslator(context);</span><br><span class=\"line\">\tinitViewResolvers(context);</span><br><span class=\"line\">\tinitFlashMapManager(context);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>initStrategies方法中的各个方法，从方法名上可以很容易理解其作用，大部分的执行逻辑都是先从WebApplicationContext中查找，找不到的情况下再加载和DispatcherServlet同目录下的DispatcherServlet.properties中的各个策略，如初始化HandlerMapping，具体如下图所示。 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">initHandlerMappings</span><span class=\"params\">(ApplicationContext context)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.handlerMappings = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.detectAllHandlerMappings) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// Find all HandlerMappings in the ApplicationContext, including ancestor contexts.</span></span><br><span class=\"line\">\t\tMap&lt;String, HandlerMapping&gt; matchingBeans =</span><br><span class=\"line\">\t\t\t\tBeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerMapping.class, <span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!matchingBeans.isEmpty()) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>.handlerMappings = <span class=\"keyword\">new</span> ArrayList&lt;HandlerMapping&gt;(matchingBeans.values());</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// We keep HandlerMappings in sorted order.</span></span><br><span class=\"line\">\t\t\tAnnotationAwareOrderComparator.sort(<span class=\"keyword\">this</span>.handlerMappings);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\tHandlerMapping hm = context.getBean(HANDLER_MAPPING_BEAN_NAME, HandlerMapping.class);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>.handlerMappings = Collections.singletonList(hm);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// Ignore, we'll add a default HandlerMapping later.</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 加载和DispatcherServlet同目录下的DispatcherServlet.properties中的各个策略</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.handlerMappings == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.handlerMappings = getDefaultStrategies(context, HandlerMapping.class);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">\t\t\tlogger.debug(<span class=\"string\">\"No HandlerMappings found in servlet '\"</span> + getServletName() + <span class=\"string\">\"': using default\"</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>首先，Spring框架在启动的时候IOC容器会遍历IOC容器中的所有bean，对标注了@Controller或@RequestMapping注解的类中方法进行遍历，将类和方法上的@RequestMapping注解中的value值进行合并，使用@RequestMapping注解的相关参数值(如value、method等)封装一个RequestMappingInfo，将这个Controller实例、方法及方法参数信息(类型、注解等)封装到HandlerMethod中，然后以RequestMappingInfo为key，HandlerMethod为value存到一个以Map为结构的handlerMethods中。</p>\n<p>接着，将@RequestMapping注解中的value(即请求路径)值取出，即url，然后以url为key，以RequestMappingInfo为value，存到一个以Map为结构的urlMap属性中。</p>\n<p>客户端发起请求的时候，根据请求的URL到urlMap中查找，找到RequestMappingInfo，然后根据RequestMappingInfo到handlerMethods中查找，找到对应的HandlerMethod，接着将HandlerMethod封装到HandlerExecutionChain；接着遍历容器中所有HandlerAdapter实现类，找到支持这次请求的HandlerAdapter，如RequestMappingHandlerAdapter，然后执行SpringMVC拦截器的前置方法(preHandle方法)，然后对请求参数解析及转换，然后(使用反射)调用具体Controller的对应方法返回一个ModelAndView对象，执行拦截器的后置方法(postHandle方法)，然后对返回的结果进行处理，最后执行afterCompletion方法。</p>\n<blockquote>\n<p>参考：《Spring技术内幕》、《精通Spring 4.x 企业应用开发实战》</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h1><p>DispatcherServlet是SpringMVC的核心分发器，它实现了请求分发，是处理请求的入口，本篇将深入源码分析它的初始化阶段。</p>\n<p> 下图为DispatcherServlet 继承关系图：</p>\n<p><img style=\"width:90%;\" src=\"http://epoch-night.oss-cn-hangzhou.aliyuncs.com/PostImg/servlet.png\"></p>\n<p>既然DispatcherServlet是一个Servlet，那么初始化的时候一定会执行init方法，查看源码发现DispatcherServlet的init方法继承自HttpServletBean，具体代码如下所示。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 方法位置：HttpServletBean#init() </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> ServletException </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">\t\tlogger.debug(<span class=\"string\">\"Initializing servlet '\"</span> + getServletName() + <span class=\"string\">\"'\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Set bean properties from init parameters.</span></span><br><span class=\"line\">\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//从web.xml中获取初始化参数并生成一个ServletConfigPropertyValues对象</span></span><br><span class=\"line\">\t\tPropertyValues pvs = <span class=\"keyword\">new</span> ServletConfigPropertyValues(getServletConfig(), <span class=\"keyword\">this</span>.requiredProperties);</span><br><span class=\"line\">\t\t<span class=\"comment\">//将当前对象封装为一个BeanWrapper，此时bena属性还未设置</span></span><br><span class=\"line\">\t\tBeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">\t\tResourceLoader resourceLoader = <span class=\"keyword\">new</span> ServletContextResourceLoader(getServletContext());</span><br><span class=\"line\">\t\tbw.registerCustomEditor(Resource.class, <span class=\"keyword\">new</span> ResourceEditor(resourceLoader, getEnvironment()));</span><br><span class=\"line\">\t\t<span class=\"comment\">//初始化BeanWrapper</span></span><br><span class=\"line\">\t\tinitBeanWrapper(bw);</span><br><span class=\"line\">\t\t<span class=\"comment\">//将构造器的属性实例设置到BeanWrapper准备下一步包装</span></span><br><span class=\"line\">\t\tbw.setPropertyValues(pvs, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">catch</span> (BeansException ex) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (logger.isErrorEnabled()) &#123;</span><br><span class=\"line\">\t\t\tlogger.error(<span class=\"string\">\"Failed to set bean properties on servlet '\"</span> + getServletName() + <span class=\"string\">\"'\"</span>, ex);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> ex;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//空实现，可由子类实现</span></span><br><span class=\"line\">\tinitServletBean();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">\t\tlogger.debug(<span class=\"string\">\"Servlet '\"</span> + getServletName() + <span class=\"string\">\"' configured successfully\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码具体加载的web.xml初始化参数如下。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- springmvc前端控制器 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>springmvc<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- contextConfigLocation配置springmvc加载的配置文件（配置处理器映射器、适配器等等） 如果不配置contextConfigLocation，默认加载的是/WEB-INF/servlet名称-serlvet.xml（springmvc-servlet.xml） --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>contextConfigLocation<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>classpath*:spring/springmvc.xml<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>springmvc<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>上面示例配置中，配置了一个 contextConfigLocation参数，该参数用于构造SpringMVC上下文。</p>\n<p>对于initServletBean方法，FrameworkServlet中进行了重写，具体代码如下图所示（就是init()方法中空实现的那个）。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 方法位置：FrameworkServlet#initServletBean() </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">initServletBean</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> ServletException </span>&#123;</span><br><span class=\"line\">\tgetServletContext().log(<span class=\"string\">\"Initializing Spring FrameworkServlet '\"</span> + getServletName() + <span class=\"string\">\"'\"</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.logger.isInfoEnabled()) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.logger.info(<span class=\"string\">\"FrameworkServlet '\"</span> + getServletName() + <span class=\"string\">\"': initialization started\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">long</span> startTime = System.currentTimeMillis();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//初始化WebApplicationContext，此处的WebApplicationContext最终会放入一个servletcontext</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.webApplicationContext = initWebApplicationContext();</span><br><span class=\"line\">            <span class=\"comment\">//空实现，子类可重写</span></span><br><span class=\"line\">\t\t\tinitFrameworkServlet();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">catch</span> (ServletException ex) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>.logger.error(<span class=\"string\">\"Context initialization failed\"</span>, ex);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">throw</span> ex;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">catch</span> (RuntimeException ex) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>.logger.error(<span class=\"string\">\"Context initialization failed\"</span>, ex);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">throw</span> ex;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.logger.isInfoEnabled()) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">long</span> elapsedTime = System.currentTimeMillis() - startTime;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.logger.info(<span class=\"string\">\"FrameworkServlet '\"</span> + getServletName() + <span class=\"string\">\"': initialization completed in \"</span> +</span><br><span class=\"line\">\t\t\t\t\telapsedTime + <span class=\"string\">\" ms\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>initWebApplicationContext方法主要代码如下图所示。 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 方法位置：FrameworkServlet#initServletBean() </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> WebApplicationContext <span class=\"title\">initWebApplicationContext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//在getServletContext 中查找WebApplicationContext，如果web.xml配置了contextLoaderListener</span></span><br><span class=\"line\">    <span class=\"comment\">//和contetConfigLocation则rootContext 是由xml配置了contextLoaderListener 监听的上下文</span></span><br><span class=\"line\">\tWebApplicationContext rootContext =</span><br><span class=\"line\">\t\t\t\tWebApplicationContextUtils.getWebApplicationContext(getServletContext());</span><br><span class=\"line\">\tWebApplicationContext wac = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t<span class=\"comment\">//DispatcherServlet的构造方法有一个是由WebApplicationContext进行创建的构造方法，如果使用这种</span></span><br><span class=\"line\">    <span class=\"comment\">//方式，则由下面的代码生成实例</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.webApplicationContext != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// A context instance was injected at construction time -&gt; use it</span></span><br><span class=\"line\">\t\twac = <span class=\"keyword\">this</span>.webApplicationContext;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (wac <span class=\"keyword\">instanceof</span> ConfigurableWebApplicationContext) &#123;</span><br><span class=\"line\">\t\t\tConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!cwac.isActive()) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// The context has not yet been refreshed -&gt; provide services such as</span></span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// setting the parent context, setting the application context id, etc</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (cwac.getParent() == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// The context instance was injected without an explicit parent -&gt; set</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// the root application context (if any; may be null) as the parent</span></span><br><span class=\"line\">\t\t\t\t\tcwac.setParent(rootContext);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tconfigureAndRefreshWebApplicationContext(cwac);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (wac == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 如果执行到这里wac还是为空，再次到ServletContext中查找，没有报错</span></span><br><span class=\"line\">\t\twac = findWebApplicationContext();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (wac == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 如果还是为空，就创建一个局部变量</span></span><br><span class=\"line\">\t\twac = createWebApplicationContext(rootContext);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.refreshEventReceived) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//这里手动刷新，交给子类实现</span></span><br><span class=\"line\">\t\tonRefresh(wac);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.publishContext) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 将这里的WebApplicationContext 放入 servletContext</span></span><br><span class=\"line\">\t\tString attrName = getServletContextAttributeName();</span><br><span class=\"line\">\t\tgetServletContext().setAttribute(attrName, wac);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>.logger.debug(<span class=\"string\">\"Published WebApplicationContext of servlet '\"</span> + getServletName() +</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"string\">\"' as ServletContext attribute with name [\"</span> + attrName + <span class=\"string\">\"]\"</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> wac;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果web.xml中配置了如下参数，将会在应用启动的时候初始化一个WebApplicationContext实例，并将其保存在ServletContext中。 </p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">listener</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class=\"tag\">&lt;/<span class=\"name\">listener-class</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">listener</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>上图中的代码很容易理解，接下来进入DispatcherServlet的onRefresh方法，具体代码如下图所示。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 方法位置：DispatcherServlet#onRefresh() </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">onRefresh</span><span class=\"params\">(ApplicationContext context)</span> </span>&#123;</span><br><span class=\"line\">\tinitStrategies(context);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Initialize the strategy objects that this servlet uses.</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;p&gt;May be overridden in subclasses in order to initialize further strategy objects.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">initStrategies</span><span class=\"params\">(ApplicationContext context)</span> </span>&#123;</span><br><span class=\"line\">\tinitMultipartResolver(context);</span><br><span class=\"line\">\tinitLocaleResolver(context);</span><br><span class=\"line\">\tinitThemeResolver(context);</span><br><span class=\"line\">\tinitHandlerMappings(context);</span><br><span class=\"line\">\tinitHandlerAdapters(context);</span><br><span class=\"line\">\tinitHandlerExceptionResolvers(context);</span><br><span class=\"line\">\tinitRequestToViewNameTranslator(context);</span><br><span class=\"line\">\tinitViewResolvers(context);</span><br><span class=\"line\">\tinitFlashMapManager(context);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>initStrategies方法中的各个方法，从方法名上可以很容易理解其作用，大部分的执行逻辑都是先从WebApplicationContext中查找，找不到的情况下再加载和DispatcherServlet同目录下的DispatcherServlet.properties中的各个策略，如初始化HandlerMapping，具体如下图所示。 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">initHandlerMappings</span><span class=\"params\">(ApplicationContext context)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.handlerMappings = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.detectAllHandlerMappings) &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// Find all HandlerMappings in the ApplicationContext, including ancestor contexts.</span></span><br><span class=\"line\">\t\tMap&lt;String, HandlerMapping&gt; matchingBeans =</span><br><span class=\"line\">\t\t\t\tBeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerMapping.class, <span class=\"keyword\">true</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!matchingBeans.isEmpty()) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>.handlerMappings = <span class=\"keyword\">new</span> ArrayList&lt;HandlerMapping&gt;(matchingBeans.values());</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// We keep HandlerMappings in sorted order.</span></span><br><span class=\"line\">\t\t\tAnnotationAwareOrderComparator.sort(<span class=\"keyword\">this</span>.handlerMappings);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\tHandlerMapping hm = context.getBean(HANDLER_MAPPING_BEAN_NAME, HandlerMapping.class);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>.handlerMappings = Collections.singletonList(hm);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// Ignore, we'll add a default HandlerMapping later.</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 加载和DispatcherServlet同目录下的DispatcherServlet.properties中的各个策略</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.handlerMappings == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.handlerMappings = getDefaultStrategies(context, HandlerMapping.class);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">\t\t\tlogger.debug(<span class=\"string\">\"No HandlerMappings found in servlet '\"</span> + getServletName() + <span class=\"string\">\"': using default\"</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>首先，Spring框架在启动的时候IOC容器会遍历IOC容器中的所有bean，对标注了@Controller或@RequestMapping注解的类中方法进行遍历，将类和方法上的@RequestMapping注解中的value值进行合并，使用@RequestMapping注解的相关参数值(如value、method等)封装一个RequestMappingInfo，将这个Controller实例、方法及方法参数信息(类型、注解等)封装到HandlerMethod中，然后以RequestMappingInfo为key，HandlerMethod为value存到一个以Map为结构的handlerMethods中。</p>\n<p>接着，将@RequestMapping注解中的value(即请求路径)值取出，即url，然后以url为key，以RequestMappingInfo为value，存到一个以Map为结构的urlMap属性中。</p>\n<p>客户端发起请求的时候，根据请求的URL到urlMap中查找，找到RequestMappingInfo，然后根据RequestMappingInfo到handlerMethods中查找，找到对应的HandlerMethod，接着将HandlerMethod封装到HandlerExecutionChain；接着遍历容器中所有HandlerAdapter实现类，找到支持这次请求的HandlerAdapter，如RequestMappingHandlerAdapter，然后执行SpringMVC拦截器的前置方法(preHandle方法)，然后对请求参数解析及转换，然后(使用反射)调用具体Controller的对应方法返回一个ModelAndView对象，执行拦截器的后置方法(postHandle方法)，然后对返回的结果进行处理，最后执行afterCompletion方法。</p>\n<blockquote>\n<p>参考：《Spring技术内幕》、《精通Spring 4.x 企业应用开发实战》</p>\n</blockquote>\n"},{"layout":"post","title":"Spring | BeanFactory与ApplicationContext基础","date":"2017-11-03T08:43:00.000Z","author":"Gubaidan","header-img":"/Header/hero@2x.jpg","cdn":"header-on","_content":"\n# BeanFactory介绍\n\nBeanFactory 是Spring中两大核心模块（AOP、IOC）之一IOC的基础，与传统的BeanFactory 不同，BeanFactory时一个通用型的Bean工厂，它可以创建和管理这些Bean，所有可以被Spring 容器实例化并管理的Java类都可以称作Bean。\n\nSpring在BeanFactory这个接口的基础上实现了很多类，最常用的是XmlBeanFactory，但在Spring3.2\t之后已经被弃用，建议使用XmlBeanDefinitionReader和，DefaultListableBeanFactory代替，Spring对这一继承机构设计的相当精巧。\n\n![BeanFactory](http://epoch-night.oss-cn-hangzhou.aliyuncs.com/PostImg/BeanFactoryDependence.png)\n\nBeanFactory 接口位于类结构树的顶端，通过其他类和接口的装饰，最后的DefaultBeanFactory就是由其他类和接口不断扩充。\n\n- ListableBeanFactory：该接口定义了访问容器中Bean基本信息的若干方法，如查看Bean的个数、获取某一类型Bean的配置名、查看容器中是否包含某一Bean等。\n\n- HierarchicalBeanFactory：父子及联IOC容器的接口、子接口可以根据接口方法访问父容器。\n\n- ConfiguratableBeanFactory：这是一个重要的接口，增强了IOC容器的可制定性。它定义了设置类装载器、属性编辑器、容器初始化后置处理器等方法。\n\n- AutowireCapableBeanFactory：定义了将容器中的Bean按照某种规则（如名字匹配、类型匹配）进行自动装配的方法。\n\n- SingletonBeanRegister：允许在运行期向容器注册单实例Bean的方法。\n\n- BeanDefinitionRegister：接口提供了向容器注册BeanDefinition的方法。\n\n  \n\n### BeanFactory使用示例\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">\n    <beans id = \"pension\" class = \"com.smart.pension\">\n        p:name = \"zhang\"\n        p:sex = \"nan\"\n        p:location = \"fujian\"\n    </beans>\n</beans\n```\n\n```java\npublic class BeanFactoryT {\n    @Test\n    public void getBean() throws IOException {\n        ResourcePatternResolver resourcePatternResolver = new PathMatchingResourcePatternResolver();\n        Resource[] resource = resourcePatternResolver.getResources(\"com.smart.pension\");\n        System.out.println(Arrays.toString(resource));\n\n        /**\n         * 废弃、不建议使用\n         */\n//        BeanFactory beanFactory = new XmlBeanFactory(res);\n        DefaultListableBeanFactory defaultListableBeanFactory = new DefaultListableBeanFactory();\n        XmlBeanDefinitionReader xmlBeanDefinitionReader = new XmlBeanDefinitionReader(defaultListableBeanFactory);\n        xmlBeanDefinitionReader.loadBeanDefinitions(resource);\n        \n        Pension zhang = defaultListableBeanFactory.getBean(Pension.class);\n        car.move();\n    }\n}\n```\n\nXmlBeanDefinitionReader 通过Resource装载配置信息并启动IOC容器，这样就可以从beanFactory中的getBean（）方法通过全限定名或者“类名.class” 为参数获取Bean。对于单例的Bean，在第二次getBean时会直接从缓存中读取Bean然后返回。\n\n在Spring容器启动的时候必须为其设置一个日志框架，用来记录启动信息，不然会启动报错。\n\n# ApplicationContext\n\n如果说beanFactory是“心脏”的话，那么ApplicationbContext就是一个完整的“躯体”了，Application由BeanFactory一步步扩充而来，提供了很多实用功能，很多在BeanFactory需要配置实现的功能在ApplicationContext中只需要简单的配置即可以实现。\n\n### ApplicationbContext类结构体系\n\n![application](http://epoch-night.oss-cn-hangzhou.aliyuncs.com/PostImg/applicationContext.png)\n\n\n\nApplicationContext的主要实现类是FileSystemxmlApplicationContext和ClassPathXmlApplicationContext，前者主要加载存储在文件系统上的配置文件，后者主要加载类结构下的Xml文件。ApplicationContext继承了HierarchicalBeanFactory、即永远父子及联、通过接口让子容器访问父容器的方法。而且通过其他接口扩充了BeanFactory的功能。\n\n- ApplicationEventPublisher：让容器拥有发布上下文事件的功能，包括启动关闭等事件。实现了ApplicationListener事件监听端口的Bean可以接收到容器事件，并进行事件响应。在ApplicationContext的抽象实现类AbstractApplicationContext中存在一个ApplicationEventMulticaster，它负责所有的监听器、以便在容器产生上下文事件时通知事件监听者。\n- MessageResource：为应用提i18n国际化消息访问的功能。\n- ResourcePatternResolver：所有ApplicationContext实现类都实现了类似于PathMatchingResourcePatternResolver的功能，可以通过带前缀的Ant风格的资源文件装载Spring配置文件。\n- Lifecycle：该接口提供了start（）和stop（）两个方法，主要用于异步处理过程。在具体实用时，该接口同时被ApplicationContext实现及具体Bean的实现，ApplicationContext会将start/stop的信息传递给容器中所有实现了该接口的Bean，以达到管理和控制JMX、任务调度的目的。\n\nConfigurableApplicationContext扩展于ApplicationContext，它新增了两个方法：\n\n```java\npublic interface ConfigurableApplicationContext extends ApplicationContext, Lifecycle, Closeable {\n    String CONFIG_LOCATION_DELIMITERS = \",; \\t\\n\";\n    String CONVERSION_SERVICE_BEAN_NAME = \"conversionService\";\n    String LOAD_TIME_WEAVER_BEAN_NAME = \"loadTimeWeaver\";\n    String ENVIRONMENT_BEAN_NAME = \"environment\";\n    String SYSTEM_PROPERTIES_BEAN_NAME = \"systemProperties\";\n    String SYSTEM_ENVIRONMENT_BEAN_NAME = \"systemEnvironment\";\n\n    void setId(String var1);\n\n    void setParent(ApplicationContext var1);\n\n    ConfigurableEnvironment getEnvironment();\n\n    void setEnvironment(ConfigurableEnvironment var1);\n\n    void addBeanFactoryPostProcessor(BeanFactoryPostProcessor var1);\n\n    void addApplicationListener(ApplicationListener<?> var1);\n\n    //整个spring启动的核心方法\n    void refresh() throws BeansException, IllegalStateException;\n\n    void registerShutdownHook();\n\t//关闭\n    void close();\n\n    boolean isActive();\n\n    ConfigurableListableBeanFactory getBeanFactory() throws IllegalStateException;\n}\n```\n\n\n\n和BeanFactory初始化相似（本质上也是因为继承并且扩展了不同类型的BeanFactory接口），如果配置文件在类路径下，则可以优先考虑使用ClassPathXmlApplicationContext\n\n```java\nApplicationContext act = new ClassPathXmlApplicationContext(\"com.xxxx.config.xml\"）;\n```\n\n如果配置文件放在文件系统中，则使用如下：\n\n```java\nApplicationContext act = new FileSystemXmlApplication(\"/Users/xxx/config.xml\");\n```\n\n在获取到ApplicationContext实例后，同样可以通过getBean（）获取bean。ApplicationContext和BeanFactory初始化时有一个重大的不同是BeanFactory并未初始化Bean，而ApplicationContext在应用初始化阶段就会实例化所有**单实例**的Bean。\n\n### 注解式配置方式\n\nSpring支持注解式的配置方式，主要功能来自JavaConfig子项目，现已升级为Spring核心项目。当一个pojo类标注了@Configuration注解，既可以提供Spring所需的Bean信息：\n\n```java\n//表示这是一个配置类\n@Configuration\npublic class Person {\n\n    //定义一个bean\n    @Bean(name = \"Female\")\n    public Female born(){\n        Female Jerry = new Female();\n        Jerry.setSkin(\"Blue\");\n        Jerry.setAge(22);\n        return Jerry;\n    }\n}\n```\n\nSpring为注解实现了专门的ApplicationContext实现类：ApplicationConfigApplicationContext。加载上述配置示例如下：\n\n```java\npublic class AnnotationConfig {\n    \n    @Test\n    public void getBean(){\n        //通过一个带有Configuration注解的POJO获得Bean\n        ApplicationContext act = new AnnotationConfigApplicationContext(Person.class);\n        Femail Jerry = act.getBean(\"Female\");\n        assertNotNull(Jerry);\n    }\n}\n```\n\n### Groovy DSL配置Bean\n\nSpring 4.x支持使用Groovy DSL来进行Bean定义配置。其与基于XML文件的配置类似，只不过基于Groovy脚本语言可以实现更复杂的Bean配置逻辑：\n\n```groovy\nbeans{\n    Jerry(Person){//名字（类型）\n        name = \"jerry\"\n        sex = \"female\"\n        age = 22\n    }\n}\n```\n\n基于Groovy的配置方式很容易让开发者配置复杂的Bean初始化过程，比@Configuration和XML更加灵活，读取Groovy也有专门的ApplicationContext - > GenericGorrvyApplicationContet:\n\n```java\npublic class GroovyConfig {\n    \n    @Test\n    public void getBean(){\n        ApplicationContext act = \n        new GenericGorrvyApplicationContet(\"com.xxx.beans.groovy\");\n        Femail Jerry = act.getBean(\"Female\");\n        assertNotNull(Jerry);\n    }\n}\n```\n\n# 总结\n\n\n\n对于BeanFactory和ApplicationContext，ApplicationContext面向的是代码开发人员，而BeanFactory则是底层支持，由ApplicationContext实现和扩展，几乎所有的场景都可以使用ApplicationContext。\n\n\n\n> 参考：《Spring技术内幕》、《精通Spring 4.x 企业应用开发实战》","source":"_posts/2017-11-3-applicationContext（上）.markdown","raw":"---\nlayout: post\ntitle: \"Spring | BeanFactory与ApplicationContext基础\"\ndate: 2017-11-03 16:43\nauthor: \"Gubaidan\"\nheader-img: \"/Header/hero@2x.jpg\"\ncdn: 'header-on'\ntags:\n\t- Spring\n---\n\n# BeanFactory介绍\n\nBeanFactory 是Spring中两大核心模块（AOP、IOC）之一IOC的基础，与传统的BeanFactory 不同，BeanFactory时一个通用型的Bean工厂，它可以创建和管理这些Bean，所有可以被Spring 容器实例化并管理的Java类都可以称作Bean。\n\nSpring在BeanFactory这个接口的基础上实现了很多类，最常用的是XmlBeanFactory，但在Spring3.2\t之后已经被弃用，建议使用XmlBeanDefinitionReader和，DefaultListableBeanFactory代替，Spring对这一继承机构设计的相当精巧。\n\n![BeanFactory](http://epoch-night.oss-cn-hangzhou.aliyuncs.com/PostImg/BeanFactoryDependence.png)\n\nBeanFactory 接口位于类结构树的顶端，通过其他类和接口的装饰，最后的DefaultBeanFactory就是由其他类和接口不断扩充。\n\n- ListableBeanFactory：该接口定义了访问容器中Bean基本信息的若干方法，如查看Bean的个数、获取某一类型Bean的配置名、查看容器中是否包含某一Bean等。\n\n- HierarchicalBeanFactory：父子及联IOC容器的接口、子接口可以根据接口方法访问父容器。\n\n- ConfiguratableBeanFactory：这是一个重要的接口，增强了IOC容器的可制定性。它定义了设置类装载器、属性编辑器、容器初始化后置处理器等方法。\n\n- AutowireCapableBeanFactory：定义了将容器中的Bean按照某种规则（如名字匹配、类型匹配）进行自动装配的方法。\n\n- SingletonBeanRegister：允许在运行期向容器注册单实例Bean的方法。\n\n- BeanDefinitionRegister：接口提供了向容器注册BeanDefinition的方法。\n\n  \n\n### BeanFactory使用示例\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">\n    <beans id = \"pension\" class = \"com.smart.pension\">\n        p:name = \"zhang\"\n        p:sex = \"nan\"\n        p:location = \"fujian\"\n    </beans>\n</beans\n```\n\n```java\npublic class BeanFactoryT {\n    @Test\n    public void getBean() throws IOException {\n        ResourcePatternResolver resourcePatternResolver = new PathMatchingResourcePatternResolver();\n        Resource[] resource = resourcePatternResolver.getResources(\"com.smart.pension\");\n        System.out.println(Arrays.toString(resource));\n\n        /**\n         * 废弃、不建议使用\n         */\n//        BeanFactory beanFactory = new XmlBeanFactory(res);\n        DefaultListableBeanFactory defaultListableBeanFactory = new DefaultListableBeanFactory();\n        XmlBeanDefinitionReader xmlBeanDefinitionReader = new XmlBeanDefinitionReader(defaultListableBeanFactory);\n        xmlBeanDefinitionReader.loadBeanDefinitions(resource);\n        \n        Pension zhang = defaultListableBeanFactory.getBean(Pension.class);\n        car.move();\n    }\n}\n```\n\nXmlBeanDefinitionReader 通过Resource装载配置信息并启动IOC容器，这样就可以从beanFactory中的getBean（）方法通过全限定名或者“类名.class” 为参数获取Bean。对于单例的Bean，在第二次getBean时会直接从缓存中读取Bean然后返回。\n\n在Spring容器启动的时候必须为其设置一个日志框架，用来记录启动信息，不然会启动报错。\n\n# ApplicationContext\n\n如果说beanFactory是“心脏”的话，那么ApplicationbContext就是一个完整的“躯体”了，Application由BeanFactory一步步扩充而来，提供了很多实用功能，很多在BeanFactory需要配置实现的功能在ApplicationContext中只需要简单的配置即可以实现。\n\n### ApplicationbContext类结构体系\n\n![application](http://epoch-night.oss-cn-hangzhou.aliyuncs.com/PostImg/applicationContext.png)\n\n\n\nApplicationContext的主要实现类是FileSystemxmlApplicationContext和ClassPathXmlApplicationContext，前者主要加载存储在文件系统上的配置文件，后者主要加载类结构下的Xml文件。ApplicationContext继承了HierarchicalBeanFactory、即永远父子及联、通过接口让子容器访问父容器的方法。而且通过其他接口扩充了BeanFactory的功能。\n\n- ApplicationEventPublisher：让容器拥有发布上下文事件的功能，包括启动关闭等事件。实现了ApplicationListener事件监听端口的Bean可以接收到容器事件，并进行事件响应。在ApplicationContext的抽象实现类AbstractApplicationContext中存在一个ApplicationEventMulticaster，它负责所有的监听器、以便在容器产生上下文事件时通知事件监听者。\n- MessageResource：为应用提i18n国际化消息访问的功能。\n- ResourcePatternResolver：所有ApplicationContext实现类都实现了类似于PathMatchingResourcePatternResolver的功能，可以通过带前缀的Ant风格的资源文件装载Spring配置文件。\n- Lifecycle：该接口提供了start（）和stop（）两个方法，主要用于异步处理过程。在具体实用时，该接口同时被ApplicationContext实现及具体Bean的实现，ApplicationContext会将start/stop的信息传递给容器中所有实现了该接口的Bean，以达到管理和控制JMX、任务调度的目的。\n\nConfigurableApplicationContext扩展于ApplicationContext，它新增了两个方法：\n\n```java\npublic interface ConfigurableApplicationContext extends ApplicationContext, Lifecycle, Closeable {\n    String CONFIG_LOCATION_DELIMITERS = \",; \\t\\n\";\n    String CONVERSION_SERVICE_BEAN_NAME = \"conversionService\";\n    String LOAD_TIME_WEAVER_BEAN_NAME = \"loadTimeWeaver\";\n    String ENVIRONMENT_BEAN_NAME = \"environment\";\n    String SYSTEM_PROPERTIES_BEAN_NAME = \"systemProperties\";\n    String SYSTEM_ENVIRONMENT_BEAN_NAME = \"systemEnvironment\";\n\n    void setId(String var1);\n\n    void setParent(ApplicationContext var1);\n\n    ConfigurableEnvironment getEnvironment();\n\n    void setEnvironment(ConfigurableEnvironment var1);\n\n    void addBeanFactoryPostProcessor(BeanFactoryPostProcessor var1);\n\n    void addApplicationListener(ApplicationListener<?> var1);\n\n    //整个spring启动的核心方法\n    void refresh() throws BeansException, IllegalStateException;\n\n    void registerShutdownHook();\n\t//关闭\n    void close();\n\n    boolean isActive();\n\n    ConfigurableListableBeanFactory getBeanFactory() throws IllegalStateException;\n}\n```\n\n\n\n和BeanFactory初始化相似（本质上也是因为继承并且扩展了不同类型的BeanFactory接口），如果配置文件在类路径下，则可以优先考虑使用ClassPathXmlApplicationContext\n\n```java\nApplicationContext act = new ClassPathXmlApplicationContext(\"com.xxxx.config.xml\"）;\n```\n\n如果配置文件放在文件系统中，则使用如下：\n\n```java\nApplicationContext act = new FileSystemXmlApplication(\"/Users/xxx/config.xml\");\n```\n\n在获取到ApplicationContext实例后，同样可以通过getBean（）获取bean。ApplicationContext和BeanFactory初始化时有一个重大的不同是BeanFactory并未初始化Bean，而ApplicationContext在应用初始化阶段就会实例化所有**单实例**的Bean。\n\n### 注解式配置方式\n\nSpring支持注解式的配置方式，主要功能来自JavaConfig子项目，现已升级为Spring核心项目。当一个pojo类标注了@Configuration注解，既可以提供Spring所需的Bean信息：\n\n```java\n//表示这是一个配置类\n@Configuration\npublic class Person {\n\n    //定义一个bean\n    @Bean(name = \"Female\")\n    public Female born(){\n        Female Jerry = new Female();\n        Jerry.setSkin(\"Blue\");\n        Jerry.setAge(22);\n        return Jerry;\n    }\n}\n```\n\nSpring为注解实现了专门的ApplicationContext实现类：ApplicationConfigApplicationContext。加载上述配置示例如下：\n\n```java\npublic class AnnotationConfig {\n    \n    @Test\n    public void getBean(){\n        //通过一个带有Configuration注解的POJO获得Bean\n        ApplicationContext act = new AnnotationConfigApplicationContext(Person.class);\n        Femail Jerry = act.getBean(\"Female\");\n        assertNotNull(Jerry);\n    }\n}\n```\n\n### Groovy DSL配置Bean\n\nSpring 4.x支持使用Groovy DSL来进行Bean定义配置。其与基于XML文件的配置类似，只不过基于Groovy脚本语言可以实现更复杂的Bean配置逻辑：\n\n```groovy\nbeans{\n    Jerry(Person){//名字（类型）\n        name = \"jerry\"\n        sex = \"female\"\n        age = 22\n    }\n}\n```\n\n基于Groovy的配置方式很容易让开发者配置复杂的Bean初始化过程，比@Configuration和XML更加灵活，读取Groovy也有专门的ApplicationContext - > GenericGorrvyApplicationContet:\n\n```java\npublic class GroovyConfig {\n    \n    @Test\n    public void getBean(){\n        ApplicationContext act = \n        new GenericGorrvyApplicationContet(\"com.xxx.beans.groovy\");\n        Femail Jerry = act.getBean(\"Female\");\n        assertNotNull(Jerry);\n    }\n}\n```\n\n# 总结\n\n\n\n对于BeanFactory和ApplicationContext，ApplicationContext面向的是代码开发人员，而BeanFactory则是底层支持，由ApplicationContext实现和扩展，几乎所有的场景都可以使用ApplicationContext。\n\n\n\n> 参考：《Spring技术内幕》、《精通Spring 4.x 企业应用开发实战》","slug":"2017-11-3-applicationContext（上）","published":1,"updated":"2019-05-05T12:32:56.551Z","comments":1,"photos":[],"link":"","_id":"cjvayvwga001ym46a0euzvfqo","content":"<h1 id=\"BeanFactory介绍\"><a href=\"#BeanFactory介绍\" class=\"headerlink\" title=\"BeanFactory介绍\"></a>BeanFactory介绍</h1><p>BeanFactory 是Spring中两大核心模块（AOP、IOC）之一IOC的基础，与传统的BeanFactory 不同，BeanFactory时一个通用型的Bean工厂，它可以创建和管理这些Bean，所有可以被Spring 容器实例化并管理的Java类都可以称作Bean。</p>\n<p>Spring在BeanFactory这个接口的基础上实现了很多类，最常用的是XmlBeanFactory，但在Spring3.2    之后已经被弃用，建议使用XmlBeanDefinitionReader和，DefaultListableBeanFactory代替，Spring对这一继承机构设计的相当精巧。</p>\n<p><img src=\"http://epoch-night.oss-cn-hangzhou.aliyuncs.com/PostImg/BeanFactoryDependence.png\" alt=\"BeanFactory\"></p>\n<p>BeanFactory 接口位于类结构树的顶端，通过其他类和接口的装饰，最后的DefaultBeanFactory就是由其他类和接口不断扩充。</p>\n<ul>\n<li><p>ListableBeanFactory：该接口定义了访问容器中Bean基本信息的若干方法，如查看Bean的个数、获取某一类型Bean的配置名、查看容器中是否包含某一Bean等。</p>\n</li>\n<li><p>HierarchicalBeanFactory：父子及联IOC容器的接口、子接口可以根据接口方法访问父容器。</p>\n</li>\n<li><p>ConfiguratableBeanFactory：这是一个重要的接口，增强了IOC容器的可制定性。它定义了设置类装载器、属性编辑器、容器初始化后置处理器等方法。</p>\n</li>\n<li><p>AutowireCapableBeanFactory：定义了将容器中的Bean按照某种规则（如名字匹配、类型匹配）进行自动装配的方法。</p>\n</li>\n<li><p>SingletonBeanRegister：允许在运行期向容器注册单实例Bean的方法。</p>\n</li>\n<li><p>BeanDefinitionRegister：接口提供了向容器注册BeanDefinition的方法。</p>\n</li>\n</ul>\n<h3 id=\"BeanFactory使用示例\"><a href=\"#BeanFactory使用示例\" class=\"headerlink\" title=\"BeanFactory使用示例\"></a>BeanFactory使用示例</h3><figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans\"</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">id</span> = <span class=\"string\">\"pension\"</span> <span class=\"attr\">class</span> = <span class=\"string\">\"com.smart.pension\"</span>&gt;</span></span><br><span class=\"line\">        p:name = \"zhang\"</span><br><span class=\"line\">        p:sex = \"nan\"</span><br><span class=\"line\">        p:location = \"fujian\"</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span></span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BeanFactoryT</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">getBean</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        ResourcePatternResolver resourcePatternResolver = <span class=\"keyword\">new</span> PathMatchingResourcePatternResolver();</span><br><span class=\"line\">        Resource[] resource = resourcePatternResolver.getResources(<span class=\"string\">\"com.smart.pension\"</span>);</span><br><span class=\"line\">        System.out.println(Arrays.toString(resource));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 废弃、不建议使用</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\"><span class=\"comment\">//        BeanFactory beanFactory = new XmlBeanFactory(res);</span></span><br><span class=\"line\">        DefaultListableBeanFactory defaultListableBeanFactory = <span class=\"keyword\">new</span> DefaultListableBeanFactory();</span><br><span class=\"line\">        XmlBeanDefinitionReader xmlBeanDefinitionReader = <span class=\"keyword\">new</span> XmlBeanDefinitionReader(defaultListableBeanFactory);</span><br><span class=\"line\">        xmlBeanDefinitionReader.loadBeanDefinitions(resource);</span><br><span class=\"line\">        </span><br><span class=\"line\">        Pension zhang = defaultListableBeanFactory.getBean(Pension.class);</span><br><span class=\"line\">        car.move();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>XmlBeanDefinitionReader 通过Resource装载配置信息并启动IOC容器，这样就可以从beanFactory中的getBean（）方法通过全限定名或者“类名.class” 为参数获取Bean。对于单例的Bean，在第二次getBean时会直接从缓存中读取Bean然后返回。</p>\n<p>在Spring容器启动的时候必须为其设置一个日志框架，用来记录启动信息，不然会启动报错。</p>\n<h1 id=\"ApplicationContext\"><a href=\"#ApplicationContext\" class=\"headerlink\" title=\"ApplicationContext\"></a>ApplicationContext</h1><p>如果说beanFactory是“心脏”的话，那么ApplicationbContext就是一个完整的“躯体”了，Application由BeanFactory一步步扩充而来，提供了很多实用功能，很多在BeanFactory需要配置实现的功能在ApplicationContext中只需要简单的配置即可以实现。</p>\n<h3 id=\"ApplicationbContext类结构体系\"><a href=\"#ApplicationbContext类结构体系\" class=\"headerlink\" title=\"ApplicationbContext类结构体系\"></a>ApplicationbContext类结构体系</h3><p><img src=\"http://epoch-night.oss-cn-hangzhou.aliyuncs.com/PostImg/applicationContext.png\" alt=\"application\"></p>\n<p>ApplicationContext的主要实现类是FileSystemxmlApplicationContext和ClassPathXmlApplicationContext，前者主要加载存储在文件系统上的配置文件，后者主要加载类结构下的Xml文件。ApplicationContext继承了HierarchicalBeanFactory、即永远父子及联、通过接口让子容器访问父容器的方法。而且通过其他接口扩充了BeanFactory的功能。</p>\n<ul>\n<li>ApplicationEventPublisher：让容器拥有发布上下文事件的功能，包括启动关闭等事件。实现了ApplicationListener事件监听端口的Bean可以接收到容器事件，并进行事件响应。在ApplicationContext的抽象实现类AbstractApplicationContext中存在一个ApplicationEventMulticaster，它负责所有的监听器、以便在容器产生上下文事件时通知事件监听者。</li>\n<li>MessageResource：为应用提i18n国际化消息访问的功能。</li>\n<li>ResourcePatternResolver：所有ApplicationContext实现类都实现了类似于PathMatchingResourcePatternResolver的功能，可以通过带前缀的Ant风格的资源文件装载Spring配置文件。</li>\n<li>Lifecycle：该接口提供了start（）和stop（）两个方法，主要用于异步处理过程。在具体实用时，该接口同时被ApplicationContext实现及具体Bean的实现，ApplicationContext会将start/stop的信息传递给容器中所有实现了该接口的Bean，以达到管理和控制JMX、任务调度的目的。</li>\n</ul>\n<p>ConfigurableApplicationContext扩展于ApplicationContext，它新增了两个方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ConfigurableApplicationContext</span> <span class=\"keyword\">extends</span> <span class=\"title\">ApplicationContext</span>, <span class=\"title\">Lifecycle</span>, <span class=\"title\">Closeable</span> </span>&#123;</span><br><span class=\"line\">    String CONFIG_LOCATION_DELIMITERS = <span class=\"string\">\",; \\t\\n\"</span>;</span><br><span class=\"line\">    String CONVERSION_SERVICE_BEAN_NAME = <span class=\"string\">\"conversionService\"</span>;</span><br><span class=\"line\">    String LOAD_TIME_WEAVER_BEAN_NAME = <span class=\"string\">\"loadTimeWeaver\"</span>;</span><br><span class=\"line\">    String ENVIRONMENT_BEAN_NAME = <span class=\"string\">\"environment\"</span>;</span><br><span class=\"line\">    String SYSTEM_PROPERTIES_BEAN_NAME = <span class=\"string\">\"systemProperties\"</span>;</span><br><span class=\"line\">    String SYSTEM_ENVIRONMENT_BEAN_NAME = <span class=\"string\">\"systemEnvironment\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setId</span><span class=\"params\">(String var1)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setParent</span><span class=\"params\">(ApplicationContext var1)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">ConfigurableEnvironment <span class=\"title\">getEnvironment</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setEnvironment</span><span class=\"params\">(ConfigurableEnvironment var1)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addBeanFactoryPostProcessor</span><span class=\"params\">(BeanFactoryPostProcessor var1)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addApplicationListener</span><span class=\"params\">(ApplicationListener&lt;?&gt; var1)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//整个spring启动的核心方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">refresh</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> BeansException, IllegalStateException</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">registerShutdownHook</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">\t<span class=\"comment\">//关闭</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isActive</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">ConfigurableListableBeanFactory <span class=\"title\">getBeanFactory</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IllegalStateException</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>和BeanFactory初始化相似（本质上也是因为继承并且扩展了不同类型的BeanFactory接口），如果配置文件在类路径下，则可以优先考虑使用ClassPathXmlApplicationContext</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">ApplicationContext act = <span class=\"keyword\">new</span> ClassPathXmlApplicationContext(<span class=\"string\">\"com.xxxx.config.xml\"</span>）;</span><br></pre></td></tr></table></figure>\n<p>如果配置文件放在文件系统中，则使用如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">ApplicationContext act = <span class=\"keyword\">new</span> FileSystemXmlApplication(<span class=\"string\">\"/Users/xxx/config.xml\"</span>);</span><br></pre></td></tr></table></figure>\n<p>在获取到ApplicationContext实例后，同样可以通过getBean（）获取bean。ApplicationContext和BeanFactory初始化时有一个重大的不同是BeanFactory并未初始化Bean，而ApplicationContext在应用初始化阶段就会实例化所有<strong>单实例</strong>的Bean。</p>\n<h3 id=\"注解式配置方式\"><a href=\"#注解式配置方式\" class=\"headerlink\" title=\"注解式配置方式\"></a>注解式配置方式</h3><p>Spring支持注解式的配置方式，主要功能来自JavaConfig子项目，现已升级为Spring核心项目。当一个pojo类标注了@Configuration注解，既可以提供Spring所需的Bean信息：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//表示这是一个配置类</span></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//定义一个bean</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span>(name = <span class=\"string\">\"Female\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Female <span class=\"title\">born</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        Female Jerry = <span class=\"keyword\">new</span> Female();</span><br><span class=\"line\">        Jerry.setSkin(<span class=\"string\">\"Blue\"</span>);</span><br><span class=\"line\">        Jerry.setAge(<span class=\"number\">22</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Jerry;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Spring为注解实现了专门的ApplicationContext实现类：ApplicationConfigApplicationContext。加载上述配置示例如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AnnotationConfig</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">getBean</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//通过一个带有Configuration注解的POJO获得Bean</span></span><br><span class=\"line\">        ApplicationContext act = <span class=\"keyword\">new</span> AnnotationConfigApplicationContext(Person.class);</span><br><span class=\"line\">        Femail Jerry = act.getBean(<span class=\"string\">\"Female\"</span>);</span><br><span class=\"line\">        assertNotNull(Jerry);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Groovy-DSL配置Bean\"><a href=\"#Groovy-DSL配置Bean\" class=\"headerlink\" title=\"Groovy DSL配置Bean\"></a>Groovy DSL配置Bean</h3><p>Spring 4.x支持使用Groovy DSL来进行Bean定义配置。其与基于XML文件的配置类似，只不过基于Groovy脚本语言可以实现更复杂的Bean配置逻辑：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"code\"><pre><span class=\"line\">beans&#123;</span><br><span class=\"line\">    Jerry(Person)&#123;<span class=\"comment\">//名字（类型）</span></span><br><span class=\"line\">        name = <span class=\"string\">\"jerry\"</span></span><br><span class=\"line\">        sex = <span class=\"string\">\"female\"</span></span><br><span class=\"line\">        age = <span class=\"number\">22</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>基于Groovy的配置方式很容易让开发者配置复杂的Bean初始化过程，比@Configuration和XML更加灵活，读取Groovy也有专门的ApplicationContext - &gt; GenericGorrvyApplicationContet:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GroovyConfig</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">getBean</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        ApplicationContext act = </span><br><span class=\"line\">        <span class=\"keyword\">new</span> GenericGorrvyApplicationContet(<span class=\"string\">\"com.xxx.beans.groovy\"</span>);</span><br><span class=\"line\">        Femail Jerry = act.getBean(<span class=\"string\">\"Female\"</span>);</span><br><span class=\"line\">        assertNotNull(Jerry);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>对于BeanFactory和ApplicationContext，ApplicationContext面向的是代码开发人员，而BeanFactory则是底层支持，由ApplicationContext实现和扩展，几乎所有的场景都可以使用ApplicationContext。</p>\n<blockquote>\n<p>参考：《Spring技术内幕》、《精通Spring 4.x 企业应用开发实战》</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"BeanFactory介绍\"><a href=\"#BeanFactory介绍\" class=\"headerlink\" title=\"BeanFactory介绍\"></a>BeanFactory介绍</h1><p>BeanFactory 是Spring中两大核心模块（AOP、IOC）之一IOC的基础，与传统的BeanFactory 不同，BeanFactory时一个通用型的Bean工厂，它可以创建和管理这些Bean，所有可以被Spring 容器实例化并管理的Java类都可以称作Bean。</p>\n<p>Spring在BeanFactory这个接口的基础上实现了很多类，最常用的是XmlBeanFactory，但在Spring3.2    之后已经被弃用，建议使用XmlBeanDefinitionReader和，DefaultListableBeanFactory代替，Spring对这一继承机构设计的相当精巧。</p>\n<p><img src=\"http://epoch-night.oss-cn-hangzhou.aliyuncs.com/PostImg/BeanFactoryDependence.png\" alt=\"BeanFactory\"></p>\n<p>BeanFactory 接口位于类结构树的顶端，通过其他类和接口的装饰，最后的DefaultBeanFactory就是由其他类和接口不断扩充。</p>\n<ul>\n<li><p>ListableBeanFactory：该接口定义了访问容器中Bean基本信息的若干方法，如查看Bean的个数、获取某一类型Bean的配置名、查看容器中是否包含某一Bean等。</p>\n</li>\n<li><p>HierarchicalBeanFactory：父子及联IOC容器的接口、子接口可以根据接口方法访问父容器。</p>\n</li>\n<li><p>ConfiguratableBeanFactory：这是一个重要的接口，增强了IOC容器的可制定性。它定义了设置类装载器、属性编辑器、容器初始化后置处理器等方法。</p>\n</li>\n<li><p>AutowireCapableBeanFactory：定义了将容器中的Bean按照某种规则（如名字匹配、类型匹配）进行自动装配的方法。</p>\n</li>\n<li><p>SingletonBeanRegister：允许在运行期向容器注册单实例Bean的方法。</p>\n</li>\n<li><p>BeanDefinitionRegister：接口提供了向容器注册BeanDefinition的方法。</p>\n</li>\n</ul>\n<h3 id=\"BeanFactory使用示例\"><a href=\"#BeanFactory使用示例\" class=\"headerlink\" title=\"BeanFactory使用示例\"></a>BeanFactory使用示例</h3><figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans\"</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">id</span> = <span class=\"string\">\"pension\"</span> <span class=\"attr\">class</span> = <span class=\"string\">\"com.smart.pension\"</span>&gt;</span></span><br><span class=\"line\">        p:name = \"zhang\"</span><br><span class=\"line\">        p:sex = \"nan\"</span><br><span class=\"line\">        p:location = \"fujian\"</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span></span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BeanFactoryT</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">getBean</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        ResourcePatternResolver resourcePatternResolver = <span class=\"keyword\">new</span> PathMatchingResourcePatternResolver();</span><br><span class=\"line\">        Resource[] resource = resourcePatternResolver.getResources(<span class=\"string\">\"com.smart.pension\"</span>);</span><br><span class=\"line\">        System.out.println(Arrays.toString(resource));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 废弃、不建议使用</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\"><span class=\"comment\">//        BeanFactory beanFactory = new XmlBeanFactory(res);</span></span><br><span class=\"line\">        DefaultListableBeanFactory defaultListableBeanFactory = <span class=\"keyword\">new</span> DefaultListableBeanFactory();</span><br><span class=\"line\">        XmlBeanDefinitionReader xmlBeanDefinitionReader = <span class=\"keyword\">new</span> XmlBeanDefinitionReader(defaultListableBeanFactory);</span><br><span class=\"line\">        xmlBeanDefinitionReader.loadBeanDefinitions(resource);</span><br><span class=\"line\">        </span><br><span class=\"line\">        Pension zhang = defaultListableBeanFactory.getBean(Pension.class);</span><br><span class=\"line\">        car.move();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>XmlBeanDefinitionReader 通过Resource装载配置信息并启动IOC容器，这样就可以从beanFactory中的getBean（）方法通过全限定名或者“类名.class” 为参数获取Bean。对于单例的Bean，在第二次getBean时会直接从缓存中读取Bean然后返回。</p>\n<p>在Spring容器启动的时候必须为其设置一个日志框架，用来记录启动信息，不然会启动报错。</p>\n<h1 id=\"ApplicationContext\"><a href=\"#ApplicationContext\" class=\"headerlink\" title=\"ApplicationContext\"></a>ApplicationContext</h1><p>如果说beanFactory是“心脏”的话，那么ApplicationbContext就是一个完整的“躯体”了，Application由BeanFactory一步步扩充而来，提供了很多实用功能，很多在BeanFactory需要配置实现的功能在ApplicationContext中只需要简单的配置即可以实现。</p>\n<h3 id=\"ApplicationbContext类结构体系\"><a href=\"#ApplicationbContext类结构体系\" class=\"headerlink\" title=\"ApplicationbContext类结构体系\"></a>ApplicationbContext类结构体系</h3><p><img src=\"http://epoch-night.oss-cn-hangzhou.aliyuncs.com/PostImg/applicationContext.png\" alt=\"application\"></p>\n<p>ApplicationContext的主要实现类是FileSystemxmlApplicationContext和ClassPathXmlApplicationContext，前者主要加载存储在文件系统上的配置文件，后者主要加载类结构下的Xml文件。ApplicationContext继承了HierarchicalBeanFactory、即永远父子及联、通过接口让子容器访问父容器的方法。而且通过其他接口扩充了BeanFactory的功能。</p>\n<ul>\n<li>ApplicationEventPublisher：让容器拥有发布上下文事件的功能，包括启动关闭等事件。实现了ApplicationListener事件监听端口的Bean可以接收到容器事件，并进行事件响应。在ApplicationContext的抽象实现类AbstractApplicationContext中存在一个ApplicationEventMulticaster，它负责所有的监听器、以便在容器产生上下文事件时通知事件监听者。</li>\n<li>MessageResource：为应用提i18n国际化消息访问的功能。</li>\n<li>ResourcePatternResolver：所有ApplicationContext实现类都实现了类似于PathMatchingResourcePatternResolver的功能，可以通过带前缀的Ant风格的资源文件装载Spring配置文件。</li>\n<li>Lifecycle：该接口提供了start（）和stop（）两个方法，主要用于异步处理过程。在具体实用时，该接口同时被ApplicationContext实现及具体Bean的实现，ApplicationContext会将start/stop的信息传递给容器中所有实现了该接口的Bean，以达到管理和控制JMX、任务调度的目的。</li>\n</ul>\n<p>ConfigurableApplicationContext扩展于ApplicationContext，它新增了两个方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ConfigurableApplicationContext</span> <span class=\"keyword\">extends</span> <span class=\"title\">ApplicationContext</span>, <span class=\"title\">Lifecycle</span>, <span class=\"title\">Closeable</span> </span>&#123;</span><br><span class=\"line\">    String CONFIG_LOCATION_DELIMITERS = <span class=\"string\">\",; \\t\\n\"</span>;</span><br><span class=\"line\">    String CONVERSION_SERVICE_BEAN_NAME = <span class=\"string\">\"conversionService\"</span>;</span><br><span class=\"line\">    String LOAD_TIME_WEAVER_BEAN_NAME = <span class=\"string\">\"loadTimeWeaver\"</span>;</span><br><span class=\"line\">    String ENVIRONMENT_BEAN_NAME = <span class=\"string\">\"environment\"</span>;</span><br><span class=\"line\">    String SYSTEM_PROPERTIES_BEAN_NAME = <span class=\"string\">\"systemProperties\"</span>;</span><br><span class=\"line\">    String SYSTEM_ENVIRONMENT_BEAN_NAME = <span class=\"string\">\"systemEnvironment\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setId</span><span class=\"params\">(String var1)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setParent</span><span class=\"params\">(ApplicationContext var1)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">ConfigurableEnvironment <span class=\"title\">getEnvironment</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setEnvironment</span><span class=\"params\">(ConfigurableEnvironment var1)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addBeanFactoryPostProcessor</span><span class=\"params\">(BeanFactoryPostProcessor var1)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addApplicationListener</span><span class=\"params\">(ApplicationListener&lt;?&gt; var1)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//整个spring启动的核心方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">refresh</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> BeansException, IllegalStateException</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">registerShutdownHook</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">\t<span class=\"comment\">//关闭</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isActive</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">ConfigurableListableBeanFactory <span class=\"title\">getBeanFactory</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IllegalStateException</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>和BeanFactory初始化相似（本质上也是因为继承并且扩展了不同类型的BeanFactory接口），如果配置文件在类路径下，则可以优先考虑使用ClassPathXmlApplicationContext</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">ApplicationContext act = <span class=\"keyword\">new</span> ClassPathXmlApplicationContext(<span class=\"string\">\"com.xxxx.config.xml\"</span>）;</span><br></pre></td></tr></table></figure>\n<p>如果配置文件放在文件系统中，则使用如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">ApplicationContext act = <span class=\"keyword\">new</span> FileSystemXmlApplication(<span class=\"string\">\"/Users/xxx/config.xml\"</span>);</span><br></pre></td></tr></table></figure>\n<p>在获取到ApplicationContext实例后，同样可以通过getBean（）获取bean。ApplicationContext和BeanFactory初始化时有一个重大的不同是BeanFactory并未初始化Bean，而ApplicationContext在应用初始化阶段就会实例化所有<strong>单实例</strong>的Bean。</p>\n<h3 id=\"注解式配置方式\"><a href=\"#注解式配置方式\" class=\"headerlink\" title=\"注解式配置方式\"></a>注解式配置方式</h3><p>Spring支持注解式的配置方式，主要功能来自JavaConfig子项目，现已升级为Spring核心项目。当一个pojo类标注了@Configuration注解，既可以提供Spring所需的Bean信息：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//表示这是一个配置类</span></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//定义一个bean</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span>(name = <span class=\"string\">\"Female\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Female <span class=\"title\">born</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        Female Jerry = <span class=\"keyword\">new</span> Female();</span><br><span class=\"line\">        Jerry.setSkin(<span class=\"string\">\"Blue\"</span>);</span><br><span class=\"line\">        Jerry.setAge(<span class=\"number\">22</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Jerry;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Spring为注解实现了专门的ApplicationContext实现类：ApplicationConfigApplicationContext。加载上述配置示例如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AnnotationConfig</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">getBean</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//通过一个带有Configuration注解的POJO获得Bean</span></span><br><span class=\"line\">        ApplicationContext act = <span class=\"keyword\">new</span> AnnotationConfigApplicationContext(Person.class);</span><br><span class=\"line\">        Femail Jerry = act.getBean(<span class=\"string\">\"Female\"</span>);</span><br><span class=\"line\">        assertNotNull(Jerry);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Groovy-DSL配置Bean\"><a href=\"#Groovy-DSL配置Bean\" class=\"headerlink\" title=\"Groovy DSL配置Bean\"></a>Groovy DSL配置Bean</h3><p>Spring 4.x支持使用Groovy DSL来进行Bean定义配置。其与基于XML文件的配置类似，只不过基于Groovy脚本语言可以实现更复杂的Bean配置逻辑：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"code\"><pre><span class=\"line\">beans&#123;</span><br><span class=\"line\">    Jerry(Person)&#123;<span class=\"comment\">//名字（类型）</span></span><br><span class=\"line\">        name = <span class=\"string\">\"jerry\"</span></span><br><span class=\"line\">        sex = <span class=\"string\">\"female\"</span></span><br><span class=\"line\">        age = <span class=\"number\">22</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>基于Groovy的配置方式很容易让开发者配置复杂的Bean初始化过程，比@Configuration和XML更加灵活，读取Groovy也有专门的ApplicationContext - &gt; GenericGorrvyApplicationContet:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GroovyConfig</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">getBean</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        ApplicationContext act = </span><br><span class=\"line\">        <span class=\"keyword\">new</span> GenericGorrvyApplicationContet(<span class=\"string\">\"com.xxx.beans.groovy\"</span>);</span><br><span class=\"line\">        Femail Jerry = act.getBean(<span class=\"string\">\"Female\"</span>);</span><br><span class=\"line\">        assertNotNull(Jerry);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>对于BeanFactory和ApplicationContext，ApplicationContext面向的是代码开发人员，而BeanFactory则是底层支持，由ApplicationContext实现和扩展，几乎所有的场景都可以使用ApplicationContext。</p>\n<blockquote>\n<p>参考：《Spring技术内幕》、《精通Spring 4.x 企业应用开发实战》</p>\n</blockquote>\n"},{"layout":"post","title":"Spring | DispatcherServlet源码分析(下)","date":"2017-11-21T14:45:00.000Z","author":"Gubaidan","header-img":"/Header/l8Qo5NqYG_k.png","cdn":"header-on","_content":"\n# 说明\n\nDispatcherServlet是SpringMVC的核心分发器，它实现了请求分发，是处理请求的入口，本篇将深入源码分析它的请求分发过程。\n\n 回顾DispatcherServlet 继承关系图：\n\n<img style=\"width:90%;\" src=\"http://epoch-night.oss-cn-hangzhou.aliyuncs.com/PostImg/servlet.png\"/>\n\n\nServlet在service方法中进行请求接收与分发，DispatcherServlet的service方法继承自HttpServlet，具体代码如下图所示。\n\n```java\n/**\n*代码位置：HttpServlet#service（）\n**/\nprotected void service(HttpServletRequest req, HttpServletResponse resp)\n        throws ServletException, IOException\n    {\n    //获取请求方式\n    String method = req.getMethod();\n\t//如果是get ，METHOD_GET 不同的请求方法会执行不同的代码，包括put,delete,post,trace.....\n    if (method.equals(METHOD_GET)) {\n        long lastModified = getLastModified(req);\n        if (lastModified == -1) {\n            // servlet doesn't support if-modified-since, no reason\n            // to go through further expensive logic\n            doGet(req, resp);\n        } else {\n            long ifModifiedSince = req.getDateHeader(HEADER_IFMODSINCE);\n            if (ifModifiedSince < lastModified) {\n                // If the servlet mod time is later, call doGet()\n                // Round down to the nearest second for a proper compare\n                // A ifModifiedSince of -1 will always be less\n                maybeSetLastModified(resp, lastModified);\n                doGet(req, resp);\n            } else {\n                resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED);\n            }\n        }\n\n    } else if (method.equals(METHOD_HEAD)) {\n        long lastModified = getLastModified(req);\n        maybeSetLastModified(resp, lastModified);\n        doHead(req, resp);\n\n   } else if (method.equals(METHOD_POST)) {\n        doPost(req, resp);\n            \n    } else if (method.equals(METHOD_PUT)) {\n        doPut(req, resp);\n            \n    } else if (method.equals(METHOD_DELETE)) {\n        doDelete(req, resp);\n            \n    } else if (method.equals(METHOD_OPTIONS)) {\n        doOptions(req,resp);\n            \n    } else if (method.equals(METHOD_TRACE)) {\n        doTrace(req,resp);\n           \n    } else {\n        //\n        // Note that this means NO servlet supports whatever\n        // method was requested, anywhere on this server.\n        //\n\n        String errMsg = lStrings.getString(\"http.method_not_implemented\");\n        Object[] errArgs = new Object[1];\n        errArgs[0] = method;\n        errMsg = MessageFormat.format(errMsg, errArgs);\n            \n        resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg);\n    }\n }\n```\n\n在FrameworkServlet中对这个protected修饰的service方法进行了重写，重写的目的是支持PATCH方式请求，具体代码如下图所示。 \n\n```java\n/**\n代码位置：FrameworkServlet#service（）\n**/\n@Override\nprotected void service(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows ServletException, IOException {\n\n\tHttpMethod httpMethod = HttpMethod.resolve(request.getMethod());\n    //支持PATCH方法\n\tif (HttpMethod.PATCH == httpMethod || httpMethod == null) {\n\t\tprocessRequest(request, response);\n\t}\n\telse {\n        //调用父类service方法\n\t\tsuper.service(request, response);\n\t}\n}\n```\n\n上述分析中的doGet、doPost等方法在HttpServlet中没有实际可用的实现，如果要使用这些方法，子类需要重写这些方法，DispatcherServlet没有重写这些方法，在DispatcherServlet的父类FrameworkServlet中进行了重写，看几个重写后的方法代码。\n\n```java\n/**\n代码位置：FrameworkServlet#doGet（）\n**/\n@Override\nprotected final void doGet(HttpServletRequest request, HttpServletResponse response)\n\t\tthrows ServletException, IOException {\n\tprocessRequest(request, response);\n}\n```\n\n可以看到这些请求都会进入当前FrameworkServlet类的processRequest方法进行处理，具体代码如下图所示。\n\n\n```java\n/**\n代码位置：FrameworkServlet#processRequest（）\n**/\nprotected final void processRequest(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows ServletException, IOException {\n\n\tlong startTime = System.currentTimeMillis();\n\tThrowable failureCause = null;\n\n    //构造LocaleContext和RequestAttributes 绑定到当前线程\n\tLocaleContext previousLocaleContext = LocaleContextHolder.getLocaleContext();\n\tLocaleContext localeContext = buildLocaleContext(request);\n\n\tRequestAttributes previousAttributes = RequestContextHolder.getRequestAttributes();\n\tServletRequestAttributes requestAttributes = buildRequestAttributes(request, response, previousAttributes);\n\n\tWebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);\n\tasyncManager.registerCallableInterceptor(FrameworkServlet.class.getName(), new RequestBindingInterceptor());\n\n\tinitContextHolders(request, localeContext, requestAttributes);\n\n\ttry {\n        //抽象方法 子类实现\n\t\tdoService(request, response);\n\t}\n\tcatch (ServletException ex) {\n\t\tfailureCause = ex;\n\t\tthrow ex;\n\t}\n\tcatch (IOException ex) {\n\t\tfailureCause = ex;\n\t\tthrow ex;\n\t}\n\tcatch (Throwable ex) {\n\t\tfailureCause = ex;\n\t\tthrow new NestedServletException(\"Request processing failed\", ex);\n\t}\n\n\tfinally {\n\t\tresetContextHolders(request, previousLocaleContext, previousAttributes);\n\t\tif (requestAttributes != null) {\n\t\t\trequestAttributes.requestCompleted();\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tif (failureCause != null) {\n\t\t\t\tthis.logger.debug(\"Could not complete request\", failureCause);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (asyncManager.isConcurrentHandlingStarted()) {\n\t\t\t\t\tlogger.debug(\"Leaving response open for concurrent processing\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthis.logger.debug(\"Successfully completed request\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublishRequestHandledEvent(request, response, startTime, failureCause);\n\t}\n}\n```\n\nFrameworkServlet中的doService是一个抽象方法，DispatcherServlet重写了这个方法，具体代码如下图。 \n\n```java\n/**\n代码位置：DispatcherServlet#doService（）\n**/\n@Override\nprotected void doService(HttpServletRequest request, HttpServletResponse response) throws Exception {\n\tif (logger.isDebugEnabled()) {\n\t\tString resumed = WebAsyncUtils.getAsyncManager(request).hasConcurrentResult() ? \" resumed\" : \"\";\n\t\tlogger.debug(\"DispatcherServlet with name '\" + getServletName() + \"'\" + resumed +\n\t\t\t\t\t\" processing \" + request.getMethod() + \" request for [\" + getRequestUri(request) + \"]\");\n\t}\n\n\t// Keep a snapshot of the request attributes in case of an include,\n\t// to be able to restore the original attributes after the include.\n    //对include请求保存一份快照，等会保存到request 属性中\n\tMap<String, Object> attributesSnapshot = null;\n\tif (WebUtils.isIncludeRequest(request)) {\n\t\tattributesSnapshot = new HashMap<String, Object>();\n\t\tEnumeration<?> attrNames = request.getAttributeNames();\n\t\twhile (attrNames.hasMoreElements()) {\n\t\t\tString attrName = (String) attrNames.nextElement();\n\t\t\tif (this.cleanupAfterInclude || attrName.startsWith(\"org.springframework.web.servlet\")) {\n\t\t\t\tattributesSnapshot.put(attrName, request.getAttribute(attrName));\n\t\t\t}\n\t\t}\n\t}\n\n\t// Make framework objects available to handlers and view objects.\n\trequest.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext());\n\trequest.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, this.localeResolver);\n\trequest.setAttribute(THEME_RESOLVER_ATTRIBUTE, this.themeResolver);\n\trequest.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());\n\n\tFlashMap inputFlashMap = this.flashMapManager.retrieveAndUpdate(request, response);\n\tif (inputFlashMap != null) {\n\t\trequest.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap));\n\t}\n\trequest.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, new FlashMap());\n\trequest.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, this.flashMapManager);\n\n\ttry {\n        // 分发请求到具体的handle\n\t\tdoDispatch(request, response);\n\t}\n\tfinally {\n\t\tif (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) {\n\t\t\t// Restore the original attribute snapshot, in case of an include.\n\t\t\tif (attributesSnapshot != null) {\n\t\t\t\trestoreAttributesAfterInclude(request, attributesSnapshot);\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n进入doDispatch方法，这个方法实现了将请求分发到具体Handler、执行拦截器的preHandle方法、调用Handler（编写的Controller）处理具体逻辑、执行拦截器的postHandle方法、处理返回的ModelAndView或异常、执行拦截器的afterCompletion方法，具体代码如下。/** 代码位置：DispatcherServlet#doService（） **/\n\n```java\nprotected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {\n\tHttpServletRequest processedRequest = request;\n\tHandlerExecutionChain mappedHandler = null;\n\tboolean multipartRequestParsed = false;\n\n\tWebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);\n\n\ttry {\n\t\tModelAndView mv = null;\n\t\tException dispatchException = null;\n\n\t\ttry {\n\t\t\tprocessedRequest = checkMultipart(request);\n\t\t\tmultipartRequestParsed = (processedRequest != request);\n\n\t\t\t// 根据实际请求的url查找具体的handle，这些handle被封装在HandlerMethod中，\n            //这个HandlerMethod又封装在HandlerExecutionChin中\n\t\t\tmappedHandler = getHandler(processedRequest);\n\t\t\tif (mappedHandler == null || mappedHandler.getHandler() == null) {\n\t\t\t\tnoHandlerFound(processedRequest, response);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// 便利HandlerAdapter， 查找支持这个请求的HandlerAdapter\n\t\t\tHandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());\n\n\t\t\t// Process last-modified header, if supported by the handler.\n\t\t\tString method = request.getMethod();\n\t\t\tboolean isGet = \"GET\".equals(method);\n\t\t\tif (isGet || \"HEAD\".equals(method)) {\n\t\t\t\tlong lastModified = ha.getLastModified(request, mappedHandler.getHandler());\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Last-Modified value for [\" + getRequestUri(request) + \"] is: \" + lastModified);\n\t\t\t\t}\n\t\t\t\tif (new ServletWebRequest(request, response).checkNotModified(lastModified) && isGet) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n            \n\t\t\t//拦截器的mappedHandler\n\t\t\tif (!mappedHandler.applyPreHandle(processedRequest, response)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// 调用实际编写的handler处理请求，也就是controller\n\t\t\tmv = ha.handle(processedRequest, response, mappedHandler.getHandler());\n            \n            .....\n\n\t}\n```\n\n上图描述中的HandlerMethod和HandlerExecutionChain代码如下所示\n\n```java\n/**\n*代码位置：HandlerMethod\n**/\npublic class HandlerMethod {\n    protected final Log logger = LogFactory.getLog(this.getClass());\n    private final Object bean;    //controller实例\n    private final BeanFactory beanFactory;\n    private final Class<?> beanType;\n    private final Method method;   //实际方法\n    private final Method bridgedMethod;\n    private final MethodParameter[] parameters;  //参数\n    private final HandlerMethod resolvedFromHandlerMethod;\n    ...\n```\n\n\n\n```java\n/**\n*代码位置：HandlerExecutionChain\n**/\npublic class HandlerExecutionChain {\n\n\tprivate static final Log logger = LogFactory.getLog(HandlerExecutionChain.class);\n\n\tprivate final Object handler;   //handlerMethod实例\n\n\tprivate HandlerInterceptor[] interceptors;\n\n\tprivate List<HandlerInterceptor> interceptorList;//拦截器实例\n\n\tprivate int interceptorIndex = -1;\n    ...\n```\n\n\n\n\n# 总结\n\n首先，Spring框架在启动的时候IOC容器会遍历IOC容器中的所有bean，对标注了@Controller或@RequestMapping注解的类中方法进行遍历，将类和方法上的@RequestMapping注解中的value值进行合并，使用@RequestMapping注解的相关参数值(如value、method等)封装一个RequestMappingInfo，将这个Controller实例、方法及方法参数信息(类型、注解等)封装到HandlerMethod中，然后以RequestMappingInfo为key，HandlerMethod为value存到一个以Map为结构的handlerMethods中。\n\n接着，将@RequestMapping注解中的value(即请求路径)值取出，即url，然后以url为key，以RequestMappingInfo为value，存到一个以Map为结构的urlMap属性中。\n\ns客户端发起请求的时候，根据请求的URL到urlMap中查找，找到RequestMappingInfo，然后根据RequestMappingInfo到handlerMethods中查找，找到对应的HandlerMethod，接着将HandlerMethod封装到HandlerExecutionChain；接着遍历容器中所有HandlerAdapter实现类，找到支持这次请求的HandlerAdapter，如RequestMappingHandlerAdapter，然后执行SpringMVC拦截器的前置方法(preHandle方法)，然后对请求参数解析及转换，然后(使用反射)调用具体Controller的对应方法返回一个ModelAndView对象，执行拦截器的后置方法(postHandle方法)，然后对返回的结果进行处理，最后执行afterCompletion方法。\n\n> 参考：《Spring技术内幕》、《精通Spring 4.x 企业应用开发实战》 \n\n \n\n \n\n \n\n ","source":"_posts/2017-11-21-DispatcherServlet-after.markdown","raw":"---\nlayout: post\ntitle: \"Spring | DispatcherServlet源码分析(下)\"\ndate: 2017-11-21 22:45\nauthor: \"Gubaidan\"\nheader-img: \"/Header/l8Qo5NqYG_k.png\"\ncdn: 'header-on'\ntags:\n\t- Spring\n---\n\n# 说明\n\nDispatcherServlet是SpringMVC的核心分发器，它实现了请求分发，是处理请求的入口，本篇将深入源码分析它的请求分发过程。\n\n 回顾DispatcherServlet 继承关系图：\n\n<img style=\"width:90%;\" src=\"http://epoch-night.oss-cn-hangzhou.aliyuncs.com/PostImg/servlet.png\"/>\n\n\nServlet在service方法中进行请求接收与分发，DispatcherServlet的service方法继承自HttpServlet，具体代码如下图所示。\n\n```java\n/**\n*代码位置：HttpServlet#service（）\n**/\nprotected void service(HttpServletRequest req, HttpServletResponse resp)\n        throws ServletException, IOException\n    {\n    //获取请求方式\n    String method = req.getMethod();\n\t//如果是get ，METHOD_GET 不同的请求方法会执行不同的代码，包括put,delete,post,trace.....\n    if (method.equals(METHOD_GET)) {\n        long lastModified = getLastModified(req);\n        if (lastModified == -1) {\n            // servlet doesn't support if-modified-since, no reason\n            // to go through further expensive logic\n            doGet(req, resp);\n        } else {\n            long ifModifiedSince = req.getDateHeader(HEADER_IFMODSINCE);\n            if (ifModifiedSince < lastModified) {\n                // If the servlet mod time is later, call doGet()\n                // Round down to the nearest second for a proper compare\n                // A ifModifiedSince of -1 will always be less\n                maybeSetLastModified(resp, lastModified);\n                doGet(req, resp);\n            } else {\n                resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED);\n            }\n        }\n\n    } else if (method.equals(METHOD_HEAD)) {\n        long lastModified = getLastModified(req);\n        maybeSetLastModified(resp, lastModified);\n        doHead(req, resp);\n\n   } else if (method.equals(METHOD_POST)) {\n        doPost(req, resp);\n            \n    } else if (method.equals(METHOD_PUT)) {\n        doPut(req, resp);\n            \n    } else if (method.equals(METHOD_DELETE)) {\n        doDelete(req, resp);\n            \n    } else if (method.equals(METHOD_OPTIONS)) {\n        doOptions(req,resp);\n            \n    } else if (method.equals(METHOD_TRACE)) {\n        doTrace(req,resp);\n           \n    } else {\n        //\n        // Note that this means NO servlet supports whatever\n        // method was requested, anywhere on this server.\n        //\n\n        String errMsg = lStrings.getString(\"http.method_not_implemented\");\n        Object[] errArgs = new Object[1];\n        errArgs[0] = method;\n        errMsg = MessageFormat.format(errMsg, errArgs);\n            \n        resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg);\n    }\n }\n```\n\n在FrameworkServlet中对这个protected修饰的service方法进行了重写，重写的目的是支持PATCH方式请求，具体代码如下图所示。 \n\n```java\n/**\n代码位置：FrameworkServlet#service（）\n**/\n@Override\nprotected void service(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows ServletException, IOException {\n\n\tHttpMethod httpMethod = HttpMethod.resolve(request.getMethod());\n    //支持PATCH方法\n\tif (HttpMethod.PATCH == httpMethod || httpMethod == null) {\n\t\tprocessRequest(request, response);\n\t}\n\telse {\n        //调用父类service方法\n\t\tsuper.service(request, response);\n\t}\n}\n```\n\n上述分析中的doGet、doPost等方法在HttpServlet中没有实际可用的实现，如果要使用这些方法，子类需要重写这些方法，DispatcherServlet没有重写这些方法，在DispatcherServlet的父类FrameworkServlet中进行了重写，看几个重写后的方法代码。\n\n```java\n/**\n代码位置：FrameworkServlet#doGet（）\n**/\n@Override\nprotected final void doGet(HttpServletRequest request, HttpServletResponse response)\n\t\tthrows ServletException, IOException {\n\tprocessRequest(request, response);\n}\n```\n\n可以看到这些请求都会进入当前FrameworkServlet类的processRequest方法进行处理，具体代码如下图所示。\n\n\n```java\n/**\n代码位置：FrameworkServlet#processRequest（）\n**/\nprotected final void processRequest(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows ServletException, IOException {\n\n\tlong startTime = System.currentTimeMillis();\n\tThrowable failureCause = null;\n\n    //构造LocaleContext和RequestAttributes 绑定到当前线程\n\tLocaleContext previousLocaleContext = LocaleContextHolder.getLocaleContext();\n\tLocaleContext localeContext = buildLocaleContext(request);\n\n\tRequestAttributes previousAttributes = RequestContextHolder.getRequestAttributes();\n\tServletRequestAttributes requestAttributes = buildRequestAttributes(request, response, previousAttributes);\n\n\tWebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);\n\tasyncManager.registerCallableInterceptor(FrameworkServlet.class.getName(), new RequestBindingInterceptor());\n\n\tinitContextHolders(request, localeContext, requestAttributes);\n\n\ttry {\n        //抽象方法 子类实现\n\t\tdoService(request, response);\n\t}\n\tcatch (ServletException ex) {\n\t\tfailureCause = ex;\n\t\tthrow ex;\n\t}\n\tcatch (IOException ex) {\n\t\tfailureCause = ex;\n\t\tthrow ex;\n\t}\n\tcatch (Throwable ex) {\n\t\tfailureCause = ex;\n\t\tthrow new NestedServletException(\"Request processing failed\", ex);\n\t}\n\n\tfinally {\n\t\tresetContextHolders(request, previousLocaleContext, previousAttributes);\n\t\tif (requestAttributes != null) {\n\t\t\trequestAttributes.requestCompleted();\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tif (failureCause != null) {\n\t\t\t\tthis.logger.debug(\"Could not complete request\", failureCause);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (asyncManager.isConcurrentHandlingStarted()) {\n\t\t\t\t\tlogger.debug(\"Leaving response open for concurrent processing\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthis.logger.debug(\"Successfully completed request\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublishRequestHandledEvent(request, response, startTime, failureCause);\n\t}\n}\n```\n\nFrameworkServlet中的doService是一个抽象方法，DispatcherServlet重写了这个方法，具体代码如下图。 \n\n```java\n/**\n代码位置：DispatcherServlet#doService（）\n**/\n@Override\nprotected void doService(HttpServletRequest request, HttpServletResponse response) throws Exception {\n\tif (logger.isDebugEnabled()) {\n\t\tString resumed = WebAsyncUtils.getAsyncManager(request).hasConcurrentResult() ? \" resumed\" : \"\";\n\t\tlogger.debug(\"DispatcherServlet with name '\" + getServletName() + \"'\" + resumed +\n\t\t\t\t\t\" processing \" + request.getMethod() + \" request for [\" + getRequestUri(request) + \"]\");\n\t}\n\n\t// Keep a snapshot of the request attributes in case of an include,\n\t// to be able to restore the original attributes after the include.\n    //对include请求保存一份快照，等会保存到request 属性中\n\tMap<String, Object> attributesSnapshot = null;\n\tif (WebUtils.isIncludeRequest(request)) {\n\t\tattributesSnapshot = new HashMap<String, Object>();\n\t\tEnumeration<?> attrNames = request.getAttributeNames();\n\t\twhile (attrNames.hasMoreElements()) {\n\t\t\tString attrName = (String) attrNames.nextElement();\n\t\t\tif (this.cleanupAfterInclude || attrName.startsWith(\"org.springframework.web.servlet\")) {\n\t\t\t\tattributesSnapshot.put(attrName, request.getAttribute(attrName));\n\t\t\t}\n\t\t}\n\t}\n\n\t// Make framework objects available to handlers and view objects.\n\trequest.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext());\n\trequest.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, this.localeResolver);\n\trequest.setAttribute(THEME_RESOLVER_ATTRIBUTE, this.themeResolver);\n\trequest.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());\n\n\tFlashMap inputFlashMap = this.flashMapManager.retrieveAndUpdate(request, response);\n\tif (inputFlashMap != null) {\n\t\trequest.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap));\n\t}\n\trequest.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, new FlashMap());\n\trequest.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, this.flashMapManager);\n\n\ttry {\n        // 分发请求到具体的handle\n\t\tdoDispatch(request, response);\n\t}\n\tfinally {\n\t\tif (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) {\n\t\t\t// Restore the original attribute snapshot, in case of an include.\n\t\t\tif (attributesSnapshot != null) {\n\t\t\t\trestoreAttributesAfterInclude(request, attributesSnapshot);\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n进入doDispatch方法，这个方法实现了将请求分发到具体Handler、执行拦截器的preHandle方法、调用Handler（编写的Controller）处理具体逻辑、执行拦截器的postHandle方法、处理返回的ModelAndView或异常、执行拦截器的afterCompletion方法，具体代码如下。/** 代码位置：DispatcherServlet#doService（） **/\n\n```java\nprotected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {\n\tHttpServletRequest processedRequest = request;\n\tHandlerExecutionChain mappedHandler = null;\n\tboolean multipartRequestParsed = false;\n\n\tWebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);\n\n\ttry {\n\t\tModelAndView mv = null;\n\t\tException dispatchException = null;\n\n\t\ttry {\n\t\t\tprocessedRequest = checkMultipart(request);\n\t\t\tmultipartRequestParsed = (processedRequest != request);\n\n\t\t\t// 根据实际请求的url查找具体的handle，这些handle被封装在HandlerMethod中，\n            //这个HandlerMethod又封装在HandlerExecutionChin中\n\t\t\tmappedHandler = getHandler(processedRequest);\n\t\t\tif (mappedHandler == null || mappedHandler.getHandler() == null) {\n\t\t\t\tnoHandlerFound(processedRequest, response);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// 便利HandlerAdapter， 查找支持这个请求的HandlerAdapter\n\t\t\tHandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());\n\n\t\t\t// Process last-modified header, if supported by the handler.\n\t\t\tString method = request.getMethod();\n\t\t\tboolean isGet = \"GET\".equals(method);\n\t\t\tif (isGet || \"HEAD\".equals(method)) {\n\t\t\t\tlong lastModified = ha.getLastModified(request, mappedHandler.getHandler());\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Last-Modified value for [\" + getRequestUri(request) + \"] is: \" + lastModified);\n\t\t\t\t}\n\t\t\t\tif (new ServletWebRequest(request, response).checkNotModified(lastModified) && isGet) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n            \n\t\t\t//拦截器的mappedHandler\n\t\t\tif (!mappedHandler.applyPreHandle(processedRequest, response)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// 调用实际编写的handler处理请求，也就是controller\n\t\t\tmv = ha.handle(processedRequest, response, mappedHandler.getHandler());\n            \n            .....\n\n\t}\n```\n\n上图描述中的HandlerMethod和HandlerExecutionChain代码如下所示\n\n```java\n/**\n*代码位置：HandlerMethod\n**/\npublic class HandlerMethod {\n    protected final Log logger = LogFactory.getLog(this.getClass());\n    private final Object bean;    //controller实例\n    private final BeanFactory beanFactory;\n    private final Class<?> beanType;\n    private final Method method;   //实际方法\n    private final Method bridgedMethod;\n    private final MethodParameter[] parameters;  //参数\n    private final HandlerMethod resolvedFromHandlerMethod;\n    ...\n```\n\n\n\n```java\n/**\n*代码位置：HandlerExecutionChain\n**/\npublic class HandlerExecutionChain {\n\n\tprivate static final Log logger = LogFactory.getLog(HandlerExecutionChain.class);\n\n\tprivate final Object handler;   //handlerMethod实例\n\n\tprivate HandlerInterceptor[] interceptors;\n\n\tprivate List<HandlerInterceptor> interceptorList;//拦截器实例\n\n\tprivate int interceptorIndex = -1;\n    ...\n```\n\n\n\n\n# 总结\n\n首先，Spring框架在启动的时候IOC容器会遍历IOC容器中的所有bean，对标注了@Controller或@RequestMapping注解的类中方法进行遍历，将类和方法上的@RequestMapping注解中的value值进行合并，使用@RequestMapping注解的相关参数值(如value、method等)封装一个RequestMappingInfo，将这个Controller实例、方法及方法参数信息(类型、注解等)封装到HandlerMethod中，然后以RequestMappingInfo为key，HandlerMethod为value存到一个以Map为结构的handlerMethods中。\n\n接着，将@RequestMapping注解中的value(即请求路径)值取出，即url，然后以url为key，以RequestMappingInfo为value，存到一个以Map为结构的urlMap属性中。\n\ns客户端发起请求的时候，根据请求的URL到urlMap中查找，找到RequestMappingInfo，然后根据RequestMappingInfo到handlerMethods中查找，找到对应的HandlerMethod，接着将HandlerMethod封装到HandlerExecutionChain；接着遍历容器中所有HandlerAdapter实现类，找到支持这次请求的HandlerAdapter，如RequestMappingHandlerAdapter，然后执行SpringMVC拦截器的前置方法(preHandle方法)，然后对请求参数解析及转换，然后(使用反射)调用具体Controller的对应方法返回一个ModelAndView对象，执行拦截器的后置方法(postHandle方法)，然后对返回的结果进行处理，最后执行afterCompletion方法。\n\n> 参考：《Spring技术内幕》、《精通Spring 4.x 企业应用开发实战》 \n\n \n\n \n\n \n\n ","slug":"2017-11-21-DispatcherServlet-after","published":1,"updated":"2019-05-05T12:35:24.858Z","comments":1,"photos":[],"link":"","_id":"cjvayvwgb0020m46axkqod06r","content":"<h1 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h1><p>DispatcherServlet是SpringMVC的核心分发器，它实现了请求分发，是处理请求的入口，本篇将深入源码分析它的请求分发过程。</p>\n<p> 回顾DispatcherServlet 继承关系图：</p>\n<p><img style=\"width:90%;\" src=\"http://epoch-night.oss-cn-hangzhou.aliyuncs.com/PostImg/servlet.png\"></p>\n<p>Servlet在service方法中进行请求接收与分发，DispatcherServlet的service方法继承自HttpServlet，具体代码如下图所示。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">*代码位置：HttpServlet#service（）</span></span><br><span class=\"line\"><span class=\"comment\">**/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">service</span><span class=\"params\">(HttpServletRequest req, HttpServletResponse resp)</span></span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"keyword\">throws</span> ServletException, IOException</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//获取请求方式</span></span><br><span class=\"line\">    String method = req.getMethod();</span><br><span class=\"line\">\t<span class=\"comment\">//如果是get ，METHOD_GET 不同的请求方法会执行不同的代码，包括put,delete,post,trace.....</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (method.equals(METHOD_GET)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> lastModified = getLastModified(req);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (lastModified == -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// servlet doesn't support if-modified-since, no reason</span></span><br><span class=\"line\">            <span class=\"comment\">// to go through further expensive logic</span></span><br><span class=\"line\">            doGet(req, resp);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">long</span> ifModifiedSince = req.getDateHeader(HEADER_IFMODSINCE);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ifModifiedSince &lt; lastModified) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// If the servlet mod time is later, call doGet()</span></span><br><span class=\"line\">                <span class=\"comment\">// Round down to the nearest second for a proper compare</span></span><br><span class=\"line\">                <span class=\"comment\">// A ifModifiedSince of -1 will always be less</span></span><br><span class=\"line\">                maybeSetLastModified(resp, lastModified);</span><br><span class=\"line\">                doGet(req, resp);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (method.equals(METHOD_HEAD)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> lastModified = getLastModified(req);</span><br><span class=\"line\">        maybeSetLastModified(resp, lastModified);</span><br><span class=\"line\">        doHead(req, resp);</span><br><span class=\"line\"></span><br><span class=\"line\">   &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (method.equals(METHOD_POST)) &#123;</span><br><span class=\"line\">        doPost(req, resp);</span><br><span class=\"line\">            </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (method.equals(METHOD_PUT)) &#123;</span><br><span class=\"line\">        doPut(req, resp);</span><br><span class=\"line\">            </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (method.equals(METHOD_DELETE)) &#123;</span><br><span class=\"line\">        doDelete(req, resp);</span><br><span class=\"line\">            </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (method.equals(METHOD_OPTIONS)) &#123;</span><br><span class=\"line\">        doOptions(req,resp);</span><br><span class=\"line\">            </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (method.equals(METHOD_TRACE)) &#123;</span><br><span class=\"line\">        doTrace(req,resp);</span><br><span class=\"line\">           </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//</span></span><br><span class=\"line\">        <span class=\"comment\">// Note that this means NO servlet supports whatever</span></span><br><span class=\"line\">        <span class=\"comment\">// method was requested, anywhere on this server.</span></span><br><span class=\"line\">        <span class=\"comment\">//</span></span><br><span class=\"line\"></span><br><span class=\"line\">        String errMsg = lStrings.getString(<span class=\"string\">\"http.method_not_implemented\"</span>);</span><br><span class=\"line\">        Object[] errArgs = <span class=\"keyword\">new</span> Object[<span class=\"number\">1</span>];</span><br><span class=\"line\">        errArgs[<span class=\"number\">0</span>] = method;</span><br><span class=\"line\">        errMsg = MessageFormat.format(errMsg, errArgs);</span><br><span class=\"line\">            </span><br><span class=\"line\">        resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>在FrameworkServlet中对这个protected修饰的service方法进行了重写，重写的目的是支持PATCH方式请求，具体代码如下图所示。 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">代码位置：FrameworkServlet#service（）</span></span><br><span class=\"line\"><span class=\"comment\">**/</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">service</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class=\"line\"><span class=\"function\">\t\t\t<span class=\"keyword\">throws</span> ServletException, IOException </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tHttpMethod httpMethod = HttpMethod.resolve(request.getMethod());</span><br><span class=\"line\">    <span class=\"comment\">//支持PATCH方法</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (HttpMethod.PATCH == httpMethod || httpMethod == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\tprocessRequest(request, response);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//调用父类service方法</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">super</span>.service(request, response);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述分析中的doGet、doPost等方法在HttpServlet中没有实际可用的实现，如果要使用这些方法，子类需要重写这些方法，DispatcherServlet没有重写这些方法，在DispatcherServlet的父类FrameworkServlet中进行了重写，看几个重写后的方法代码。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">代码位置：FrameworkServlet#doGet（）</span></span><br><span class=\"line\"><span class=\"comment\">**/</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">doGet</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class=\"line\"><span class=\"function\">\t\t<span class=\"keyword\">throws</span> ServletException, IOException </span>&#123;</span><br><span class=\"line\">\tprocessRequest(request, response);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到这些请求都会进入当前FrameworkServlet类的processRequest方法进行处理，具体代码如下图所示。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">代码位置：FrameworkServlet#processRequest（）</span></span><br><span class=\"line\"><span class=\"comment\">**/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">processRequest</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class=\"line\"><span class=\"function\">\t\t\t<span class=\"keyword\">throws</span> ServletException, IOException </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">long</span> startTime = System.currentTimeMillis();</span><br><span class=\"line\">\tThrowable failureCause = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//构造LocaleContext和RequestAttributes 绑定到当前线程</span></span><br><span class=\"line\">\tLocaleContext previousLocaleContext = LocaleContextHolder.getLocaleContext();</span><br><span class=\"line\">\tLocaleContext localeContext = buildLocaleContext(request);</span><br><span class=\"line\"></span><br><span class=\"line\">\tRequestAttributes previousAttributes = RequestContextHolder.getRequestAttributes();</span><br><span class=\"line\">\tServletRequestAttributes requestAttributes = buildRequestAttributes(request, response, previousAttributes);</span><br><span class=\"line\"></span><br><span class=\"line\">\tWebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class=\"line\">\tasyncManager.registerCallableInterceptor(FrameworkServlet.class.getName(), <span class=\"keyword\">new</span> RequestBindingInterceptor());</span><br><span class=\"line\"></span><br><span class=\"line\">\tinitContextHolders(request, localeContext, requestAttributes);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//抽象方法 子类实现</span></span><br><span class=\"line\">\t\tdoService(request, response);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">catch</span> (ServletException ex) &#123;</span><br><span class=\"line\">\t\tfailureCause = ex;</span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> ex;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">catch</span> (IOException ex) &#123;</span><br><span class=\"line\">\t\tfailureCause = ex;</span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> ex;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">catch</span> (Throwable ex) &#123;</span><br><span class=\"line\">\t\tfailureCause = ex;</span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NestedServletException(<span class=\"string\">\"Request processing failed\"</span>, ex);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">\t\tresetContextHolders(request, previousLocaleContext, previousAttributes);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (requestAttributes != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\trequestAttributes.requestCompleted();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (failureCause != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">this</span>.logger.debug(<span class=\"string\">\"Could not complete request\"</span>, failureCause);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class=\"line\">\t\t\t\t\tlogger.debug(<span class=\"string\">\"Leaving response open for concurrent processing\"</span>);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">this</span>.logger.debug(<span class=\"string\">\"Successfully completed request\"</span>);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tpublishRequestHandledEvent(request, response, startTime, failureCause);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>FrameworkServlet中的doService是一个抽象方法，DispatcherServlet重写了这个方法，具体代码如下图。 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">代码位置：DispatcherServlet#doService（）</span></span><br><span class=\"line\"><span class=\"comment\">**/</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">doService</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">\t\tString resumed = WebAsyncUtils.getAsyncManager(request).hasConcurrentResult() ? <span class=\"string\">\" resumed\"</span> : <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">\t\tlogger.debug(<span class=\"string\">\"DispatcherServlet with name '\"</span> + getServletName() + <span class=\"string\">\"'\"</span> + resumed +</span><br><span class=\"line\">\t\t\t\t\t<span class=\"string\">\" processing \"</span> + request.getMethod() + <span class=\"string\">\" request for [\"</span> + getRequestUri(request) + <span class=\"string\">\"]\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Keep a snapshot of the request attributes in case of an include,</span></span><br><span class=\"line\">\t<span class=\"comment\">// to be able to restore the original attributes after the include.</span></span><br><span class=\"line\">    <span class=\"comment\">//对include请求保存一份快照，等会保存到request 属性中</span></span><br><span class=\"line\">\tMap&lt;String, Object&gt; attributesSnapshot = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (WebUtils.isIncludeRequest(request)) &#123;</span><br><span class=\"line\">\t\tattributesSnapshot = <span class=\"keyword\">new</span> HashMap&lt;String, Object&gt;();</span><br><span class=\"line\">\t\tEnumeration&lt;?&gt; attrNames = request.getAttributeNames();</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (attrNames.hasMoreElements()) &#123;</span><br><span class=\"line\">\t\t\tString attrName = (String) attrNames.nextElement();</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.cleanupAfterInclude || attrName.startsWith(<span class=\"string\">\"org.springframework.web.servlet\"</span>)) &#123;</span><br><span class=\"line\">\t\t\t\tattributesSnapshot.put(attrName, request.getAttribute(attrName));</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Make framework objects available to handlers and view objects.</span></span><br><span class=\"line\">\trequest.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext());</span><br><span class=\"line\">\trequest.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, <span class=\"keyword\">this</span>.localeResolver);</span><br><span class=\"line\">\trequest.setAttribute(THEME_RESOLVER_ATTRIBUTE, <span class=\"keyword\">this</span>.themeResolver);</span><br><span class=\"line\">\trequest.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());</span><br><span class=\"line\"></span><br><span class=\"line\">\tFlashMap inputFlashMap = <span class=\"keyword\">this</span>.flashMapManager.retrieveAndUpdate(request, response);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (inputFlashMap != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\trequest.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\trequest.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, <span class=\"keyword\">new</span> FlashMap());</span><br><span class=\"line\">\trequest.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, <span class=\"keyword\">this</span>.flashMapManager);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 分发请求到具体的handle</span></span><br><span class=\"line\">\t\tdoDispatch(request, response);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// Restore the original attribute snapshot, in case of an include.</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (attributesSnapshot != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t\trestoreAttributesAfterInclude(request, attributesSnapshot);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>进入doDispatch方法，这个方法实现了将请求分发到具体Handler、执行拦截器的preHandle方法、调用Handler（编写的Controller）处理具体逻辑、执行拦截器的postHandle方法、处理返回的ModelAndView或异常、执行拦截器的afterCompletion方法，具体代码如下。/<strong> 代码位置：DispatcherServlet#doService（） </strong>/</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">doDispatch</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">\tHttpServletRequest processedRequest = request;</span><br><span class=\"line\">\tHandlerExecutionChain mappedHandler = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">boolean</span> multipartRequestParsed = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tWebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\tModelAndView mv = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\tException dispatchException = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\tprocessedRequest = checkMultipart(request);</span><br><span class=\"line\">\t\t\tmultipartRequestParsed = (processedRequest != request);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 根据实际请求的url查找具体的handle，这些handle被封装在HandlerMethod中，</span></span><br><span class=\"line\">            <span class=\"comment\">//这个HandlerMethod又封装在HandlerExecutionChin中</span></span><br><span class=\"line\">\t\t\tmappedHandler = getHandler(processedRequest);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (mappedHandler == <span class=\"keyword\">null</span> || mappedHandler.getHandler() == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t\tnoHandlerFound(processedRequest, response);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 便利HandlerAdapter， 查找支持这个请求的HandlerAdapter</span></span><br><span class=\"line\">\t\t\tHandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// Process last-modified header, if supported by the handler.</span></span><br><span class=\"line\">\t\t\tString method = request.getMethod();</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">boolean</span> isGet = <span class=\"string\">\"GET\"</span>.equals(method);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (isGet || <span class=\"string\">\"HEAD\"</span>.equals(method)) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">long</span> lastModified = ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">\t\t\t\t\tlogger.debug(<span class=\"string\">\"Last-Modified value for [\"</span> + getRequestUri(request) + <span class=\"string\">\"] is: \"</span> + lastModified);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">new</span> ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">\t\t\t<span class=\"comment\">//拦截器的mappedHandler</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 调用实际编写的handler处理请求，也就是controller</span></span><br><span class=\"line\">\t\t\tmv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class=\"line\">            </span><br><span class=\"line\">            .....</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n<p>上图描述中的HandlerMethod和HandlerExecutionChain代码如下所示</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">*代码位置：HandlerMethod</span></span><br><span class=\"line\"><span class=\"comment\">**/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HandlerMethod</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> Log logger = LogFactory.getLog(<span class=\"keyword\">this</span>.getClass());</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Object bean;    <span class=\"comment\">//controller实例</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> BeanFactory beanFactory;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Class&lt;?&gt; beanType;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Method method;   <span class=\"comment\">//实际方法</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Method bridgedMethod;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> MethodParameter[] parameters;  <span class=\"comment\">//参数</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> HandlerMethod resolvedFromHandlerMethod;</span><br><span class=\"line\">    ...</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">*代码位置：HandlerExecutionChain</span></span><br><span class=\"line\"><span class=\"comment\">**/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HandlerExecutionChain</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Log logger = LogFactory.getLog(HandlerExecutionChain.class);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Object handler;   <span class=\"comment\">//handlerMethod实例</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> HandlerInterceptor[] interceptors;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> List&lt;HandlerInterceptor&gt; interceptorList;<span class=\"comment\">//拦截器实例</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> interceptorIndex = -<span class=\"number\">1</span>;</span><br><span class=\"line\">    ...</span><br></pre></td></tr></table></figure>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>首先，Spring框架在启动的时候IOC容器会遍历IOC容器中的所有bean，对标注了@Controller或@RequestMapping注解的类中方法进行遍历，将类和方法上的@RequestMapping注解中的value值进行合并，使用@RequestMapping注解的相关参数值(如value、method等)封装一个RequestMappingInfo，将这个Controller实例、方法及方法参数信息(类型、注解等)封装到HandlerMethod中，然后以RequestMappingInfo为key，HandlerMethod为value存到一个以Map为结构的handlerMethods中。</p>\n<p>接着，将@RequestMapping注解中的value(即请求路径)值取出，即url，然后以url为key，以RequestMappingInfo为value，存到一个以Map为结构的urlMap属性中。</p>\n<p>s客户端发起请求的时候，根据请求的URL到urlMap中查找，找到RequestMappingInfo，然后根据RequestMappingInfo到handlerMethods中查找，找到对应的HandlerMethod，接着将HandlerMethod封装到HandlerExecutionChain；接着遍历容器中所有HandlerAdapter实现类，找到支持这次请求的HandlerAdapter，如RequestMappingHandlerAdapter，然后执行SpringMVC拦截器的前置方法(preHandle方法)，然后对请求参数解析及转换，然后(使用反射)调用具体Controller的对应方法返回一个ModelAndView对象，执行拦截器的后置方法(postHandle方法)，然后对返回的结果进行处理，最后执行afterCompletion方法。</p>\n<blockquote>\n<p>参考：《Spring技术内幕》、《精通Spring 4.x 企业应用开发实战》 </p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h1><p>DispatcherServlet是SpringMVC的核心分发器，它实现了请求分发，是处理请求的入口，本篇将深入源码分析它的请求分发过程。</p>\n<p> 回顾DispatcherServlet 继承关系图：</p>\n<p><img style=\"width:90%;\" src=\"http://epoch-night.oss-cn-hangzhou.aliyuncs.com/PostImg/servlet.png\"></p>\n<p>Servlet在service方法中进行请求接收与分发，DispatcherServlet的service方法继承自HttpServlet，具体代码如下图所示。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">*代码位置：HttpServlet#service（）</span></span><br><span class=\"line\"><span class=\"comment\">**/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">service</span><span class=\"params\">(HttpServletRequest req, HttpServletResponse resp)</span></span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"keyword\">throws</span> ServletException, IOException</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//获取请求方式</span></span><br><span class=\"line\">    String method = req.getMethod();</span><br><span class=\"line\">\t<span class=\"comment\">//如果是get ，METHOD_GET 不同的请求方法会执行不同的代码，包括put,delete,post,trace.....</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (method.equals(METHOD_GET)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> lastModified = getLastModified(req);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (lastModified == -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// servlet doesn't support if-modified-since, no reason</span></span><br><span class=\"line\">            <span class=\"comment\">// to go through further expensive logic</span></span><br><span class=\"line\">            doGet(req, resp);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">long</span> ifModifiedSince = req.getDateHeader(HEADER_IFMODSINCE);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ifModifiedSince &lt; lastModified) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// If the servlet mod time is later, call doGet()</span></span><br><span class=\"line\">                <span class=\"comment\">// Round down to the nearest second for a proper compare</span></span><br><span class=\"line\">                <span class=\"comment\">// A ifModifiedSince of -1 will always be less</span></span><br><span class=\"line\">                maybeSetLastModified(resp, lastModified);</span><br><span class=\"line\">                doGet(req, resp);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (method.equals(METHOD_HEAD)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> lastModified = getLastModified(req);</span><br><span class=\"line\">        maybeSetLastModified(resp, lastModified);</span><br><span class=\"line\">        doHead(req, resp);</span><br><span class=\"line\"></span><br><span class=\"line\">   &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (method.equals(METHOD_POST)) &#123;</span><br><span class=\"line\">        doPost(req, resp);</span><br><span class=\"line\">            </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (method.equals(METHOD_PUT)) &#123;</span><br><span class=\"line\">        doPut(req, resp);</span><br><span class=\"line\">            </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (method.equals(METHOD_DELETE)) &#123;</span><br><span class=\"line\">        doDelete(req, resp);</span><br><span class=\"line\">            </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (method.equals(METHOD_OPTIONS)) &#123;</span><br><span class=\"line\">        doOptions(req,resp);</span><br><span class=\"line\">            </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (method.equals(METHOD_TRACE)) &#123;</span><br><span class=\"line\">        doTrace(req,resp);</span><br><span class=\"line\">           </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//</span></span><br><span class=\"line\">        <span class=\"comment\">// Note that this means NO servlet supports whatever</span></span><br><span class=\"line\">        <span class=\"comment\">// method was requested, anywhere on this server.</span></span><br><span class=\"line\">        <span class=\"comment\">//</span></span><br><span class=\"line\"></span><br><span class=\"line\">        String errMsg = lStrings.getString(<span class=\"string\">\"http.method_not_implemented\"</span>);</span><br><span class=\"line\">        Object[] errArgs = <span class=\"keyword\">new</span> Object[<span class=\"number\">1</span>];</span><br><span class=\"line\">        errArgs[<span class=\"number\">0</span>] = method;</span><br><span class=\"line\">        errMsg = MessageFormat.format(errMsg, errArgs);</span><br><span class=\"line\">            </span><br><span class=\"line\">        resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>在FrameworkServlet中对这个protected修饰的service方法进行了重写，重写的目的是支持PATCH方式请求，具体代码如下图所示。 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">代码位置：FrameworkServlet#service（）</span></span><br><span class=\"line\"><span class=\"comment\">**/</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">service</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class=\"line\"><span class=\"function\">\t\t\t<span class=\"keyword\">throws</span> ServletException, IOException </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tHttpMethod httpMethod = HttpMethod.resolve(request.getMethod());</span><br><span class=\"line\">    <span class=\"comment\">//支持PATCH方法</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (HttpMethod.PATCH == httpMethod || httpMethod == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\tprocessRequest(request, response);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//调用父类service方法</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">super</span>.service(request, response);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述分析中的doGet、doPost等方法在HttpServlet中没有实际可用的实现，如果要使用这些方法，子类需要重写这些方法，DispatcherServlet没有重写这些方法，在DispatcherServlet的父类FrameworkServlet中进行了重写，看几个重写后的方法代码。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">代码位置：FrameworkServlet#doGet（）</span></span><br><span class=\"line\"><span class=\"comment\">**/</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">doGet</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class=\"line\"><span class=\"function\">\t\t<span class=\"keyword\">throws</span> ServletException, IOException </span>&#123;</span><br><span class=\"line\">\tprocessRequest(request, response);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到这些请求都会进入当前FrameworkServlet类的processRequest方法进行处理，具体代码如下图所示。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">代码位置：FrameworkServlet#processRequest（）</span></span><br><span class=\"line\"><span class=\"comment\">**/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">processRequest</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class=\"line\"><span class=\"function\">\t\t\t<span class=\"keyword\">throws</span> ServletException, IOException </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">long</span> startTime = System.currentTimeMillis();</span><br><span class=\"line\">\tThrowable failureCause = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//构造LocaleContext和RequestAttributes 绑定到当前线程</span></span><br><span class=\"line\">\tLocaleContext previousLocaleContext = LocaleContextHolder.getLocaleContext();</span><br><span class=\"line\">\tLocaleContext localeContext = buildLocaleContext(request);</span><br><span class=\"line\"></span><br><span class=\"line\">\tRequestAttributes previousAttributes = RequestContextHolder.getRequestAttributes();</span><br><span class=\"line\">\tServletRequestAttributes requestAttributes = buildRequestAttributes(request, response, previousAttributes);</span><br><span class=\"line\"></span><br><span class=\"line\">\tWebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class=\"line\">\tasyncManager.registerCallableInterceptor(FrameworkServlet.class.getName(), <span class=\"keyword\">new</span> RequestBindingInterceptor());</span><br><span class=\"line\"></span><br><span class=\"line\">\tinitContextHolders(request, localeContext, requestAttributes);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//抽象方法 子类实现</span></span><br><span class=\"line\">\t\tdoService(request, response);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">catch</span> (ServletException ex) &#123;</span><br><span class=\"line\">\t\tfailureCause = ex;</span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> ex;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">catch</span> (IOException ex) &#123;</span><br><span class=\"line\">\t\tfailureCause = ex;</span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> ex;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">catch</span> (Throwable ex) &#123;</span><br><span class=\"line\">\t\tfailureCause = ex;</span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NestedServletException(<span class=\"string\">\"Request processing failed\"</span>, ex);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">\t\tresetContextHolders(request, previousLocaleContext, previousAttributes);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (requestAttributes != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\trequestAttributes.requestCompleted();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (failureCause != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">this</span>.logger.debug(<span class=\"string\">\"Could not complete request\"</span>, failureCause);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class=\"line\">\t\t\t\t\tlogger.debug(<span class=\"string\">\"Leaving response open for concurrent processing\"</span>);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">this</span>.logger.debug(<span class=\"string\">\"Successfully completed request\"</span>);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tpublishRequestHandledEvent(request, response, startTime, failureCause);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>FrameworkServlet中的doService是一个抽象方法，DispatcherServlet重写了这个方法，具体代码如下图。 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">代码位置：DispatcherServlet#doService（）</span></span><br><span class=\"line\"><span class=\"comment\">**/</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">doService</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">\t\tString resumed = WebAsyncUtils.getAsyncManager(request).hasConcurrentResult() ? <span class=\"string\">\" resumed\"</span> : <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">\t\tlogger.debug(<span class=\"string\">\"DispatcherServlet with name '\"</span> + getServletName() + <span class=\"string\">\"'\"</span> + resumed +</span><br><span class=\"line\">\t\t\t\t\t<span class=\"string\">\" processing \"</span> + request.getMethod() + <span class=\"string\">\" request for [\"</span> + getRequestUri(request) + <span class=\"string\">\"]\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Keep a snapshot of the request attributes in case of an include,</span></span><br><span class=\"line\">\t<span class=\"comment\">// to be able to restore the original attributes after the include.</span></span><br><span class=\"line\">    <span class=\"comment\">//对include请求保存一份快照，等会保存到request 属性中</span></span><br><span class=\"line\">\tMap&lt;String, Object&gt; attributesSnapshot = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (WebUtils.isIncludeRequest(request)) &#123;</span><br><span class=\"line\">\t\tattributesSnapshot = <span class=\"keyword\">new</span> HashMap&lt;String, Object&gt;();</span><br><span class=\"line\">\t\tEnumeration&lt;?&gt; attrNames = request.getAttributeNames();</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (attrNames.hasMoreElements()) &#123;</span><br><span class=\"line\">\t\t\tString attrName = (String) attrNames.nextElement();</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.cleanupAfterInclude || attrName.startsWith(<span class=\"string\">\"org.springframework.web.servlet\"</span>)) &#123;</span><br><span class=\"line\">\t\t\t\tattributesSnapshot.put(attrName, request.getAttribute(attrName));</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Make framework objects available to handlers and view objects.</span></span><br><span class=\"line\">\trequest.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext());</span><br><span class=\"line\">\trequest.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, <span class=\"keyword\">this</span>.localeResolver);</span><br><span class=\"line\">\trequest.setAttribute(THEME_RESOLVER_ATTRIBUTE, <span class=\"keyword\">this</span>.themeResolver);</span><br><span class=\"line\">\trequest.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());</span><br><span class=\"line\"></span><br><span class=\"line\">\tFlashMap inputFlashMap = <span class=\"keyword\">this</span>.flashMapManager.retrieveAndUpdate(request, response);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (inputFlashMap != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\trequest.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\trequest.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, <span class=\"keyword\">new</span> FlashMap());</span><br><span class=\"line\">\trequest.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, <span class=\"keyword\">this</span>.flashMapManager);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 分发请求到具体的handle</span></span><br><span class=\"line\">\t\tdoDispatch(request, response);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// Restore the original attribute snapshot, in case of an include.</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (attributesSnapshot != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t\trestoreAttributesAfterInclude(request, attributesSnapshot);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>进入doDispatch方法，这个方法实现了将请求分发到具体Handler、执行拦截器的preHandle方法、调用Handler（编写的Controller）处理具体逻辑、执行拦截器的postHandle方法、处理返回的ModelAndView或异常、执行拦截器的afterCompletion方法，具体代码如下。/<strong> 代码位置：DispatcherServlet#doService（） </strong>/</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">doDispatch</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">\tHttpServletRequest processedRequest = request;</span><br><span class=\"line\">\tHandlerExecutionChain mappedHandler = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">boolean</span> multipartRequestParsed = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tWebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\tModelAndView mv = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\tException dispatchException = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\tprocessedRequest = checkMultipart(request);</span><br><span class=\"line\">\t\t\tmultipartRequestParsed = (processedRequest != request);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 根据实际请求的url查找具体的handle，这些handle被封装在HandlerMethod中，</span></span><br><span class=\"line\">            <span class=\"comment\">//这个HandlerMethod又封装在HandlerExecutionChin中</span></span><br><span class=\"line\">\t\t\tmappedHandler = getHandler(processedRequest);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (mappedHandler == <span class=\"keyword\">null</span> || mappedHandler.getHandler() == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t\tnoHandlerFound(processedRequest, response);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 便利HandlerAdapter， 查找支持这个请求的HandlerAdapter</span></span><br><span class=\"line\">\t\t\tHandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// Process last-modified header, if supported by the handler.</span></span><br><span class=\"line\">\t\t\tString method = request.getMethod();</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">boolean</span> isGet = <span class=\"string\">\"GET\"</span>.equals(method);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (isGet || <span class=\"string\">\"HEAD\"</span>.equals(method)) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">long</span> lastModified = ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">\t\t\t\t\tlogger.debug(<span class=\"string\">\"Last-Modified value for [\"</span> + getRequestUri(request) + <span class=\"string\">\"] is: \"</span> + lastModified);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">new</span> ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">\t\t\t<span class=\"comment\">//拦截器的mappedHandler</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 调用实际编写的handler处理请求，也就是controller</span></span><br><span class=\"line\">\t\t\tmv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class=\"line\">            </span><br><span class=\"line\">            .....</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n<p>上图描述中的HandlerMethod和HandlerExecutionChain代码如下所示</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">*代码位置：HandlerMethod</span></span><br><span class=\"line\"><span class=\"comment\">**/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HandlerMethod</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> Log logger = LogFactory.getLog(<span class=\"keyword\">this</span>.getClass());</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Object bean;    <span class=\"comment\">//controller实例</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> BeanFactory beanFactory;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Class&lt;?&gt; beanType;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Method method;   <span class=\"comment\">//实际方法</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Method bridgedMethod;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> MethodParameter[] parameters;  <span class=\"comment\">//参数</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> HandlerMethod resolvedFromHandlerMethod;</span><br><span class=\"line\">    ...</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">*代码位置：HandlerExecutionChain</span></span><br><span class=\"line\"><span class=\"comment\">**/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HandlerExecutionChain</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Log logger = LogFactory.getLog(HandlerExecutionChain.class);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Object handler;   <span class=\"comment\">//handlerMethod实例</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> HandlerInterceptor[] interceptors;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> List&lt;HandlerInterceptor&gt; interceptorList;<span class=\"comment\">//拦截器实例</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> interceptorIndex = -<span class=\"number\">1</span>;</span><br><span class=\"line\">    ...</span><br></pre></td></tr></table></figure>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>首先，Spring框架在启动的时候IOC容器会遍历IOC容器中的所有bean，对标注了@Controller或@RequestMapping注解的类中方法进行遍历，将类和方法上的@RequestMapping注解中的value值进行合并，使用@RequestMapping注解的相关参数值(如value、method等)封装一个RequestMappingInfo，将这个Controller实例、方法及方法参数信息(类型、注解等)封装到HandlerMethod中，然后以RequestMappingInfo为key，HandlerMethod为value存到一个以Map为结构的handlerMethods中。</p>\n<p>接着，将@RequestMapping注解中的value(即请求路径)值取出，即url，然后以url为key，以RequestMappingInfo为value，存到一个以Map为结构的urlMap属性中。</p>\n<p>s客户端发起请求的时候，根据请求的URL到urlMap中查找，找到RequestMappingInfo，然后根据RequestMappingInfo到handlerMethods中查找，找到对应的HandlerMethod，接着将HandlerMethod封装到HandlerExecutionChain；接着遍历容器中所有HandlerAdapter实现类，找到支持这次请求的HandlerAdapter，如RequestMappingHandlerAdapter，然后执行SpringMVC拦截器的前置方法(preHandle方法)，然后对请求参数解析及转换，然后(使用反射)调用具体Controller的对应方法返回一个ModelAndView对象，执行拦截器的后置方法(postHandle方法)，然后对返回的结果进行处理，最后执行afterCompletion方法。</p>\n<blockquote>\n<p>参考：《Spring技术内幕》、《精通Spring 4.x 企业应用开发实战》 </p>\n</blockquote>\n"},{"layout":"post","title":"Spring | 容器启动梳理","date":"2017-11-27T14:42:00.000Z","author":"Gubaidan","header-img":"/Header/l8Qo5NqYG_k.png","cdn":"header-on","_content":"\n# 说明\n\n我们有时候是用下面这种手动的方式启动Spring 容器：\n\n```java\nApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"application-Context.xml\")；\n```\n\n除了这种方式，当然还有常见的配置文件启动，在web应用中，配置文件都是自动加载的，上述代码中的方式就不能满足需求了。在web应用中使用Spring，需要在web.xml中添加如下配置。\n\n```xml\n<listener>\n       <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>\n</listener>\n<context-param>\n     <param-name>contextConfigLocation</param-name>\n     <param-value>classpath:application-Context.xml;</param-value>\n</context-param>\n```\n\n##  ServletContext和ServletContextListene\n\nServletContext定义了一些方法方便Servlet和Servlet容器进行通讯，在一个web应用中所有的Servlet都公用一个ServletContext，Spring在和web应用结合使用的时候，是将Spring的容器存到ServletContext中的，通俗的说就是将一个ApplicationContext存储到ServletContext的一个Map属性中；而ServletContextListener用于监听ServletContext一些事件。分析就从ContextLoaderListener开始。在web应用启动读取web.xml时，发现配置了ContextLoaderListener，而ContextLoaderListener实现了ServletContextListener接口，因此会执行ContextLoaderListener类中的contextInitialized方法，方法的具体代码如下。\n\n```java\n/**\n* 代码位置：ServletContextListener\n*/\npublic interface ServletContextListener extends EventListener {\n\n    /**\n     * 接收Web应用程序初始化过程中的通知。\n     * 在初始化Web应用程序中的任何过滤器或servlet之前，\n     * 将通知所有ServletContextListener上下文初始化。\n     */\n    public void contextInitialized(ServletContextEvent sce);\n\n    /**\n     * 接收 ServletContext 关闭的事件信息。\n     */\n    public void contextDestroyed(ServletContextEvent sce);\n}\n```\n\n\n\n```java\n/**\n* 代码位置：ContextLoaderListener#contextInitialized()\n*/\npublic void contextInitialized(ServletContextEvent event) {\n        initWebApplicationContext(event.getServletContext());\n}\n```\n\n\n\n## initWebApplicationContext\n\n<span id=\"initWebApplicationContext\"></span>\n\n继续进入initWebApplicationContext方法，这个方法在其父类ContextLoader实现，根据方法名可以看出这个方法是用于初始化一个WebApplicationContext，简单理解就是初始化一个Web应用下的Spring容器。方法的具体代码如下。\n\n```java\n/**\n* 代码位置：ContextLoader#initWebApplicationContext()\n*/\npublic WebApplicationContext initWebApplicationContext(ServletContext servletContext) {\n\tif (servletContext.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE) != null) {\n\t\tthrow new IllegalStateException(\n\t\t\t\t\t\"Cannot initialize context because there is already a root application context present - \" +\n\t\t\t\t\t\"check whether you have multiple ContextLoader* definitions in your web.xml!\");\n\t}\n\n\tLog logger = LogFactory.getLog(ContextLoader.class);\n\tservletContext.log(\"Initializing Spring root WebApplicationContext\");\n\tif (logger.isInfoEnabled()) {\n\t\tlogger.info(\"Root WebApplicationContext: initialization started\");\n\t}\n\tlong startTime = System.currentTimeMillis();\n\n\ttry {\n\t\t// 将context存储在本地实例变量中，以保证它在ServletContext关闭时可用。\n\t\tif (this.context == null) {\n\t\t\tthis.context = createWebApplicationContext(servletContext);\n\t\t}\n\t\tif (this.context instanceof ConfigurableWebApplicationContext) {\n\t\t\tConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) this.context;\n\t\t\tif (!cwac.isActive()) {\n\t\t\t\t// 如果容器还未刷新 -> 则设置父容器\n\t\t\t\tif (cwac.getParent() == null) {\n\t\t\t\t\t// 如果context没有显示的设置父容器 ->\n                    //如果存在root-webapplication就把它设置为父容器\n\t\t\t\t\tApplicationContext parent = loadParentContext(servletContext);\n\t\t\t\t\tcwac.setParent(parent);\n\t\t\t\t}\n\t\t\t\tconfigureAndRefreshWebApplicationContext(cwac, servletContext);\n\t\t\t}\n\t\t}\n\t\t\tservletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, this.context);\n\t\n\t\tClassLoader ccl = Thread.currentThread().getContextClassLoader();\n\t\tif (ccl == ContextLoader.class.getClassLoader()) {\n\t\t\tcurrentContext = this.context;\n\t\t}\n\t\telse if (ccl != null) {\n\t\t\tcurrentContextPerThread.put(ccl, this.context);\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Published root WebApplicationContext as ServletContext attribute with name [\" +\n\t\t\t\t\tWebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE + \"]\");\n\t\t}\n\t\tif (logger.isInfoEnabled()) {\n\t\t\tlong elapsedTime = System.currentTimeMillis() - startTime;\n\t\t\tlogger.info(\"Root WebApplicationContext: initialization completed in \" + elapsedTime + \" ms\");\n\t\t}\n\n\t\treturn this.context;\n\t}\n\tcatch (RuntimeException ex) {\n\t\tlogger.error(\"Context initialization failed\", ex);\n\t\t\tservletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, ex);\n\t\tthrow ex;\n\t}\n\tcatch (Error err) {\n\t\tlogger.error(\"Context initialization failed\", err);\n\t\t\tservletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, err);\n\t\tthrow err;\n\t}\n}\n```\n\n方法的第一行就是检查servletContext是否已经存储了一个默认名称的WebApplicationContext，因为在一个应用中Spring容器只能有一个，所以需要校验，至于这个默认的名称为什么是**WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE**，看到后面就会慢慢明白。直接关注重点代码，代码如下。\n\n```java\n/**\n* 代码位置：ContextLoader#initWebApplicationContext()\n*/\nif (this.context == null) {\n    //这里的context是ContextLoader的一个变量，声明代码如下。\n\tthis.context = createWebApplicationContext(servletContext);\n}\n```\n\n```java\n/**\n* 代码位置：ContextLoader私有属性\n*/\nprivate WebApplicationContext context; \n```\n\n\n\n## createWebApplicationContext\n\n继续进入createWebApplicationContext方法，具体代码如下。\n\n```java\n/**\n* 代码位置：ContextLoader#createWebApplicationContext()\n*/\nprotected WebApplicationContext createWebApplicationContext(ServletContext sc) {\n   Class<?> contextClass = determineContextClass(sc);\n   if (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) {\n      throw new ApplicationContextException(\"Custom context class [\" + contextClass.getName() +\n            \"] is not of type [\" + ConfigurableWebApplicationContext.class.getName() + \"]\");\n   }\n   return (ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass);\n}\n```\n\n这个方法主要用于创建一个WebApplicationContext对象。因为WebApplicationContext只是一个接口，不能创建对象，所以需要找到一个WebApplicationContext接口的实现类，determineContextClass方法就是用于寻找实现类，如果开发人员在web.xml中配置了一个参数名为contextClass，值为WebApplicationContext接口实现类，那就会返回这个配置的实现类Class；如果没有配置，则会返回Spring默认的实现类XmlWebApplicationContext。直接进入determineContextClass方法体，代码如下。\n\n## determineContextClass\n\n```java\n/**\n* 代码位置：ContextLoader#determineContextClass()\n*/\nprotected Class<?> determineContextClass(ServletContext servletContext) {\n\tString contextClassName = servletContext.getInitParameter(CONTEXT_CLASS_PARAM);\n\tif (contextClassName != null) {\n\t\ttry {\n\t\t\t\treturn ClassUtils.forName(contextClassName, ClassUtils.getDefaultClassLoader());\n\t\t\t}\n\t\tcatch (ClassNotFoundException ex) {\n\t\t\t\tthrow new ApplicationContextException(\n\t\t\t\t\t\t\"Failed to load custom context class [\" + contextClassName + \"]\", ex);\n\t\t}\n\t}\n\telse {\n\t\tcontextClassName = defaultStrategies.getProperty(WebApplicationContext.class.getName());\n\t\ttry {\n\t\t\t\treturn ClassUtils.forName(contextClassName, ContextLoader.class.getClassLoader());\n\t\t\t}\n\t\tcatch (ClassNotFoundException ex) {\n\t\t\t\tthrow new ApplicationContextException(\n\t\t\t\t\t\t\"Failed to load default context class [\" + contextClassName + \"]\", ex);\n\t\t}\n\t}\n}\n```\n\n上面的代码中使用了defaultStrategies，用于获取Spring默认的WebApplicationContext接口实现类XmlWebApplicationContext.java，它的声明如下。\n\n```java\n/**\n* 代码位置：ContextLoader#私有属性和静态代码块\n*/\nprivate static final String DEFAULT_STRATEGIES_PATH = \"ContextLoader.properties\";\nprivate static final Properties defaultStrategies;\nstatic {\n       try {\n            ClassPathResource resource = new ClassPathResource(DEFAULT_STRATEGIES_PATH, ContextLoader.class);\n            defaultStrategies = PropertiesLoaderUtils.loadProperties(resource);\n        }catch (IOException ex) {\n            throw new IllegalStateException(\"Could not load 'ContextLoader.properties': \" + ex.getMessage());\n        }\n}\n```\n\n也就是说在ContextLoader.java的路径下，有一个ContextLoader.properties文件，查找并打开这个文件，文件内容如下。\n\n```java\norg.springframework.web.context.WebApplicationContext=org.springframework.web.context.support.XmlWebApplicationContext\n```\n\n这里配置了Spring默认的WebApplicationContext接口实现类XmlWebApplicationContext.java。回到createWebApplicationContext方法，WebApplicationContext接口实现类的Class已经找到，然后就是使用构造函数进行初始化完成WebApplicationContext对象创建。 \n继续回到 [>> initWebApplicationContext](#initWebApplicationContext) 方法，此时这个context就指向了刚刚创建的WebApplicationContext对象。因为XmlWebApplicationContext间接实现了ConfigurableWebApplicationContext接口，所以将会执行如下代码。\n\n```java\n/**\n* 代码位置：ContextLoader#initWebApplicationContext（）\n*/\nif (this.context instanceof ConfigurableWebApplicationContext) {\n\tConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) this.context;\n\tif (!cwac.isActive()) {\n\t\tif (cwac.getParent() == null) {\n\t\t\tApplicationContext parent = loadParentContext(servletContext);\n\t\t\t\tcwac.setParent(parent);\n\t\t}\n        configureAndRefreshWebApplicationContext(cwac, servletContext);\n\t}\n}\n```\n\n这里关注重点代码configureAndRefreshWebApplicationContext(cwac, servletContext)，configureAndRefreshWebApplicationContext方法具体代码如下。\n\n## configureAndRefreshWebApplicationContext\n\n```java\n/**\n* 代码位置：ContextLoader#configureAndRefreshWebApplicationContext（）\n*/\nprotected void configureAndRefreshWebApplicationContext(ConfigurableWebApplicationContext wac, ServletContext sc) {\n\tif (ObjectUtils.identityToString(wac).equals(wac.getId())) {\n        //如果应用程序上下文ID仍是其原始默认值则根据可用信息分配更有用的ID\n\t\tString idParam = sc.getInitParameter(CONTEXT_ID_PARAM);\n\t\tif (idParam != null) {\n\t\t\t wac.setId(idParam);\n\t\t}else {\n\t\t\twac.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX +\n                        ObjectUtils.getDisplayString(sc.getContextPath()));\n\t\t}\n\t}\n\twac.setServletContext(sc);\n\tString configLocationParam = sc.getInitParameter(CONFIG_LOCATION_PARAM);\n\tif (configLocationParam != null) {\n        wac.setConfigLocation(configLocationParam);\n    }\n    ConfigurableEnvironment env = wac.getEnvironment();\n    if (env instanceof ConfigurableWebEnvironment) {\n        ((ConfigurableWebEnvironment) env).initPropertySources(sc, null);\n    }\n    customizeContext(sc, wac);\n    wac.refresh();\n}\n```\n\n还是一样，关注重点代码。看一下CONFIG_LOCATION_PARAM这个常量的值是”contextConfigLocation”，OK，这个就是web.xml中配置applicationContext.xml的。这个参数如果没有配置，在XmlWebApplicationContext中是有默认值的，具体的值如下。\n\n```\npublic static final String DEFAULT_CONFIG_LOCATION = \"/WEB-INF/applicationContext.xml\";\n```\n\n也就是说，如果没有配置contextConfigLocation参数，将会使用/WEB-INF/applicationContext.xml。关注configureAndRefreshWebApplicationContext方法的最后一行代码wac.refresh()，是不是有点眼熟，继续跟踪代码，refresh方法的具体代码如下。\n\n```java\n/**\n* 代码位置：AbstractApplicationContext#refresh（）\n*/\npublic void refresh() throws BeansException, IllegalStateException {\n    synchronized (this.startupShutdownMonitor) {\n        prepareRefresh();\n        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();\n        prepareBeanFactory(beanFactory);\n        try {\n            postProcessBeanFactory(beanFactory);\n            invokeBeanFactoryPostProcessors(beanFactory);\n            registerBeanPostProcessors(beanFactory);\n            initMessageSource();\n            initApplicationEventMulticaster();\n            onRefresh();\n            registerListeners();\n            finishBeanFactoryInitialization(beanFactory);\n            finishRefresh();\n        }catch (BeansException ex) {\n            logger.warn(\"Exception encountered during context initialization - cancelling refresh attempt\", ex);\n            destroyBeans();\n            cancelRefresh(ex);\n            throw ex;\n        }\n    }\n}\n```\n\n这个refresh [《Spring | AbstractApplicationContext refresh()方法源码解析》](http://gubaidan.top/2017/11/06/2017-11-06-refresh/) 中的refresh方法，用于完成Bean的解析、实例化及注册。  继续分析，回到[>> initWebApplicationContext](#initWebApplicationContext) 方法，将执行如下代码。\n\n```java\nservletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, this.context);\n```\n\n可以看到，这里将初始化后的context存到了servletContext中，具体的就是存到了一个Map变量中，key值就是WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE这个常量。\n\n使用Spring的WebApplicationContextUtils工具类获取这个WebApplicationContext方式如下。\n\n```java\nWebApplicationContext applicationContext = WebApplicationContextUtils.getWebApplicationContext(request.getServletContext()); \n```\n\n\n\n>参考：《Spring技术内幕》、《精通Spring 4.x 企业应用开发实战》","source":"_posts/2017-11-27-web-launch.markdown","raw":"---\nlayout: post\ntitle: \"Spring | 容器启动梳理\"\ndate: 2017-11-27 22:42\nauthor: \"Gubaidan\"\nheader-img: \"/Header/l8Qo5NqYG_k.png\"\ncdn: 'header-on'\ntags:\n\t- Spring\n---\n\n# 说明\n\n我们有时候是用下面这种手动的方式启动Spring 容器：\n\n```java\nApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"application-Context.xml\")；\n```\n\n除了这种方式，当然还有常见的配置文件启动，在web应用中，配置文件都是自动加载的，上述代码中的方式就不能满足需求了。在web应用中使用Spring，需要在web.xml中添加如下配置。\n\n```xml\n<listener>\n       <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>\n</listener>\n<context-param>\n     <param-name>contextConfigLocation</param-name>\n     <param-value>classpath:application-Context.xml;</param-value>\n</context-param>\n```\n\n##  ServletContext和ServletContextListene\n\nServletContext定义了一些方法方便Servlet和Servlet容器进行通讯，在一个web应用中所有的Servlet都公用一个ServletContext，Spring在和web应用结合使用的时候，是将Spring的容器存到ServletContext中的，通俗的说就是将一个ApplicationContext存储到ServletContext的一个Map属性中；而ServletContextListener用于监听ServletContext一些事件。分析就从ContextLoaderListener开始。在web应用启动读取web.xml时，发现配置了ContextLoaderListener，而ContextLoaderListener实现了ServletContextListener接口，因此会执行ContextLoaderListener类中的contextInitialized方法，方法的具体代码如下。\n\n```java\n/**\n* 代码位置：ServletContextListener\n*/\npublic interface ServletContextListener extends EventListener {\n\n    /**\n     * 接收Web应用程序初始化过程中的通知。\n     * 在初始化Web应用程序中的任何过滤器或servlet之前，\n     * 将通知所有ServletContextListener上下文初始化。\n     */\n    public void contextInitialized(ServletContextEvent sce);\n\n    /**\n     * 接收 ServletContext 关闭的事件信息。\n     */\n    public void contextDestroyed(ServletContextEvent sce);\n}\n```\n\n\n\n```java\n/**\n* 代码位置：ContextLoaderListener#contextInitialized()\n*/\npublic void contextInitialized(ServletContextEvent event) {\n        initWebApplicationContext(event.getServletContext());\n}\n```\n\n\n\n## initWebApplicationContext\n\n<span id=\"initWebApplicationContext\"></span>\n\n继续进入initWebApplicationContext方法，这个方法在其父类ContextLoader实现，根据方法名可以看出这个方法是用于初始化一个WebApplicationContext，简单理解就是初始化一个Web应用下的Spring容器。方法的具体代码如下。\n\n```java\n/**\n* 代码位置：ContextLoader#initWebApplicationContext()\n*/\npublic WebApplicationContext initWebApplicationContext(ServletContext servletContext) {\n\tif (servletContext.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE) != null) {\n\t\tthrow new IllegalStateException(\n\t\t\t\t\t\"Cannot initialize context because there is already a root application context present - \" +\n\t\t\t\t\t\"check whether you have multiple ContextLoader* definitions in your web.xml!\");\n\t}\n\n\tLog logger = LogFactory.getLog(ContextLoader.class);\n\tservletContext.log(\"Initializing Spring root WebApplicationContext\");\n\tif (logger.isInfoEnabled()) {\n\t\tlogger.info(\"Root WebApplicationContext: initialization started\");\n\t}\n\tlong startTime = System.currentTimeMillis();\n\n\ttry {\n\t\t// 将context存储在本地实例变量中，以保证它在ServletContext关闭时可用。\n\t\tif (this.context == null) {\n\t\t\tthis.context = createWebApplicationContext(servletContext);\n\t\t}\n\t\tif (this.context instanceof ConfigurableWebApplicationContext) {\n\t\t\tConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) this.context;\n\t\t\tif (!cwac.isActive()) {\n\t\t\t\t// 如果容器还未刷新 -> 则设置父容器\n\t\t\t\tif (cwac.getParent() == null) {\n\t\t\t\t\t// 如果context没有显示的设置父容器 ->\n                    //如果存在root-webapplication就把它设置为父容器\n\t\t\t\t\tApplicationContext parent = loadParentContext(servletContext);\n\t\t\t\t\tcwac.setParent(parent);\n\t\t\t\t}\n\t\t\t\tconfigureAndRefreshWebApplicationContext(cwac, servletContext);\n\t\t\t}\n\t\t}\n\t\t\tservletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, this.context);\n\t\n\t\tClassLoader ccl = Thread.currentThread().getContextClassLoader();\n\t\tif (ccl == ContextLoader.class.getClassLoader()) {\n\t\t\tcurrentContext = this.context;\n\t\t}\n\t\telse if (ccl != null) {\n\t\t\tcurrentContextPerThread.put(ccl, this.context);\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Published root WebApplicationContext as ServletContext attribute with name [\" +\n\t\t\t\t\tWebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE + \"]\");\n\t\t}\n\t\tif (logger.isInfoEnabled()) {\n\t\t\tlong elapsedTime = System.currentTimeMillis() - startTime;\n\t\t\tlogger.info(\"Root WebApplicationContext: initialization completed in \" + elapsedTime + \" ms\");\n\t\t}\n\n\t\treturn this.context;\n\t}\n\tcatch (RuntimeException ex) {\n\t\tlogger.error(\"Context initialization failed\", ex);\n\t\t\tservletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, ex);\n\t\tthrow ex;\n\t}\n\tcatch (Error err) {\n\t\tlogger.error(\"Context initialization failed\", err);\n\t\t\tservletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, err);\n\t\tthrow err;\n\t}\n}\n```\n\n方法的第一行就是检查servletContext是否已经存储了一个默认名称的WebApplicationContext，因为在一个应用中Spring容器只能有一个，所以需要校验，至于这个默认的名称为什么是**WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE**，看到后面就会慢慢明白。直接关注重点代码，代码如下。\n\n```java\n/**\n* 代码位置：ContextLoader#initWebApplicationContext()\n*/\nif (this.context == null) {\n    //这里的context是ContextLoader的一个变量，声明代码如下。\n\tthis.context = createWebApplicationContext(servletContext);\n}\n```\n\n```java\n/**\n* 代码位置：ContextLoader私有属性\n*/\nprivate WebApplicationContext context; \n```\n\n\n\n## createWebApplicationContext\n\n继续进入createWebApplicationContext方法，具体代码如下。\n\n```java\n/**\n* 代码位置：ContextLoader#createWebApplicationContext()\n*/\nprotected WebApplicationContext createWebApplicationContext(ServletContext sc) {\n   Class<?> contextClass = determineContextClass(sc);\n   if (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) {\n      throw new ApplicationContextException(\"Custom context class [\" + contextClass.getName() +\n            \"] is not of type [\" + ConfigurableWebApplicationContext.class.getName() + \"]\");\n   }\n   return (ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass);\n}\n```\n\n这个方法主要用于创建一个WebApplicationContext对象。因为WebApplicationContext只是一个接口，不能创建对象，所以需要找到一个WebApplicationContext接口的实现类，determineContextClass方法就是用于寻找实现类，如果开发人员在web.xml中配置了一个参数名为contextClass，值为WebApplicationContext接口实现类，那就会返回这个配置的实现类Class；如果没有配置，则会返回Spring默认的实现类XmlWebApplicationContext。直接进入determineContextClass方法体，代码如下。\n\n## determineContextClass\n\n```java\n/**\n* 代码位置：ContextLoader#determineContextClass()\n*/\nprotected Class<?> determineContextClass(ServletContext servletContext) {\n\tString contextClassName = servletContext.getInitParameter(CONTEXT_CLASS_PARAM);\n\tif (contextClassName != null) {\n\t\ttry {\n\t\t\t\treturn ClassUtils.forName(contextClassName, ClassUtils.getDefaultClassLoader());\n\t\t\t}\n\t\tcatch (ClassNotFoundException ex) {\n\t\t\t\tthrow new ApplicationContextException(\n\t\t\t\t\t\t\"Failed to load custom context class [\" + contextClassName + \"]\", ex);\n\t\t}\n\t}\n\telse {\n\t\tcontextClassName = defaultStrategies.getProperty(WebApplicationContext.class.getName());\n\t\ttry {\n\t\t\t\treturn ClassUtils.forName(contextClassName, ContextLoader.class.getClassLoader());\n\t\t\t}\n\t\tcatch (ClassNotFoundException ex) {\n\t\t\t\tthrow new ApplicationContextException(\n\t\t\t\t\t\t\"Failed to load default context class [\" + contextClassName + \"]\", ex);\n\t\t}\n\t}\n}\n```\n\n上面的代码中使用了defaultStrategies，用于获取Spring默认的WebApplicationContext接口实现类XmlWebApplicationContext.java，它的声明如下。\n\n```java\n/**\n* 代码位置：ContextLoader#私有属性和静态代码块\n*/\nprivate static final String DEFAULT_STRATEGIES_PATH = \"ContextLoader.properties\";\nprivate static final Properties defaultStrategies;\nstatic {\n       try {\n            ClassPathResource resource = new ClassPathResource(DEFAULT_STRATEGIES_PATH, ContextLoader.class);\n            defaultStrategies = PropertiesLoaderUtils.loadProperties(resource);\n        }catch (IOException ex) {\n            throw new IllegalStateException(\"Could not load 'ContextLoader.properties': \" + ex.getMessage());\n        }\n}\n```\n\n也就是说在ContextLoader.java的路径下，有一个ContextLoader.properties文件，查找并打开这个文件，文件内容如下。\n\n```java\norg.springframework.web.context.WebApplicationContext=org.springframework.web.context.support.XmlWebApplicationContext\n```\n\n这里配置了Spring默认的WebApplicationContext接口实现类XmlWebApplicationContext.java。回到createWebApplicationContext方法，WebApplicationContext接口实现类的Class已经找到，然后就是使用构造函数进行初始化完成WebApplicationContext对象创建。 \n继续回到 [>> initWebApplicationContext](#initWebApplicationContext) 方法，此时这个context就指向了刚刚创建的WebApplicationContext对象。因为XmlWebApplicationContext间接实现了ConfigurableWebApplicationContext接口，所以将会执行如下代码。\n\n```java\n/**\n* 代码位置：ContextLoader#initWebApplicationContext（）\n*/\nif (this.context instanceof ConfigurableWebApplicationContext) {\n\tConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) this.context;\n\tif (!cwac.isActive()) {\n\t\tif (cwac.getParent() == null) {\n\t\t\tApplicationContext parent = loadParentContext(servletContext);\n\t\t\t\tcwac.setParent(parent);\n\t\t}\n        configureAndRefreshWebApplicationContext(cwac, servletContext);\n\t}\n}\n```\n\n这里关注重点代码configureAndRefreshWebApplicationContext(cwac, servletContext)，configureAndRefreshWebApplicationContext方法具体代码如下。\n\n## configureAndRefreshWebApplicationContext\n\n```java\n/**\n* 代码位置：ContextLoader#configureAndRefreshWebApplicationContext（）\n*/\nprotected void configureAndRefreshWebApplicationContext(ConfigurableWebApplicationContext wac, ServletContext sc) {\n\tif (ObjectUtils.identityToString(wac).equals(wac.getId())) {\n        //如果应用程序上下文ID仍是其原始默认值则根据可用信息分配更有用的ID\n\t\tString idParam = sc.getInitParameter(CONTEXT_ID_PARAM);\n\t\tif (idParam != null) {\n\t\t\t wac.setId(idParam);\n\t\t}else {\n\t\t\twac.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX +\n                        ObjectUtils.getDisplayString(sc.getContextPath()));\n\t\t}\n\t}\n\twac.setServletContext(sc);\n\tString configLocationParam = sc.getInitParameter(CONFIG_LOCATION_PARAM);\n\tif (configLocationParam != null) {\n        wac.setConfigLocation(configLocationParam);\n    }\n    ConfigurableEnvironment env = wac.getEnvironment();\n    if (env instanceof ConfigurableWebEnvironment) {\n        ((ConfigurableWebEnvironment) env).initPropertySources(sc, null);\n    }\n    customizeContext(sc, wac);\n    wac.refresh();\n}\n```\n\n还是一样，关注重点代码。看一下CONFIG_LOCATION_PARAM这个常量的值是”contextConfigLocation”，OK，这个就是web.xml中配置applicationContext.xml的。这个参数如果没有配置，在XmlWebApplicationContext中是有默认值的，具体的值如下。\n\n```\npublic static final String DEFAULT_CONFIG_LOCATION = \"/WEB-INF/applicationContext.xml\";\n```\n\n也就是说，如果没有配置contextConfigLocation参数，将会使用/WEB-INF/applicationContext.xml。关注configureAndRefreshWebApplicationContext方法的最后一行代码wac.refresh()，是不是有点眼熟，继续跟踪代码，refresh方法的具体代码如下。\n\n```java\n/**\n* 代码位置：AbstractApplicationContext#refresh（）\n*/\npublic void refresh() throws BeansException, IllegalStateException {\n    synchronized (this.startupShutdownMonitor) {\n        prepareRefresh();\n        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();\n        prepareBeanFactory(beanFactory);\n        try {\n            postProcessBeanFactory(beanFactory);\n            invokeBeanFactoryPostProcessors(beanFactory);\n            registerBeanPostProcessors(beanFactory);\n            initMessageSource();\n            initApplicationEventMulticaster();\n            onRefresh();\n            registerListeners();\n            finishBeanFactoryInitialization(beanFactory);\n            finishRefresh();\n        }catch (BeansException ex) {\n            logger.warn(\"Exception encountered during context initialization - cancelling refresh attempt\", ex);\n            destroyBeans();\n            cancelRefresh(ex);\n            throw ex;\n        }\n    }\n}\n```\n\n这个refresh [《Spring | AbstractApplicationContext refresh()方法源码解析》](http://gubaidan.top/2017/11/06/2017-11-06-refresh/) 中的refresh方法，用于完成Bean的解析、实例化及注册。  继续分析，回到[>> initWebApplicationContext](#initWebApplicationContext) 方法，将执行如下代码。\n\n```java\nservletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, this.context);\n```\n\n可以看到，这里将初始化后的context存到了servletContext中，具体的就是存到了一个Map变量中，key值就是WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE这个常量。\n\n使用Spring的WebApplicationContextUtils工具类获取这个WebApplicationContext方式如下。\n\n```java\nWebApplicationContext applicationContext = WebApplicationContextUtils.getWebApplicationContext(request.getServletContext()); \n```\n\n\n\n>参考：《Spring技术内幕》、《精通Spring 4.x 企业应用开发实战》","slug":"2017-11-27-web-launch","published":1,"updated":"2018-07-21T13:14:17.535Z","comments":1,"photos":[],"link":"","_id":"cjvayvwgc0022m46a0l8g8ipy","content":"<h1 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h1><p>我们有时候是用下面这种手动的方式启动Spring 容器：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">ApplicationContext applicationContext = <span class=\"keyword\">new</span> ClassPathXmlApplicationContext(<span class=\"string\">\"application-Context.xml\"</span>)；</span><br></pre></td></tr></table></figure>\n<p>除了这种方式，当然还有常见的配置文件启动，在web应用中，配置文件都是自动加载的，上述代码中的方式就不能满足需求了。在web应用中使用Spring，需要在web.xml中添加如下配置。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">listener</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class=\"tag\">&lt;/<span class=\"name\">listener-class</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">listener</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">context-param</span>&gt;</span></span><br><span class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>contextConfigLocation<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></span><br><span class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>classpath:application-Context.xml;<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"ServletContext和ServletContextListene\"><a href=\"#ServletContext和ServletContextListene\" class=\"headerlink\" title=\"ServletContext和ServletContextListene\"></a>ServletContext和ServletContextListene</h2><p>ServletContext定义了一些方法方便Servlet和Servlet容器进行通讯，在一个web应用中所有的Servlet都公用一个ServletContext，Spring在和web应用结合使用的时候，是将Spring的容器存到ServletContext中的，通俗的说就是将一个ApplicationContext存储到ServletContext的一个Map属性中；而ServletContextListener用于监听ServletContext一些事件。分析就从ContextLoaderListener开始。在web应用启动读取web.xml时，发现配置了ContextLoaderListener，而ContextLoaderListener实现了ServletContextListener接口，因此会执行ContextLoaderListener类中的contextInitialized方法，方法的具体代码如下。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 代码位置：ServletContextListener</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ServletContextListener</span> <span class=\"keyword\">extends</span> <span class=\"title\">EventListener</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 接收Web应用程序初始化过程中的通知。</span></span><br><span class=\"line\"><span class=\"comment\">     * 在初始化Web应用程序中的任何过滤器或servlet之前，</span></span><br><span class=\"line\"><span class=\"comment\">     * 将通知所有ServletContextListener上下文初始化。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">contextInitialized</span><span class=\"params\">(ServletContextEvent sce)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 接收 ServletContext 关闭的事件信息。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">contextDestroyed</span><span class=\"params\">(ServletContextEvent sce)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 代码位置：ContextLoaderListener#contextInitialized()</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">contextInitialized</span><span class=\"params\">(ServletContextEvent event)</span> </span>&#123;</span><br><span class=\"line\">        initWebApplicationContext(event.getServletContext());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"initWebApplicationContext\"><a href=\"#initWebApplicationContext\" class=\"headerlink\" title=\"initWebApplicationContext\"></a>initWebApplicationContext</h2><p><span id=\"initWebApplicationContext\"></span></p>\n<p>继续进入initWebApplicationContext方法，这个方法在其父类ContextLoader实现，根据方法名可以看出这个方法是用于初始化一个WebApplicationContext，简单理解就是初始化一个Web应用下的Spring容器。方法的具体代码如下。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 代码位置：ContextLoader#initWebApplicationContext()</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> WebApplicationContext <span class=\"title\">initWebApplicationContext</span><span class=\"params\">(ServletContext servletContext)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (servletContext.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(</span><br><span class=\"line\">\t\t\t\t\t<span class=\"string\">\"Cannot initialize context because there is already a root application context present - \"</span> +</span><br><span class=\"line\">\t\t\t\t\t<span class=\"string\">\"check whether you have multiple ContextLoader* definitions in your web.xml!\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tLog logger = LogFactory.getLog(ContextLoader.class);</span><br><span class=\"line\">\tservletContext.log(<span class=\"string\">\"Initializing Spring root WebApplicationContext\"</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class=\"line\">\t\tlogger.info(<span class=\"string\">\"Root WebApplicationContext: initialization started\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">long</span> startTime = System.currentTimeMillis();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 将context存储在本地实例变量中，以保证它在ServletContext关闭时可用。</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.context == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>.context = createWebApplicationContext(servletContext);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.context <span class=\"keyword\">instanceof</span> ConfigurableWebApplicationContext) &#123;</span><br><span class=\"line\">\t\t\tConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) <span class=\"keyword\">this</span>.context;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!cwac.isActive()) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 如果容器还未刷新 -&gt; 则设置父容器</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (cwac.getParent() == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 如果context没有显示的设置父容器 -&gt;</span></span><br><span class=\"line\">                    <span class=\"comment\">//如果存在root-webapplication就把它设置为父容器</span></span><br><span class=\"line\">\t\t\t\t\tApplicationContext parent = loadParentContext(servletContext);</span><br><span class=\"line\">\t\t\t\t\tcwac.setParent(parent);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tconfigureAndRefreshWebApplicationContext(cwac, servletContext);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t\tservletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, <span class=\"keyword\">this</span>.context);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t\tClassLoader ccl = Thread.currentThread().getContextClassLoader();</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (ccl == ContextLoader.class.getClassLoader()) &#123;</span><br><span class=\"line\">\t\t\tcurrentContext = <span class=\"keyword\">this</span>.context;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ccl != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\tcurrentContextPerThread.put(ccl, <span class=\"keyword\">this</span>.context);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">\t\t\tlogger.debug(<span class=\"string\">\"Published root WebApplicationContext as ServletContext attribute with name [\"</span> +</span><br><span class=\"line\">\t\t\t\t\tWebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE + <span class=\"string\">\"]\"</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">long</span> elapsedTime = System.currentTimeMillis() - startTime;</span><br><span class=\"line\">\t\t\tlogger.info(<span class=\"string\">\"Root WebApplicationContext: initialization completed in \"</span> + elapsedTime + <span class=\"string\">\" ms\"</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.context;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">catch</span> (RuntimeException ex) &#123;</span><br><span class=\"line\">\t\tlogger.error(<span class=\"string\">\"Context initialization failed\"</span>, ex);</span><br><span class=\"line\">\t\t\tservletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, ex);</span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> ex;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">catch</span> (Error err) &#123;</span><br><span class=\"line\">\t\tlogger.error(<span class=\"string\">\"Context initialization failed\"</span>, err);</span><br><span class=\"line\">\t\t\tservletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, err);</span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>方法的第一行就是检查servletContext是否已经存储了一个默认名称的WebApplicationContext，因为在一个应用中Spring容器只能有一个，所以需要校验，至于这个默认的名称为什么是<strong>WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE</strong>，看到后面就会慢慢明白。直接关注重点代码，代码如下。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 代码位置：ContextLoader#initWebApplicationContext()</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.context == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//这里的context是ContextLoader的一个变量，声明代码如下。</span></span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.context = createWebApplicationContext(servletContext);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 代码位置：ContextLoader私有属性</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> WebApplicationContext context;</span><br></pre></td></tr></table></figure>\n<h2 id=\"createWebApplicationContext\"><a href=\"#createWebApplicationContext\" class=\"headerlink\" title=\"createWebApplicationContext\"></a>createWebApplicationContext</h2><p>继续进入createWebApplicationContext方法，具体代码如下。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 代码位置：ContextLoader#createWebApplicationContext()</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> WebApplicationContext <span class=\"title\">createWebApplicationContext</span><span class=\"params\">(ServletContext sc)</span> </span>&#123;</span><br><span class=\"line\">   Class&lt;?&gt; contextClass = determineContextClass(sc);</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ApplicationContextException(<span class=\"string\">\"Custom context class [\"</span> + contextClass.getName() +</span><br><span class=\"line\">            <span class=\"string\">\"] is not of type [\"</span> + ConfigurableWebApplicationContext.class.getName() + <span class=\"string\">\"]\"</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> (ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个方法主要用于创建一个WebApplicationContext对象。因为WebApplicationContext只是一个接口，不能创建对象，所以需要找到一个WebApplicationContext接口的实现类，determineContextClass方法就是用于寻找实现类，如果开发人员在web.xml中配置了一个参数名为contextClass，值为WebApplicationContext接口实现类，那就会返回这个配置的实现类Class；如果没有配置，则会返回Spring默认的实现类XmlWebApplicationContext。直接进入determineContextClass方法体，代码如下。</p>\n<h2 id=\"determineContextClass\"><a href=\"#determineContextClass\" class=\"headerlink\" title=\"determineContextClass\"></a>determineContextClass</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 代码位置：ContextLoader#determineContextClass()</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> Class&lt;?&gt; determineContextClass(ServletContext servletContext) &#123;</span><br><span class=\"line\">\tString contextClassName = servletContext.getInitParameter(CONTEXT_CLASS_PARAM);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (contextClassName != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> ClassUtils.forName(contextClassName, ClassUtils.getDefaultClassLoader());</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ApplicationContextException(</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"string\">\"Failed to load custom context class [\"</span> + contextClassName + <span class=\"string\">\"]\"</span>, ex);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tcontextClassName = defaultStrategies.getProperty(WebApplicationContext.class.getName());</span><br><span class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> ClassUtils.forName(contextClassName, ContextLoader.class.getClassLoader());</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ApplicationContextException(</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"string\">\"Failed to load default context class [\"</span> + contextClassName + <span class=\"string\">\"]\"</span>, ex);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的代码中使用了defaultStrategies，用于获取Spring默认的WebApplicationContext接口实现类XmlWebApplicationContext.java，它的声明如下。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 代码位置：ContextLoader#私有属性和静态代码块</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String DEFAULT_STRATEGIES_PATH = <span class=\"string\">\"ContextLoader.properties\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Properties defaultStrategies;</span><br><span class=\"line\"><span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">       <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            ClassPathResource resource = <span class=\"keyword\">new</span> ClassPathResource(DEFAULT_STRATEGIES_PATH, ContextLoader.class);</span><br><span class=\"line\">            defaultStrategies = PropertiesLoaderUtils.loadProperties(resource);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">catch</span> (IOException ex) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Could not load 'ContextLoader.properties': \"</span> + ex.getMessage());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>也就是说在ContextLoader.java的路径下，有一个ContextLoader.properties文件，查找并打开这个文件，文件内容如下。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">org.springframework.web.context.WebApplicationContext=org.springframework.web.context.support.XmlWebApplicationContext</span><br></pre></td></tr></table></figure>\n<p>这里配置了Spring默认的WebApplicationContext接口实现类XmlWebApplicationContext.java。回到createWebApplicationContext方法，WebApplicationContext接口实现类的Class已经找到，然后就是使用构造函数进行初始化完成WebApplicationContext对象创建。<br>继续回到 <a href=\"#initWebApplicationContext\">&gt;&gt; initWebApplicationContext</a> 方法，此时这个context就指向了刚刚创建的WebApplicationContext对象。因为XmlWebApplicationContext间接实现了ConfigurableWebApplicationContext接口，所以将会执行如下代码。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 代码位置：ContextLoader#initWebApplicationContext（）</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.context <span class=\"keyword\">instanceof</span> ConfigurableWebApplicationContext) &#123;</span><br><span class=\"line\">\tConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) <span class=\"keyword\">this</span>.context;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!cwac.isActive()) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (cwac.getParent() == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\tApplicationContext parent = loadParentContext(servletContext);</span><br><span class=\"line\">\t\t\t\tcwac.setParent(parent);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">        configureAndRefreshWebApplicationContext(cwac, servletContext);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里关注重点代码configureAndRefreshWebApplicationContext(cwac, servletContext)，configureAndRefreshWebApplicationContext方法具体代码如下。</p>\n<h2 id=\"configureAndRefreshWebApplicationContext\"><a href=\"#configureAndRefreshWebApplicationContext\" class=\"headerlink\" title=\"configureAndRefreshWebApplicationContext\"></a>configureAndRefreshWebApplicationContext</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 代码位置：ContextLoader#configureAndRefreshWebApplicationContext（）</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">configureAndRefreshWebApplicationContext</span><span class=\"params\">(ConfigurableWebApplicationContext wac, ServletContext sc)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (ObjectUtils.identityToString(wac).equals(wac.getId())) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//如果应用程序上下文ID仍是其原始默认值则根据可用信息分配更有用的ID</span></span><br><span class=\"line\">\t\tString idParam = sc.getInitParameter(CONTEXT_ID_PARAM);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (idParam != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t wac.setId(idParam);</span><br><span class=\"line\">\t\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\twac.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX +</span><br><span class=\"line\">                        ObjectUtils.getDisplayString(sc.getContextPath()));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\twac.setServletContext(sc);</span><br><span class=\"line\">\tString configLocationParam = sc.getInitParameter(CONFIG_LOCATION_PARAM);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (configLocationParam != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        wac.setConfigLocation(configLocationParam);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ConfigurableEnvironment env = wac.getEnvironment();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (env <span class=\"keyword\">instanceof</span> ConfigurableWebEnvironment) &#123;</span><br><span class=\"line\">        ((ConfigurableWebEnvironment) env).initPropertySources(sc, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    customizeContext(sc, wac);</span><br><span class=\"line\">    wac.refresh();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>还是一样，关注重点代码。看一下CONFIG_LOCATION_PARAM这个常量的值是”contextConfigLocation”，OK，这个就是web.xml中配置applicationContext.xml的。这个参数如果没有配置，在XmlWebApplicationContext中是有默认值的，具体的值如下。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">public static final String DEFAULT_CONFIG_LOCATION = &quot;/WEB-INF/applicationContext.xml&quot;;</span><br></pre></td></tr></table></figure>\n<p>也就是说，如果没有配置contextConfigLocation参数，将会使用/WEB-INF/applicationContext.xml。关注configureAndRefreshWebApplicationContext方法的最后一行代码wac.refresh()，是不是有点眼熟，继续跟踪代码，refresh方法的具体代码如下。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 代码位置：AbstractApplicationContext#refresh（）</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">refresh</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>.startupShutdownMonitor) &#123;</span><br><span class=\"line\">        prepareRefresh();</span><br><span class=\"line\">        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class=\"line\">        prepareBeanFactory(beanFactory);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            postProcessBeanFactory(beanFactory);</span><br><span class=\"line\">            invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class=\"line\">            registerBeanPostProcessors(beanFactory);</span><br><span class=\"line\">            initMessageSource();</span><br><span class=\"line\">            initApplicationEventMulticaster();</span><br><span class=\"line\">            onRefresh();</span><br><span class=\"line\">            registerListeners();</span><br><span class=\"line\">            finishBeanFactoryInitialization(beanFactory);</span><br><span class=\"line\">            finishRefresh();</span><br><span class=\"line\">        &#125;<span class=\"keyword\">catch</span> (BeansException ex) &#123;</span><br><span class=\"line\">            logger.warn(<span class=\"string\">\"Exception encountered during context initialization - cancelling refresh attempt\"</span>, ex);</span><br><span class=\"line\">            destroyBeans();</span><br><span class=\"line\">            cancelRefresh(ex);</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> ex;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个refresh <a href=\"http://gubaidan.top/2017/11/06/2017-11-06-refresh/\" target=\"_blank\" rel=\"noopener\">《Spring | AbstractApplicationContext refresh()方法源码解析》</a> 中的refresh方法，用于完成Bean的解析、实例化及注册。  继续分析，回到<a href=\"#initWebApplicationContext\">&gt;&gt; initWebApplicationContext</a> 方法，将执行如下代码。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, <span class=\"keyword\">this</span>.context);</span><br></pre></td></tr></table></figure>\n<p>可以看到，这里将初始化后的context存到了servletContext中，具体的就是存到了一个Map变量中，key值就是WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE这个常量。</p>\n<p>使用Spring的WebApplicationContextUtils工具类获取这个WebApplicationContext方式如下。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">WebApplicationContext applicationContext = WebApplicationContextUtils.getWebApplicationContext(request.getServletContext());</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>参考：《Spring技术内幕》、《精通Spring 4.x 企业应用开发实战》</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h1><p>我们有时候是用下面这种手动的方式启动Spring 容器：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">ApplicationContext applicationContext = <span class=\"keyword\">new</span> ClassPathXmlApplicationContext(<span class=\"string\">\"application-Context.xml\"</span>)；</span><br></pre></td></tr></table></figure>\n<p>除了这种方式，当然还有常见的配置文件启动，在web应用中，配置文件都是自动加载的，上述代码中的方式就不能满足需求了。在web应用中使用Spring，需要在web.xml中添加如下配置。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">listener</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class=\"tag\">&lt;/<span class=\"name\">listener-class</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">listener</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">context-param</span>&gt;</span></span><br><span class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>contextConfigLocation<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></span><br><span class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>classpath:application-Context.xml;<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"ServletContext和ServletContextListene\"><a href=\"#ServletContext和ServletContextListene\" class=\"headerlink\" title=\"ServletContext和ServletContextListene\"></a>ServletContext和ServletContextListene</h2><p>ServletContext定义了一些方法方便Servlet和Servlet容器进行通讯，在一个web应用中所有的Servlet都公用一个ServletContext，Spring在和web应用结合使用的时候，是将Spring的容器存到ServletContext中的，通俗的说就是将一个ApplicationContext存储到ServletContext的一个Map属性中；而ServletContextListener用于监听ServletContext一些事件。分析就从ContextLoaderListener开始。在web应用启动读取web.xml时，发现配置了ContextLoaderListener，而ContextLoaderListener实现了ServletContextListener接口，因此会执行ContextLoaderListener类中的contextInitialized方法，方法的具体代码如下。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 代码位置：ServletContextListener</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ServletContextListener</span> <span class=\"keyword\">extends</span> <span class=\"title\">EventListener</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 接收Web应用程序初始化过程中的通知。</span></span><br><span class=\"line\"><span class=\"comment\">     * 在初始化Web应用程序中的任何过滤器或servlet之前，</span></span><br><span class=\"line\"><span class=\"comment\">     * 将通知所有ServletContextListener上下文初始化。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">contextInitialized</span><span class=\"params\">(ServletContextEvent sce)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 接收 ServletContext 关闭的事件信息。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">contextDestroyed</span><span class=\"params\">(ServletContextEvent sce)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 代码位置：ContextLoaderListener#contextInitialized()</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">contextInitialized</span><span class=\"params\">(ServletContextEvent event)</span> </span>&#123;</span><br><span class=\"line\">        initWebApplicationContext(event.getServletContext());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"initWebApplicationContext\"><a href=\"#initWebApplicationContext\" class=\"headerlink\" title=\"initWebApplicationContext\"></a>initWebApplicationContext</h2><p><span id=\"initWebApplicationContext\"></span></p>\n<p>继续进入initWebApplicationContext方法，这个方法在其父类ContextLoader实现，根据方法名可以看出这个方法是用于初始化一个WebApplicationContext，简单理解就是初始化一个Web应用下的Spring容器。方法的具体代码如下。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 代码位置：ContextLoader#initWebApplicationContext()</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> WebApplicationContext <span class=\"title\">initWebApplicationContext</span><span class=\"params\">(ServletContext servletContext)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (servletContext.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(</span><br><span class=\"line\">\t\t\t\t\t<span class=\"string\">\"Cannot initialize context because there is already a root application context present - \"</span> +</span><br><span class=\"line\">\t\t\t\t\t<span class=\"string\">\"check whether you have multiple ContextLoader* definitions in your web.xml!\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tLog logger = LogFactory.getLog(ContextLoader.class);</span><br><span class=\"line\">\tservletContext.log(<span class=\"string\">\"Initializing Spring root WebApplicationContext\"</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class=\"line\">\t\tlogger.info(<span class=\"string\">\"Root WebApplicationContext: initialization started\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">long</span> startTime = System.currentTimeMillis();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 将context存储在本地实例变量中，以保证它在ServletContext关闭时可用。</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.context == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>.context = createWebApplicationContext(servletContext);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.context <span class=\"keyword\">instanceof</span> ConfigurableWebApplicationContext) &#123;</span><br><span class=\"line\">\t\t\tConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) <span class=\"keyword\">this</span>.context;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!cwac.isActive()) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">// 如果容器还未刷新 -&gt; 则设置父容器</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (cwac.getParent() == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">// 如果context没有显示的设置父容器 -&gt;</span></span><br><span class=\"line\">                    <span class=\"comment\">//如果存在root-webapplication就把它设置为父容器</span></span><br><span class=\"line\">\t\t\t\t\tApplicationContext parent = loadParentContext(servletContext);</span><br><span class=\"line\">\t\t\t\t\tcwac.setParent(parent);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tconfigureAndRefreshWebApplicationContext(cwac, servletContext);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t\tservletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, <span class=\"keyword\">this</span>.context);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t\tClassLoader ccl = Thread.currentThread().getContextClassLoader();</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (ccl == ContextLoader.class.getClassLoader()) &#123;</span><br><span class=\"line\">\t\t\tcurrentContext = <span class=\"keyword\">this</span>.context;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ccl != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\tcurrentContextPerThread.put(ccl, <span class=\"keyword\">this</span>.context);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class=\"line\">\t\t\tlogger.debug(<span class=\"string\">\"Published root WebApplicationContext as ServletContext attribute with name [\"</span> +</span><br><span class=\"line\">\t\t\t\t\tWebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE + <span class=\"string\">\"]\"</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">long</span> elapsedTime = System.currentTimeMillis() - startTime;</span><br><span class=\"line\">\t\t\tlogger.info(<span class=\"string\">\"Root WebApplicationContext: initialization completed in \"</span> + elapsedTime + <span class=\"string\">\" ms\"</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.context;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">catch</span> (RuntimeException ex) &#123;</span><br><span class=\"line\">\t\tlogger.error(<span class=\"string\">\"Context initialization failed\"</span>, ex);</span><br><span class=\"line\">\t\t\tservletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, ex);</span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> ex;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">catch</span> (Error err) &#123;</span><br><span class=\"line\">\t\tlogger.error(<span class=\"string\">\"Context initialization failed\"</span>, err);</span><br><span class=\"line\">\t\t\tservletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, err);</span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>方法的第一行就是检查servletContext是否已经存储了一个默认名称的WebApplicationContext，因为在一个应用中Spring容器只能有一个，所以需要校验，至于这个默认的名称为什么是<strong>WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE</strong>，看到后面就会慢慢明白。直接关注重点代码，代码如下。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 代码位置：ContextLoader#initWebApplicationContext()</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.context == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//这里的context是ContextLoader的一个变量，声明代码如下。</span></span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.context = createWebApplicationContext(servletContext);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 代码位置：ContextLoader私有属性</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> WebApplicationContext context;</span><br></pre></td></tr></table></figure>\n<h2 id=\"createWebApplicationContext\"><a href=\"#createWebApplicationContext\" class=\"headerlink\" title=\"createWebApplicationContext\"></a>createWebApplicationContext</h2><p>继续进入createWebApplicationContext方法，具体代码如下。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 代码位置：ContextLoader#createWebApplicationContext()</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> WebApplicationContext <span class=\"title\">createWebApplicationContext</span><span class=\"params\">(ServletContext sc)</span> </span>&#123;</span><br><span class=\"line\">   Class&lt;?&gt; contextClass = determineContextClass(sc);</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ApplicationContextException(<span class=\"string\">\"Custom context class [\"</span> + contextClass.getName() +</span><br><span class=\"line\">            <span class=\"string\">\"] is not of type [\"</span> + ConfigurableWebApplicationContext.class.getName() + <span class=\"string\">\"]\"</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> (ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个方法主要用于创建一个WebApplicationContext对象。因为WebApplicationContext只是一个接口，不能创建对象，所以需要找到一个WebApplicationContext接口的实现类，determineContextClass方法就是用于寻找实现类，如果开发人员在web.xml中配置了一个参数名为contextClass，值为WebApplicationContext接口实现类，那就会返回这个配置的实现类Class；如果没有配置，则会返回Spring默认的实现类XmlWebApplicationContext。直接进入determineContextClass方法体，代码如下。</p>\n<h2 id=\"determineContextClass\"><a href=\"#determineContextClass\" class=\"headerlink\" title=\"determineContextClass\"></a>determineContextClass</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 代码位置：ContextLoader#determineContextClass()</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span> Class&lt;?&gt; determineContextClass(ServletContext servletContext) &#123;</span><br><span class=\"line\">\tString contextClassName = servletContext.getInitParameter(CONTEXT_CLASS_PARAM);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (contextClassName != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> ClassUtils.forName(contextClassName, ClassUtils.getDefaultClassLoader());</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ApplicationContextException(</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"string\">\"Failed to load custom context class [\"</span> + contextClassName + <span class=\"string\">\"]\"</span>, ex);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\tcontextClassName = defaultStrategies.getProperty(WebApplicationContext.class.getName());</span><br><span class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> ClassUtils.forName(contextClassName, ContextLoader.class.getClassLoader());</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ApplicationContextException(</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"string\">\"Failed to load default context class [\"</span> + contextClassName + <span class=\"string\">\"]\"</span>, ex);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的代码中使用了defaultStrategies，用于获取Spring默认的WebApplicationContext接口实现类XmlWebApplicationContext.java，它的声明如下。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 代码位置：ContextLoader#私有属性和静态代码块</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String DEFAULT_STRATEGIES_PATH = <span class=\"string\">\"ContextLoader.properties\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Properties defaultStrategies;</span><br><span class=\"line\"><span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">       <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            ClassPathResource resource = <span class=\"keyword\">new</span> ClassPathResource(DEFAULT_STRATEGIES_PATH, ContextLoader.class);</span><br><span class=\"line\">            defaultStrategies = PropertiesLoaderUtils.loadProperties(resource);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">catch</span> (IOException ex) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Could not load 'ContextLoader.properties': \"</span> + ex.getMessage());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>也就是说在ContextLoader.java的路径下，有一个ContextLoader.properties文件，查找并打开这个文件，文件内容如下。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">org.springframework.web.context.WebApplicationContext=org.springframework.web.context.support.XmlWebApplicationContext</span><br></pre></td></tr></table></figure>\n<p>这里配置了Spring默认的WebApplicationContext接口实现类XmlWebApplicationContext.java。回到createWebApplicationContext方法，WebApplicationContext接口实现类的Class已经找到，然后就是使用构造函数进行初始化完成WebApplicationContext对象创建。<br>继续回到 <a href=\"#initWebApplicationContext\">&gt;&gt; initWebApplicationContext</a> 方法，此时这个context就指向了刚刚创建的WebApplicationContext对象。因为XmlWebApplicationContext间接实现了ConfigurableWebApplicationContext接口，所以将会执行如下代码。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 代码位置：ContextLoader#initWebApplicationContext（）</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.context <span class=\"keyword\">instanceof</span> ConfigurableWebApplicationContext) &#123;</span><br><span class=\"line\">\tConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) <span class=\"keyword\">this</span>.context;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!cwac.isActive()) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (cwac.getParent() == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\tApplicationContext parent = loadParentContext(servletContext);</span><br><span class=\"line\">\t\t\t\tcwac.setParent(parent);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">        configureAndRefreshWebApplicationContext(cwac, servletContext);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里关注重点代码configureAndRefreshWebApplicationContext(cwac, servletContext)，configureAndRefreshWebApplicationContext方法具体代码如下。</p>\n<h2 id=\"configureAndRefreshWebApplicationContext\"><a href=\"#configureAndRefreshWebApplicationContext\" class=\"headerlink\" title=\"configureAndRefreshWebApplicationContext\"></a>configureAndRefreshWebApplicationContext</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 代码位置：ContextLoader#configureAndRefreshWebApplicationContext（）</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">configureAndRefreshWebApplicationContext</span><span class=\"params\">(ConfigurableWebApplicationContext wac, ServletContext sc)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (ObjectUtils.identityToString(wac).equals(wac.getId())) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//如果应用程序上下文ID仍是其原始默认值则根据可用信息分配更有用的ID</span></span><br><span class=\"line\">\t\tString idParam = sc.getInitParameter(CONTEXT_ID_PARAM);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (idParam != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t wac.setId(idParam);</span><br><span class=\"line\">\t\t&#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\t\twac.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX +</span><br><span class=\"line\">                        ObjectUtils.getDisplayString(sc.getContextPath()));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\twac.setServletContext(sc);</span><br><span class=\"line\">\tString configLocationParam = sc.getInitParameter(CONFIG_LOCATION_PARAM);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (configLocationParam != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        wac.setConfigLocation(configLocationParam);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ConfigurableEnvironment env = wac.getEnvironment();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (env <span class=\"keyword\">instanceof</span> ConfigurableWebEnvironment) &#123;</span><br><span class=\"line\">        ((ConfigurableWebEnvironment) env).initPropertySources(sc, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    customizeContext(sc, wac);</span><br><span class=\"line\">    wac.refresh();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>还是一样，关注重点代码。看一下CONFIG_LOCATION_PARAM这个常量的值是”contextConfigLocation”，OK，这个就是web.xml中配置applicationContext.xml的。这个参数如果没有配置，在XmlWebApplicationContext中是有默认值的，具体的值如下。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">public static final String DEFAULT_CONFIG_LOCATION = &quot;/WEB-INF/applicationContext.xml&quot;;</span><br></pre></td></tr></table></figure>\n<p>也就是说，如果没有配置contextConfigLocation参数，将会使用/WEB-INF/applicationContext.xml。关注configureAndRefreshWebApplicationContext方法的最后一行代码wac.refresh()，是不是有点眼熟，继续跟踪代码，refresh方法的具体代码如下。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 代码位置：AbstractApplicationContext#refresh（）</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">refresh</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (<span class=\"keyword\">this</span>.startupShutdownMonitor) &#123;</span><br><span class=\"line\">        prepareRefresh();</span><br><span class=\"line\">        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class=\"line\">        prepareBeanFactory(beanFactory);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            postProcessBeanFactory(beanFactory);</span><br><span class=\"line\">            invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class=\"line\">            registerBeanPostProcessors(beanFactory);</span><br><span class=\"line\">            initMessageSource();</span><br><span class=\"line\">            initApplicationEventMulticaster();</span><br><span class=\"line\">            onRefresh();</span><br><span class=\"line\">            registerListeners();</span><br><span class=\"line\">            finishBeanFactoryInitialization(beanFactory);</span><br><span class=\"line\">            finishRefresh();</span><br><span class=\"line\">        &#125;<span class=\"keyword\">catch</span> (BeansException ex) &#123;</span><br><span class=\"line\">            logger.warn(<span class=\"string\">\"Exception encountered during context initialization - cancelling refresh attempt\"</span>, ex);</span><br><span class=\"line\">            destroyBeans();</span><br><span class=\"line\">            cancelRefresh(ex);</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> ex;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个refresh <a href=\"http://gubaidan.top/2017/11/06/2017-11-06-refresh/\" target=\"_blank\" rel=\"noopener\">《Spring | AbstractApplicationContext refresh()方法源码解析》</a> 中的refresh方法，用于完成Bean的解析、实例化及注册。  继续分析，回到<a href=\"#initWebApplicationContext\">&gt;&gt; initWebApplicationContext</a> 方法，将执行如下代码。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, <span class=\"keyword\">this</span>.context);</span><br></pre></td></tr></table></figure>\n<p>可以看到，这里将初始化后的context存到了servletContext中，具体的就是存到了一个Map变量中，key值就是WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE这个常量。</p>\n<p>使用Spring的WebApplicationContextUtils工具类获取这个WebApplicationContext方式如下。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">WebApplicationContext applicationContext = WebApplicationContextUtils.getWebApplicationContext(request.getServletContext());</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>参考：《Spring技术内幕》、《精通Spring 4.x 企业应用开发实战》</p>\n</blockquote>\n"},{"layout":"post","title":"回溯搜索算法总结","date":"2018-02-22T22:00:00.000Z","author":"Gubaidan","header-img":"/Header/gs.png","cdn":"header-on","_content":"### 理解回溯法\n\n回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。\n\n回溯法在解空间树中（解空间是一个树结构），按照深度优先策略进行搜索\n\n* 若用回溯法求问题的所有解时，要回溯到根，且根结点的所有可行的子树都要已被搜索遍才结束。\n\n\n* 若使用回溯法求任一个解时，只要搜索到问题的一个解就可以结束。\n\n\n\n回溯法中，首先需要明确下面三个概念：\n\n\n*  约束函数：约束函数是根据题意定出的。通过描述合法解的一般特征用于去除不合法的解，从而避免继续搜索出这个不合法解的剩余部分。因此，约束函数是对于任何状态空间树上的节点都有效、等价的。\n* 状态空间树：刚刚已经提到，状态空间树是一个对所有解的图形描述。树上的每个子节点的解都只有一个部分与父节点不同。\n* 扩展节点、活结点、死结点：所谓扩展节点，就是当前正在求出它的子节点的节点，在DFS中，只允许有一个扩展节点。活结点就是通过与约束函数的对照，节点本身和其父节点均满足约束函数要求的节点；死结点反之。由此很容易知道死结点是不必求出其子节点的（没有意义）。\n\n回溯法一般步骤：\n\n* 针对所给问题，确定问题的解空间，首先应明确定义问题的解空间，问题的解空间应至少包含问题的一个（最优）解。\n\n* 确定结点的扩展搜索规则\n\n* 以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。\n\n### 实战\n\n\n#### Subsets （Leetcode 78）\n\n> Given a set of distinct integers, nums, return all possible subsets (the power set).\n\n> Note: The solution set must not contain duplicate subsets.\n\n```sh\nInput: nums = [1,2,3]\nOutput:\n[\n  [3],\n  [1],\n  [2],\n  [1,2,3],\n  [1,3],\n  [2,3],\n  [1,2],\n  []\n]\n```\n\n描述：求解一个数列的全部不重复子集，输入也是不重复的。\n\n设计思想：利用回溯法，深度优先遍历树结构即可得到结果\n\n解空间\n\n![subsets](http://epoch-night.oss-cn-hangzhou.aliyuncs.com/PostImg/subsets.png)\n\n实现：\n\n\n```java\npublic static List<List<Integer>> subsets(int[] nums) {\n    //存储结果的list\n    List<List<Integer>> list = new ArrayList<>();\n    backtrack(list, new ArrayList<>(), nums, 0);\n    return list;\n}\n\nprivate static void backtrack(List<List<Integer>> list , List<Integer> tempList, int [] nums, int start) {\n    list.add(new ArrayList<>(tempList));\n    for (int i = start; i < nums.length; i++) {\n        tempList.add(nums[i]);\n        backtrack(list, tempList, nums, i + 1);\n        tempList.remove(tempList.size() - 1);\n    }\n}\n\npublic static void main(String[] args) {\n    int[] nums = new int[]{1, 2, 3};\n    List<List<Integer>> lists = subsets(nums);\n    for (List l1: lists){\n        System.out.println(l1.toString());\n    }\n\n}\n```\n\n这道题因为输入没有重复，所以不必设置剪枝规则，只要深度优先搜索完树结构，结果就出来了，回溯法对于这道题并不是最优解法，旨在学习总结回溯法。\n\n#### Subsets II（Leetcode 90）\n\n> Given a collection of integers that might contain duplicates, nums, return all possible subsets (the power set).\n\n> The solution set must not contain duplicate subsets.\n\n```java\nInput: [1,2,2]\nOutput:\n[\n  [2],\n  [1],\n  [1,2,2],\n  [2,2],\n  [1,2],\n  []\n]\n```\n\n描述：求解一个数列的全部不重复子集，**输入可能是重复的**。\n\n设计思想：因为输入包含重复，先对输入进行排序，然后利用回溯法，深度优先遍历树结构，如果当前节点与上一个节点相等则剪枝\n\n实现：\n\n```java\n public static List<List<Integer>> subsetsWithDup(int[] nums) {\n    List<List<Integer>> list = new ArrayList<>();\n    //因为包含重复 先排序\n    Arrays.sort(nums);\n    backtrack(list, new ArrayList<>(), nums, 0);\n    return list;\n}\n\nprivate static void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int start){\n    list.add(new ArrayList<>(tempList));\n    for(int i = start; i < nums.length; i++){\n\n\t\t  回溯过程中，如果当前节点和上一节点相同则剪枝\n        if(i > start && nums[i] == nums[i-1]) continue;             \t\t\t  tempList.add(nums[i]);\n        backtrack(list, tempList, nums, i + 1);\n        tempList.remove(tempList.size() - 1);\n    }\n}\n\npublic static void main(String[] args) {\n    int[] nums = new int[]{1, 2, 2};\n    List<List<Integer>> lists = subsetsWithDup(nums);\n    for (List l1: lists){\n        System.out.println(l1.toString());  //打印\n    }\n\n}\n```\n\n#### Permutations（leetcode 46）\n\n> Given a collection of distinct integers, return all possible permutations.\n\n```sh\nInput: [1,2,3]\nOutput:\n[\n  [1,2,3],\n  [1,3,2],\n  [2,1,3],\n  [2,3,1],\n  [3,1,2],\n  [3,2,1]\n]\n```\n\n描述：输入一个不重复数组，输出这个数组的全排列。\n\n问题分析：搜索解空间树，如果某一次搜索过程中结果的长度等于数组长度说明已经完成了一次从跟节点到叶节点的搜索，则把结果存储。如果在搜索过程中当前解已经存在于结果集，则剪枝。\n\n实现：\n\n```java\n public static List<List<Integer>> permute(int[] nums) {\n    List<List<Integer>> list = new ArrayList<>();\n    backtrack(list, new ArrayList<>(), nums);\n    return list;\n}\n\nprivate static void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums){\n    if(tempList.size() == nums.length){\n        //当list长度等于数组长度则加入结果集\n        list.add(new ArrayList<>(tempList));\n    } else{\n        //注意这里i从0开始\n        for(int i = 0; i < nums.length; i++){\n            //如果某一个结果已经包含这个数字 则剪枝\n            if(tempList.contains(nums[i])) continue; \n            tempList.add(nums[i]);\n            backtrack(list, tempList, nums);\n            tempList.remove(tempList.size() - 1);\n        }\n    }\n}\n\npublic static void main(String[] args) {\n    int[] nums = new int[]{1, 2, 3};\n    List<List<Integer>> lists = permute(nums);\n    for (List l1: lists){\n        System.out.println(l1.toString());\n    }\n}\n```\n\n#### Permutations II (leetcode 47)\n\n> Given a collection of numbers that might contain duplicates, return all possible unique permutations.\n\n```sh\nInput: [1,1,2]\nOutput:\n[\n  [1,1,2],\n  [1,2,1],\n  [2,1,1]\n]\n```\n\n描述：与上一题不同的是，这里的输入是包含重复的，输出同样是不重复的全部排列\n\n分析：既然包含重复的，则搜索算法执行之前要对数组进行排序，以便在后续剪枝。开启一个boolen数组存储搜索过程中某个元素是否已经被使用。\n\n剪枝规则：除了对已经包含在临时队列中的元素进行剪枝，还有对下一个元素和当前元素相等的搜素路径进行剪枝\n\n实现：\n\n\n```java\npublic static List<List<Integer>> permuteUnique(int[] nums) {\n    List<List<Integer>> list = new ArrayList<>();\n    //排序\n    Arrays.sort(nums);\n    backtrack(list, new ArrayList<>(), nums, new boolean[nums.length]);\n    return list;\n}\n\nprivate static void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, boolean [] used){\n    if(tempList.size() == nums.length){\n        list.add(new ArrayList<>(tempList));\n    } else{\n        for(int i = 0; i < nums.length; i++){\n        \t\t//如果已经使用过 \n            if(used[i] || i > 0 && nums[i] == nums[i-1] && !used[i - 1]) continue;\n            used[i] = true;\n            tempList.add(nums[i]);\n            backtrack(list, tempList, nums, used);\n            used[i] = false;\n            tempList.remove(tempList.size() - 1);\n        }\n    }\n}\n\npublic static void main(String[] args) {\n    int[] nums = new int[]{1, 2, 2};\n    List<List<Integer>> lists = permuteUnique(nums);\n    for (List l1: lists){\n        System.out.println(l1.toString());\n    }\n}\n```\n\n分析：\n\n```java\nif(used[i] || i > 0 && nums[i] == nums[i-1] && !used[i - 1]) continue;\n```\n\n如果按照上面题目的模式，将剪枝规则写为：\n\n```java\nif(i > 0 && nums[i] == nums[i-1] && tempList.contains(nums[i])) continue;\n```\n\n则结果为：\n\n```sh\n[1, 1, 1]\n[1, 1, 2]\n[1, 1, 2]\n[1, 2, 1]\n[1, 2, 2]\n[1, 2, 1]\n[1, 2, 2]\n[2, 1, 1]\n[2, 1, 2]\n[2, 2, 1]\n[2, 2, 2]\n[2, 1, 1]\n[2, 1, 2]\n[2, 2, 1]\n[2, 2, 2]\n```\n\n产生这种情况的原因是：因为输入是可重复的，所以每一个全排列组合是允许出现重复元素的，如果单单只是判断是不是包含在某个结果中，会导致元素的重复使用。\n\n#### Combination Sum（leetcode 39）\n> Given a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.\n\n> The same repeated number may be chosen from candidates unlimited number of times.\n\n```sh\nInput: candidates = [2,3,6,7], target = 7,\nA solution set is:\n[\n  [7],\n  [2,2,3]\n]\n```\n\n描述：输入一个不重复的数组和一个目标整数，求数组中所有加起来等于目标整数的集合，其中数组内的数可以多次使用。\n\n设计思路：搜索解空间时，用target 减去当前节点值，当值为0，就是其中一个解。如果小于0，则剪枝。排序是为了加快执行效率。\n\n实现：\n\n```java\npublic static List<List<Integer>> combinationSum(int[] nums, int target) {\n    List<List<Integer>> list = new ArrayList<>();\n    Arrays.sort(nums);\n    backtrack(list, new ArrayList<>(), nums, target, 0);\n    return list;\n}\n\nprivate static void backtrack(List<List<Integer>> list, List<Integer> tempList, int[] nums, int remain, int start) {\n    if (remain < 0) return;\n    else if (remain == 0) list.add(new ArrayList<>(tempList));\n    else {\n        for (int i = start; i < nums.length; i++) {\n            tempList.add(nums[i]);\n            backtrack(list, tempList, nums, remain - nums[i], i); // not i + 1 because we can reuse same elements\n            tempList.remove(tempList.size() - 1);\n        }\n    }\n}\n\npublic static void main(String[] args) {\n    int[] nums = new int[]{2, 3, 6, 7};\n    List<List<Integer>> lists = combinationSum(nums,7);\n    for (List l1 : lists) {\n        System.out.println(l1.toString());\n    }\n}\n```\n\n#### Combination Sum II（leetcode 40）\n\n> Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.\n\n> Each number in candidates may only be used once in the combination.\n\n```sh\nInput: candidates = [10,1,2,7,6,1,5], target = 8,\nA solution set is:\n[\n  [1, 7],\n  [1, 2, 5],\n  [2, 6],\n  [1, 1, 6]\n]\n```\n\n描述：输入一个**可重复**的数组和一个目标整数，求数组中所有加起来等于目标整数的集合，**其中数组内的数不可以多次使用**。\n\n设计思路：和上题类似，只是可使用的元素使用前会判断，如果和上一个元素相同则剪枝\n\n实现：\n\n```java\npublic static List<List<Integer>> combinationSum2(int[] nums, int target) {\n    List<List<Integer>> list = new ArrayList<>();\n    Arrays.sort(nums);\n    backtrack(list, new ArrayList<>(), nums, target, 0);\n    return list;\n\n}\n\nprivate static void backtrack(List<List<Integer>> list, List<Integer> tempList, int[] nums, int remain, int start) {\n    if (remain < 0) return;\n    else if (remain == 0) list.add(new ArrayList<>(tempList));\n    else {\n        for (int i = start; i < nums.length; i++) {\n            if (i > start && nums[i] == nums[i - 1]) continue; // 剪枝\n            tempList.add(nums[i]);\n            backtrack(list, tempList, nums, remain - nums[i], i + 1);\n            tempList.remove(tempList.size() - 1);\n        }\n    }\n}\n\npublic static void main(String[] args) {\n    int[] nums = new int[]{10, 1, 2, 7, 6, 1, 5};\n    List<List<Integer>> lists = combinationSum2(nums, 8);\n    for (List l1 : lists) {\n        System.out.println(l1.toString());\n    }\n}\n```\n\n\n\n\n","source":"_posts/2018-02-23-GS.markdown","raw":"---\nlayout: post\ntitle: \"回溯搜索算法总结\"\ndate: 2018-02-23 06:00\nauthor: \"Gubaidan\"\nheader-img: \"/Header/gs.png\"\ncdn: 'header-on'\ntags:\n\t- 算法\n---\n### 理解回溯法\n\n回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。\n\n回溯法在解空间树中（解空间是一个树结构），按照深度优先策略进行搜索\n\n* 若用回溯法求问题的所有解时，要回溯到根，且根结点的所有可行的子树都要已被搜索遍才结束。\n\n\n* 若使用回溯法求任一个解时，只要搜索到问题的一个解就可以结束。\n\n\n\n回溯法中，首先需要明确下面三个概念：\n\n\n*  约束函数：约束函数是根据题意定出的。通过描述合法解的一般特征用于去除不合法的解，从而避免继续搜索出这个不合法解的剩余部分。因此，约束函数是对于任何状态空间树上的节点都有效、等价的。\n* 状态空间树：刚刚已经提到，状态空间树是一个对所有解的图形描述。树上的每个子节点的解都只有一个部分与父节点不同。\n* 扩展节点、活结点、死结点：所谓扩展节点，就是当前正在求出它的子节点的节点，在DFS中，只允许有一个扩展节点。活结点就是通过与约束函数的对照，节点本身和其父节点均满足约束函数要求的节点；死结点反之。由此很容易知道死结点是不必求出其子节点的（没有意义）。\n\n回溯法一般步骤：\n\n* 针对所给问题，确定问题的解空间，首先应明确定义问题的解空间，问题的解空间应至少包含问题的一个（最优）解。\n\n* 确定结点的扩展搜索规则\n\n* 以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。\n\n### 实战\n\n\n#### Subsets （Leetcode 78）\n\n> Given a set of distinct integers, nums, return all possible subsets (the power set).\n\n> Note: The solution set must not contain duplicate subsets.\n\n```sh\nInput: nums = [1,2,3]\nOutput:\n[\n  [3],\n  [1],\n  [2],\n  [1,2,3],\n  [1,3],\n  [2,3],\n  [1,2],\n  []\n]\n```\n\n描述：求解一个数列的全部不重复子集，输入也是不重复的。\n\n设计思想：利用回溯法，深度优先遍历树结构即可得到结果\n\n解空间\n\n![subsets](http://epoch-night.oss-cn-hangzhou.aliyuncs.com/PostImg/subsets.png)\n\n实现：\n\n\n```java\npublic static List<List<Integer>> subsets(int[] nums) {\n    //存储结果的list\n    List<List<Integer>> list = new ArrayList<>();\n    backtrack(list, new ArrayList<>(), nums, 0);\n    return list;\n}\n\nprivate static void backtrack(List<List<Integer>> list , List<Integer> tempList, int [] nums, int start) {\n    list.add(new ArrayList<>(tempList));\n    for (int i = start; i < nums.length; i++) {\n        tempList.add(nums[i]);\n        backtrack(list, tempList, nums, i + 1);\n        tempList.remove(tempList.size() - 1);\n    }\n}\n\npublic static void main(String[] args) {\n    int[] nums = new int[]{1, 2, 3};\n    List<List<Integer>> lists = subsets(nums);\n    for (List l1: lists){\n        System.out.println(l1.toString());\n    }\n\n}\n```\n\n这道题因为输入没有重复，所以不必设置剪枝规则，只要深度优先搜索完树结构，结果就出来了，回溯法对于这道题并不是最优解法，旨在学习总结回溯法。\n\n#### Subsets II（Leetcode 90）\n\n> Given a collection of integers that might contain duplicates, nums, return all possible subsets (the power set).\n\n> The solution set must not contain duplicate subsets.\n\n```java\nInput: [1,2,2]\nOutput:\n[\n  [2],\n  [1],\n  [1,2,2],\n  [2,2],\n  [1,2],\n  []\n]\n```\n\n描述：求解一个数列的全部不重复子集，**输入可能是重复的**。\n\n设计思想：因为输入包含重复，先对输入进行排序，然后利用回溯法，深度优先遍历树结构，如果当前节点与上一个节点相等则剪枝\n\n实现：\n\n```java\n public static List<List<Integer>> subsetsWithDup(int[] nums) {\n    List<List<Integer>> list = new ArrayList<>();\n    //因为包含重复 先排序\n    Arrays.sort(nums);\n    backtrack(list, new ArrayList<>(), nums, 0);\n    return list;\n}\n\nprivate static void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int start){\n    list.add(new ArrayList<>(tempList));\n    for(int i = start; i < nums.length; i++){\n\n\t\t  回溯过程中，如果当前节点和上一节点相同则剪枝\n        if(i > start && nums[i] == nums[i-1]) continue;             \t\t\t  tempList.add(nums[i]);\n        backtrack(list, tempList, nums, i + 1);\n        tempList.remove(tempList.size() - 1);\n    }\n}\n\npublic static void main(String[] args) {\n    int[] nums = new int[]{1, 2, 2};\n    List<List<Integer>> lists = subsetsWithDup(nums);\n    for (List l1: lists){\n        System.out.println(l1.toString());  //打印\n    }\n\n}\n```\n\n#### Permutations（leetcode 46）\n\n> Given a collection of distinct integers, return all possible permutations.\n\n```sh\nInput: [1,2,3]\nOutput:\n[\n  [1,2,3],\n  [1,3,2],\n  [2,1,3],\n  [2,3,1],\n  [3,1,2],\n  [3,2,1]\n]\n```\n\n描述：输入一个不重复数组，输出这个数组的全排列。\n\n问题分析：搜索解空间树，如果某一次搜索过程中结果的长度等于数组长度说明已经完成了一次从跟节点到叶节点的搜索，则把结果存储。如果在搜索过程中当前解已经存在于结果集，则剪枝。\n\n实现：\n\n```java\n public static List<List<Integer>> permute(int[] nums) {\n    List<List<Integer>> list = new ArrayList<>();\n    backtrack(list, new ArrayList<>(), nums);\n    return list;\n}\n\nprivate static void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums){\n    if(tempList.size() == nums.length){\n        //当list长度等于数组长度则加入结果集\n        list.add(new ArrayList<>(tempList));\n    } else{\n        //注意这里i从0开始\n        for(int i = 0; i < nums.length; i++){\n            //如果某一个结果已经包含这个数字 则剪枝\n            if(tempList.contains(nums[i])) continue; \n            tempList.add(nums[i]);\n            backtrack(list, tempList, nums);\n            tempList.remove(tempList.size() - 1);\n        }\n    }\n}\n\npublic static void main(String[] args) {\n    int[] nums = new int[]{1, 2, 3};\n    List<List<Integer>> lists = permute(nums);\n    for (List l1: lists){\n        System.out.println(l1.toString());\n    }\n}\n```\n\n#### Permutations II (leetcode 47)\n\n> Given a collection of numbers that might contain duplicates, return all possible unique permutations.\n\n```sh\nInput: [1,1,2]\nOutput:\n[\n  [1,1,2],\n  [1,2,1],\n  [2,1,1]\n]\n```\n\n描述：与上一题不同的是，这里的输入是包含重复的，输出同样是不重复的全部排列\n\n分析：既然包含重复的，则搜索算法执行之前要对数组进行排序，以便在后续剪枝。开启一个boolen数组存储搜索过程中某个元素是否已经被使用。\n\n剪枝规则：除了对已经包含在临时队列中的元素进行剪枝，还有对下一个元素和当前元素相等的搜素路径进行剪枝\n\n实现：\n\n\n```java\npublic static List<List<Integer>> permuteUnique(int[] nums) {\n    List<List<Integer>> list = new ArrayList<>();\n    //排序\n    Arrays.sort(nums);\n    backtrack(list, new ArrayList<>(), nums, new boolean[nums.length]);\n    return list;\n}\n\nprivate static void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, boolean [] used){\n    if(tempList.size() == nums.length){\n        list.add(new ArrayList<>(tempList));\n    } else{\n        for(int i = 0; i < nums.length; i++){\n        \t\t//如果已经使用过 \n            if(used[i] || i > 0 && nums[i] == nums[i-1] && !used[i - 1]) continue;\n            used[i] = true;\n            tempList.add(nums[i]);\n            backtrack(list, tempList, nums, used);\n            used[i] = false;\n            tempList.remove(tempList.size() - 1);\n        }\n    }\n}\n\npublic static void main(String[] args) {\n    int[] nums = new int[]{1, 2, 2};\n    List<List<Integer>> lists = permuteUnique(nums);\n    for (List l1: lists){\n        System.out.println(l1.toString());\n    }\n}\n```\n\n分析：\n\n```java\nif(used[i] || i > 0 && nums[i] == nums[i-1] && !used[i - 1]) continue;\n```\n\n如果按照上面题目的模式，将剪枝规则写为：\n\n```java\nif(i > 0 && nums[i] == nums[i-1] && tempList.contains(nums[i])) continue;\n```\n\n则结果为：\n\n```sh\n[1, 1, 1]\n[1, 1, 2]\n[1, 1, 2]\n[1, 2, 1]\n[1, 2, 2]\n[1, 2, 1]\n[1, 2, 2]\n[2, 1, 1]\n[2, 1, 2]\n[2, 2, 1]\n[2, 2, 2]\n[2, 1, 1]\n[2, 1, 2]\n[2, 2, 1]\n[2, 2, 2]\n```\n\n产生这种情况的原因是：因为输入是可重复的，所以每一个全排列组合是允许出现重复元素的，如果单单只是判断是不是包含在某个结果中，会导致元素的重复使用。\n\n#### Combination Sum（leetcode 39）\n> Given a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.\n\n> The same repeated number may be chosen from candidates unlimited number of times.\n\n```sh\nInput: candidates = [2,3,6,7], target = 7,\nA solution set is:\n[\n  [7],\n  [2,2,3]\n]\n```\n\n描述：输入一个不重复的数组和一个目标整数，求数组中所有加起来等于目标整数的集合，其中数组内的数可以多次使用。\n\n设计思路：搜索解空间时，用target 减去当前节点值，当值为0，就是其中一个解。如果小于0，则剪枝。排序是为了加快执行效率。\n\n实现：\n\n```java\npublic static List<List<Integer>> combinationSum(int[] nums, int target) {\n    List<List<Integer>> list = new ArrayList<>();\n    Arrays.sort(nums);\n    backtrack(list, new ArrayList<>(), nums, target, 0);\n    return list;\n}\n\nprivate static void backtrack(List<List<Integer>> list, List<Integer> tempList, int[] nums, int remain, int start) {\n    if (remain < 0) return;\n    else if (remain == 0) list.add(new ArrayList<>(tempList));\n    else {\n        for (int i = start; i < nums.length; i++) {\n            tempList.add(nums[i]);\n            backtrack(list, tempList, nums, remain - nums[i], i); // not i + 1 because we can reuse same elements\n            tempList.remove(tempList.size() - 1);\n        }\n    }\n}\n\npublic static void main(String[] args) {\n    int[] nums = new int[]{2, 3, 6, 7};\n    List<List<Integer>> lists = combinationSum(nums,7);\n    for (List l1 : lists) {\n        System.out.println(l1.toString());\n    }\n}\n```\n\n#### Combination Sum II（leetcode 40）\n\n> Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.\n\n> Each number in candidates may only be used once in the combination.\n\n```sh\nInput: candidates = [10,1,2,7,6,1,5], target = 8,\nA solution set is:\n[\n  [1, 7],\n  [1, 2, 5],\n  [2, 6],\n  [1, 1, 6]\n]\n```\n\n描述：输入一个**可重复**的数组和一个目标整数，求数组中所有加起来等于目标整数的集合，**其中数组内的数不可以多次使用**。\n\n设计思路：和上题类似，只是可使用的元素使用前会判断，如果和上一个元素相同则剪枝\n\n实现：\n\n```java\npublic static List<List<Integer>> combinationSum2(int[] nums, int target) {\n    List<List<Integer>> list = new ArrayList<>();\n    Arrays.sort(nums);\n    backtrack(list, new ArrayList<>(), nums, target, 0);\n    return list;\n\n}\n\nprivate static void backtrack(List<List<Integer>> list, List<Integer> tempList, int[] nums, int remain, int start) {\n    if (remain < 0) return;\n    else if (remain == 0) list.add(new ArrayList<>(tempList));\n    else {\n        for (int i = start; i < nums.length; i++) {\n            if (i > start && nums[i] == nums[i - 1]) continue; // 剪枝\n            tempList.add(nums[i]);\n            backtrack(list, tempList, nums, remain - nums[i], i + 1);\n            tempList.remove(tempList.size() - 1);\n        }\n    }\n}\n\npublic static void main(String[] args) {\n    int[] nums = new int[]{10, 1, 2, 7, 6, 1, 5};\n    List<List<Integer>> lists = combinationSum2(nums, 8);\n    for (List l1 : lists) {\n        System.out.println(l1.toString());\n    }\n}\n```\n\n\n\n\n","slug":"2018-02-23-GS","published":1,"updated":"2019-05-05T12:35:59.989Z","comments":1,"photos":[],"link":"","_id":"cjvayvwgc0024m46a2mffzagx","content":"<h3 id=\"理解回溯法\"><a href=\"#理解回溯法\" class=\"headerlink\" title=\"理解回溯法\"></a>理解回溯法</h3><p>回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。</p>\n<p>回溯法在解空间树中（解空间是一个树结构），按照深度优先策略进行搜索</p>\n<ul>\n<li>若用回溯法求问题的所有解时，要回溯到根，且根结点的所有可行的子树都要已被搜索遍才结束。</li>\n</ul>\n<ul>\n<li>若使用回溯法求任一个解时，只要搜索到问题的一个解就可以结束。</li>\n</ul>\n<p>回溯法中，首先需要明确下面三个概念：</p>\n<ul>\n<li>约束函数：约束函数是根据题意定出的。通过描述合法解的一般特征用于去除不合法的解，从而避免继续搜索出这个不合法解的剩余部分。因此，约束函数是对于任何状态空间树上的节点都有效、等价的。</li>\n<li>状态空间树：刚刚已经提到，状态空间树是一个对所有解的图形描述。树上的每个子节点的解都只有一个部分与父节点不同。</li>\n<li>扩展节点、活结点、死结点：所谓扩展节点，就是当前正在求出它的子节点的节点，在DFS中，只允许有一个扩展节点。活结点就是通过与约束函数的对照，节点本身和其父节点均满足约束函数要求的节点；死结点反之。由此很容易知道死结点是不必求出其子节点的（没有意义）。</li>\n</ul>\n<p>回溯法一般步骤：</p>\n<ul>\n<li><p>针对所给问题，确定问题的解空间，首先应明确定义问题的解空间，问题的解空间应至少包含问题的一个（最优）解。</p>\n</li>\n<li><p>确定结点的扩展搜索规则</p>\n</li>\n<li><p>以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。</p>\n</li>\n</ul>\n<h3 id=\"实战\"><a href=\"#实战\" class=\"headerlink\" title=\"实战\"></a>实战</h3><h4 id=\"Subsets-（Leetcode-78）\"><a href=\"#Subsets-（Leetcode-78）\" class=\"headerlink\" title=\"Subsets （Leetcode 78）\"></a>Subsets （Leetcode 78）</h4><blockquote>\n<p>Given a set of distinct integers, nums, return all possible subsets (the power set).</p>\n</blockquote>\n<blockquote>\n<p>Note: The solution set must not contain duplicate subsets.</p>\n</blockquote>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: nums = [1,2,3]</span><br><span class=\"line\">Output:</span><br><span class=\"line\">[</span><br><span class=\"line\">  [3],</span><br><span class=\"line\">  [1],</span><br><span class=\"line\">  [2],</span><br><span class=\"line\">  [1,2,3],</span><br><span class=\"line\">  [1,3],</span><br><span class=\"line\">  [2,3],</span><br><span class=\"line\">  [1,2],</span><br><span class=\"line\">  []</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>描述：求解一个数列的全部不重复子集，输入也是不重复的。</p>\n<p>设计思想：利用回溯法，深度优先遍历树结构即可得到结果</p>\n<p>解空间</p>\n<p><img src=\"http://epoch-night.oss-cn-hangzhou.aliyuncs.com/PostImg/subsets.png\" alt=\"subsets\"></p>\n<p>实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class=\"keyword\">int</span>[] nums) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//存储结果的list</span></span><br><span class=\"line\">    List&lt;List&lt;Integer&gt;&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    backtrack(list, <span class=\"keyword\">new</span> ArrayList&lt;&gt;(), nums, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">backtrack</span><span class=\"params\">(List&lt;List&lt;Integer&gt;&gt; list , List&lt;Integer&gt; tempList, <span class=\"keyword\">int</span> [] nums, <span class=\"keyword\">int</span> start)</span> </span>&#123;</span><br><span class=\"line\">    list.add(<span class=\"keyword\">new</span> ArrayList&lt;&gt;(tempList));</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = start; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">        tempList.add(nums[i]);</span><br><span class=\"line\">        backtrack(list, tempList, nums, i + <span class=\"number\">1</span>);</span><br><span class=\"line\">        tempList.remove(tempList.size() - <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] nums = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;;</span><br><span class=\"line\">    List&lt;List&lt;Integer&gt;&gt; lists = subsets(nums);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (List l1: lists)&#123;</span><br><span class=\"line\">        System.out.println(l1.toString());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这道题因为输入没有重复，所以不必设置剪枝规则，只要深度优先搜索完树结构，结果就出来了，回溯法对于这道题并不是最优解法，旨在学习总结回溯法。</p>\n<h4 id=\"Subsets-II（Leetcode-90）\"><a href=\"#Subsets-II（Leetcode-90）\" class=\"headerlink\" title=\"Subsets II（Leetcode 90）\"></a>Subsets II（Leetcode 90）</h4><blockquote>\n<p>Given a collection of integers that might contain duplicates, nums, return all possible subsets (the power set).</p>\n</blockquote>\n<blockquote>\n<p>The solution set must not contain duplicate subsets.</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">2</span>]</span><br><span class=\"line\">Output:</span><br><span class=\"line\">[</span><br><span class=\"line\">  [<span class=\"number\">2</span>],</span><br><span class=\"line\">  [<span class=\"number\">1</span>],</span><br><span class=\"line\">  [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">2</span>],</span><br><span class=\"line\">  [<span class=\"number\">2</span>,<span class=\"number\">2</span>],</span><br><span class=\"line\">  [<span class=\"number\">1</span>,<span class=\"number\">2</span>],</span><br><span class=\"line\">  []</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>描述：求解一个数列的全部不重复子集，<strong>输入可能是重复的</strong>。</p>\n<p>设计思想：因为输入包含重复，先对输入进行排序，然后利用回溯法，深度优先遍历树结构，如果当前节点与上一个节点相等则剪枝</p>\n<p>实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(<span class=\"keyword\">int</span>[] nums) &#123;</span><br><span class=\"line\">    List&lt;List&lt;Integer&gt;&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    <span class=\"comment\">//因为包含重复 先排序</span></span><br><span class=\"line\">    Arrays.sort(nums);</span><br><span class=\"line\">    backtrack(list, <span class=\"keyword\">new</span> ArrayList&lt;&gt;(), nums, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">backtrack</span><span class=\"params\">(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, <span class=\"keyword\">int</span> [] nums, <span class=\"keyword\">int</span> start)</span></span>&#123;</span><br><span class=\"line\">    list.add(<span class=\"keyword\">new</span> ArrayList&lt;&gt;(tempList));</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = start; i &lt; nums.length; i++)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t  回溯过程中，如果当前节点和上一节点相同则剪枝</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i &gt; start &amp;&amp; nums[i] == nums[i-<span class=\"number\">1</span>]) <span class=\"keyword\">continue</span>;             \t\t\t  tempList.add(nums[i]);</span><br><span class=\"line\">        backtrack(list, tempList, nums, i + <span class=\"number\">1</span>);</span><br><span class=\"line\">        tempList.remove(tempList.size() - <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] nums = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>&#125;;</span><br><span class=\"line\">    List&lt;List&lt;Integer&gt;&gt; lists = subsetsWithDup(nums);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (List l1: lists)&#123;</span><br><span class=\"line\">        System.out.println(l1.toString());  <span class=\"comment\">//打印</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"Permutations（leetcode-46）\"><a href=\"#Permutations（leetcode-46）\" class=\"headerlink\" title=\"Permutations（leetcode 46）\"></a>Permutations（leetcode 46）</h4><blockquote>\n<p>Given a collection of distinct integers, return all possible permutations.</p>\n</blockquote>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [1,2,3]</span><br><span class=\"line\">Output:</span><br><span class=\"line\">[</span><br><span class=\"line\">  [1,2,3],</span><br><span class=\"line\">  [1,3,2],</span><br><span class=\"line\">  [2,1,3],</span><br><span class=\"line\">  [2,3,1],</span><br><span class=\"line\">  [3,1,2],</span><br><span class=\"line\">  [3,2,1]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>描述：输入一个不重复数组，输出这个数组的全排列。</p>\n<p>问题分析：搜索解空间树，如果某一次搜索过程中结果的长度等于数组长度说明已经完成了一次从跟节点到叶节点的搜索，则把结果存储。如果在搜索过程中当前解已经存在于结果集，则剪枝。</p>\n<p>实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class=\"keyword\">int</span>[] nums) &#123;</span><br><span class=\"line\">    List&lt;List&lt;Integer&gt;&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    backtrack(list, <span class=\"keyword\">new</span> ArrayList&lt;&gt;(), nums);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">backtrack</span><span class=\"params\">(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, <span class=\"keyword\">int</span> [] nums)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(tempList.size() == nums.length)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//当list长度等于数组长度则加入结果集</span></span><br><span class=\"line\">        list.add(<span class=\"keyword\">new</span> ArrayList&lt;&gt;(tempList));</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//注意这里i从0开始</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//如果某一个结果已经包含这个数字 则剪枝</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(tempList.contains(nums[i])) <span class=\"keyword\">continue</span>; </span><br><span class=\"line\">            tempList.add(nums[i]);</span><br><span class=\"line\">            backtrack(list, tempList, nums);</span><br><span class=\"line\">            tempList.remove(tempList.size() - <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] nums = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;;</span><br><span class=\"line\">    List&lt;List&lt;Integer&gt;&gt; lists = permute(nums);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (List l1: lists)&#123;</span><br><span class=\"line\">        System.out.println(l1.toString());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"Permutations-II-leetcode-47\"><a href=\"#Permutations-II-leetcode-47\" class=\"headerlink\" title=\"Permutations II (leetcode 47)\"></a>Permutations II (leetcode 47)</h4><blockquote>\n<p>Given a collection of numbers that might contain duplicates, return all possible unique permutations.</p>\n</blockquote>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [1,1,2]</span><br><span class=\"line\">Output:</span><br><span class=\"line\">[</span><br><span class=\"line\">  [1,1,2],</span><br><span class=\"line\">  [1,2,1],</span><br><span class=\"line\">  [2,1,1]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>描述：与上一题不同的是，这里的输入是包含重复的，输出同样是不重复的全部排列</p>\n<p>分析：既然包含重复的，则搜索算法执行之前要对数组进行排序，以便在后续剪枝。开启一个boolen数组存储搜索过程中某个元素是否已经被使用。</p>\n<p>剪枝规则：除了对已经包含在临时队列中的元素进行剪枝，还有对下一个元素和当前元素相等的搜素路径进行剪枝</p>\n<p>实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class=\"keyword\">int</span>[] nums) &#123;</span><br><span class=\"line\">    List&lt;List&lt;Integer&gt;&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    <span class=\"comment\">//排序</span></span><br><span class=\"line\">    Arrays.sort(nums);</span><br><span class=\"line\">    backtrack(list, <span class=\"keyword\">new</span> ArrayList&lt;&gt;(), nums, <span class=\"keyword\">new</span> <span class=\"keyword\">boolean</span>[nums.length]);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">backtrack</span><span class=\"params\">(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, <span class=\"keyword\">int</span> [] nums, <span class=\"keyword\">boolean</span> [] used)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(tempList.size() == nums.length)&#123;</span><br><span class=\"line\">        list.add(<span class=\"keyword\">new</span> ArrayList&lt;&gt;(tempList));</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class=\"line\">        \t\t<span class=\"comment\">//如果已经使用过 </span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(used[i] || i &gt; <span class=\"number\">0</span> &amp;&amp; nums[i] == nums[i-<span class=\"number\">1</span>] &amp;&amp; !used[i - <span class=\"number\">1</span>]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            used[i] = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            tempList.add(nums[i]);</span><br><span class=\"line\">            backtrack(list, tempList, nums, used);</span><br><span class=\"line\">            used[i] = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            tempList.remove(tempList.size() - <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] nums = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>&#125;;</span><br><span class=\"line\">    List&lt;List&lt;Integer&gt;&gt; lists = permuteUnique(nums);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (List l1: lists)&#123;</span><br><span class=\"line\">        System.out.println(l1.toString());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>分析：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(used[i] || i &gt; <span class=\"number\">0</span> &amp;&amp; nums[i] == nums[i-<span class=\"number\">1</span>] &amp;&amp; !used[i - <span class=\"number\">1</span>]) <span class=\"keyword\">continue</span>;</span><br></pre></td></tr></table></figure>\n<p>如果按照上面题目的模式，将剪枝规则写为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(i &gt; <span class=\"number\">0</span> &amp;&amp; nums[i] == nums[i-<span class=\"number\">1</span>] &amp;&amp; tempList.contains(nums[i])) <span class=\"keyword\">continue</span>;</span><br></pre></td></tr></table></figure>\n<p>则结果为：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">[1, 1, 1]</span><br><span class=\"line\">[1, 1, 2]</span><br><span class=\"line\">[1, 1, 2]</span><br><span class=\"line\">[1, 2, 1]</span><br><span class=\"line\">[1, 2, 2]</span><br><span class=\"line\">[1, 2, 1]</span><br><span class=\"line\">[1, 2, 2]</span><br><span class=\"line\">[2, 1, 1]</span><br><span class=\"line\">[2, 1, 2]</span><br><span class=\"line\">[2, 2, 1]</span><br><span class=\"line\">[2, 2, 2]</span><br><span class=\"line\">[2, 1, 1]</span><br><span class=\"line\">[2, 1, 2]</span><br><span class=\"line\">[2, 2, 1]</span><br><span class=\"line\">[2, 2, 2]</span><br></pre></td></tr></table></figure>\n<p>产生这种情况的原因是：因为输入是可重复的，所以每一个全排列组合是允许出现重复元素的，如果单单只是判断是不是包含在某个结果中，会导致元素的重复使用。</p>\n<h4 id=\"Combination-Sum（leetcode-39）\"><a href=\"#Combination-Sum（leetcode-39）\" class=\"headerlink\" title=\"Combination Sum（leetcode 39）\"></a>Combination Sum（leetcode 39）</h4><blockquote>\n<p>Given a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.</p>\n</blockquote>\n<blockquote>\n<p>The same repeated number may be chosen from candidates unlimited number of times.</p>\n</blockquote>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: candidates = [2,3,6,7], target = 7,</span><br><span class=\"line\">A solution <span class=\"built_in\">set</span> is:</span><br><span class=\"line\">[</span><br><span class=\"line\">  [7],</span><br><span class=\"line\">  [2,2,3]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>描述：输入一个不重复的数组和一个目标整数，求数组中所有加起来等于目标整数的集合，其中数组内的数可以多次使用。</p>\n<p>设计思路：搜索解空间时，用target 减去当前节点值，当值为0，就是其中一个解。如果小于0，则剪枝。排序是为了加快执行效率。</p>\n<p>实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> target) &#123;</span><br><span class=\"line\">    List&lt;List&lt;Integer&gt;&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    Arrays.sort(nums);</span><br><span class=\"line\">    backtrack(list, <span class=\"keyword\">new</span> ArrayList&lt;&gt;(), nums, target, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">backtrack</span><span class=\"params\">(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, <span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> remain, <span class=\"keyword\">int</span> start)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (remain &lt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (remain == <span class=\"number\">0</span>) list.add(<span class=\"keyword\">new</span> ArrayList&lt;&gt;(tempList));</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = start; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">            tempList.add(nums[i]);</span><br><span class=\"line\">            backtrack(list, tempList, nums, remain - nums[i], i); <span class=\"comment\">// not i + 1 because we can reuse same elements</span></span><br><span class=\"line\">            tempList.remove(tempList.size() - <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] nums = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>&#125;;</span><br><span class=\"line\">    List&lt;List&lt;Integer&gt;&gt; lists = combinationSum(nums,<span class=\"number\">7</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (List l1 : lists) &#123;</span><br><span class=\"line\">        System.out.println(l1.toString());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"Combination-Sum-II（leetcode-40）\"><a href=\"#Combination-Sum-II（leetcode-40）\" class=\"headerlink\" title=\"Combination Sum II（leetcode 40）\"></a>Combination Sum II（leetcode 40）</h4><blockquote>\n<p>Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.</p>\n</blockquote>\n<blockquote>\n<p>Each number in candidates may only be used once in the combination.</p>\n</blockquote>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: candidates = [10,1,2,7,6,1,5], target = 8,</span><br><span class=\"line\">A solution <span class=\"built_in\">set</span> is:</span><br><span class=\"line\">[</span><br><span class=\"line\">  [1, 7],</span><br><span class=\"line\">  [1, 2, 5],</span><br><span class=\"line\">  [2, 6],</span><br><span class=\"line\">  [1, 1, 6]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>描述：输入一个<strong>可重复</strong>的数组和一个目标整数，求数组中所有加起来等于目标整数的集合，<strong>其中数组内的数不可以多次使用</strong>。</p>\n<p>设计思路：和上题类似，只是可使用的元素使用前会判断，如果和上一个元素相同则剪枝</p>\n<p>实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> List&lt;List&lt;Integer&gt;&gt; combinationSum2(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> target) &#123;</span><br><span class=\"line\">    List&lt;List&lt;Integer&gt;&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    Arrays.sort(nums);</span><br><span class=\"line\">    backtrack(list, <span class=\"keyword\">new</span> ArrayList&lt;&gt;(), nums, target, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> list;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">backtrack</span><span class=\"params\">(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, <span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> remain, <span class=\"keyword\">int</span> start)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (remain &lt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (remain == <span class=\"number\">0</span>) list.add(<span class=\"keyword\">new</span> ArrayList&lt;&gt;(tempList));</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = start; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i &gt; start &amp;&amp; nums[i] == nums[i - <span class=\"number\">1</span>]) <span class=\"keyword\">continue</span>; <span class=\"comment\">// 剪枝</span></span><br><span class=\"line\">            tempList.add(nums[i]);</span><br><span class=\"line\">            backtrack(list, tempList, nums, remain - nums[i], i + <span class=\"number\">1</span>);</span><br><span class=\"line\">            tempList.remove(tempList.size() - <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] nums = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;<span class=\"number\">10</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">7</span>, <span class=\"number\">6</span>, <span class=\"number\">1</span>, <span class=\"number\">5</span>&#125;;</span><br><span class=\"line\">    List&lt;List&lt;Integer&gt;&gt; lists = combinationSum2(nums, <span class=\"number\">8</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (List l1 : lists) &#123;</span><br><span class=\"line\">        System.out.println(l1.toString());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"理解回溯法\"><a href=\"#理解回溯法\" class=\"headerlink\" title=\"理解回溯法\"></a>理解回溯法</h3><p>回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。</p>\n<p>回溯法在解空间树中（解空间是一个树结构），按照深度优先策略进行搜索</p>\n<ul>\n<li>若用回溯法求问题的所有解时，要回溯到根，且根结点的所有可行的子树都要已被搜索遍才结束。</li>\n</ul>\n<ul>\n<li>若使用回溯法求任一个解时，只要搜索到问题的一个解就可以结束。</li>\n</ul>\n<p>回溯法中，首先需要明确下面三个概念：</p>\n<ul>\n<li>约束函数：约束函数是根据题意定出的。通过描述合法解的一般特征用于去除不合法的解，从而避免继续搜索出这个不合法解的剩余部分。因此，约束函数是对于任何状态空间树上的节点都有效、等价的。</li>\n<li>状态空间树：刚刚已经提到，状态空间树是一个对所有解的图形描述。树上的每个子节点的解都只有一个部分与父节点不同。</li>\n<li>扩展节点、活结点、死结点：所谓扩展节点，就是当前正在求出它的子节点的节点，在DFS中，只允许有一个扩展节点。活结点就是通过与约束函数的对照，节点本身和其父节点均满足约束函数要求的节点；死结点反之。由此很容易知道死结点是不必求出其子节点的（没有意义）。</li>\n</ul>\n<p>回溯法一般步骤：</p>\n<ul>\n<li><p>针对所给问题，确定问题的解空间，首先应明确定义问题的解空间，问题的解空间应至少包含问题的一个（最优）解。</p>\n</li>\n<li><p>确定结点的扩展搜索规则</p>\n</li>\n<li><p>以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。</p>\n</li>\n</ul>\n<h3 id=\"实战\"><a href=\"#实战\" class=\"headerlink\" title=\"实战\"></a>实战</h3><h4 id=\"Subsets-（Leetcode-78）\"><a href=\"#Subsets-（Leetcode-78）\" class=\"headerlink\" title=\"Subsets （Leetcode 78）\"></a>Subsets （Leetcode 78）</h4><blockquote>\n<p>Given a set of distinct integers, nums, return all possible subsets (the power set).</p>\n</blockquote>\n<blockquote>\n<p>Note: The solution set must not contain duplicate subsets.</p>\n</blockquote>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: nums = [1,2,3]</span><br><span class=\"line\">Output:</span><br><span class=\"line\">[</span><br><span class=\"line\">  [3],</span><br><span class=\"line\">  [1],</span><br><span class=\"line\">  [2],</span><br><span class=\"line\">  [1,2,3],</span><br><span class=\"line\">  [1,3],</span><br><span class=\"line\">  [2,3],</span><br><span class=\"line\">  [1,2],</span><br><span class=\"line\">  []</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>描述：求解一个数列的全部不重复子集，输入也是不重复的。</p>\n<p>设计思想：利用回溯法，深度优先遍历树结构即可得到结果</p>\n<p>解空间</p>\n<p><img src=\"http://epoch-night.oss-cn-hangzhou.aliyuncs.com/PostImg/subsets.png\" alt=\"subsets\"></p>\n<p>实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class=\"keyword\">int</span>[] nums) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//存储结果的list</span></span><br><span class=\"line\">    List&lt;List&lt;Integer&gt;&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    backtrack(list, <span class=\"keyword\">new</span> ArrayList&lt;&gt;(), nums, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">backtrack</span><span class=\"params\">(List&lt;List&lt;Integer&gt;&gt; list , List&lt;Integer&gt; tempList, <span class=\"keyword\">int</span> [] nums, <span class=\"keyword\">int</span> start)</span> </span>&#123;</span><br><span class=\"line\">    list.add(<span class=\"keyword\">new</span> ArrayList&lt;&gt;(tempList));</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = start; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">        tempList.add(nums[i]);</span><br><span class=\"line\">        backtrack(list, tempList, nums, i + <span class=\"number\">1</span>);</span><br><span class=\"line\">        tempList.remove(tempList.size() - <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] nums = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;;</span><br><span class=\"line\">    List&lt;List&lt;Integer&gt;&gt; lists = subsets(nums);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (List l1: lists)&#123;</span><br><span class=\"line\">        System.out.println(l1.toString());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这道题因为输入没有重复，所以不必设置剪枝规则，只要深度优先搜索完树结构，结果就出来了，回溯法对于这道题并不是最优解法，旨在学习总结回溯法。</p>\n<h4 id=\"Subsets-II（Leetcode-90）\"><a href=\"#Subsets-II（Leetcode-90）\" class=\"headerlink\" title=\"Subsets II（Leetcode 90）\"></a>Subsets II（Leetcode 90）</h4><blockquote>\n<p>Given a collection of integers that might contain duplicates, nums, return all possible subsets (the power set).</p>\n</blockquote>\n<blockquote>\n<p>The solution set must not contain duplicate subsets.</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">2</span>]</span><br><span class=\"line\">Output:</span><br><span class=\"line\">[</span><br><span class=\"line\">  [<span class=\"number\">2</span>],</span><br><span class=\"line\">  [<span class=\"number\">1</span>],</span><br><span class=\"line\">  [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">2</span>],</span><br><span class=\"line\">  [<span class=\"number\">2</span>,<span class=\"number\">2</span>],</span><br><span class=\"line\">  [<span class=\"number\">1</span>,<span class=\"number\">2</span>],</span><br><span class=\"line\">  []</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>描述：求解一个数列的全部不重复子集，<strong>输入可能是重复的</strong>。</p>\n<p>设计思想：因为输入包含重复，先对输入进行排序，然后利用回溯法，深度优先遍历树结构，如果当前节点与上一个节点相等则剪枝</p>\n<p>实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(<span class=\"keyword\">int</span>[] nums) &#123;</span><br><span class=\"line\">    List&lt;List&lt;Integer&gt;&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    <span class=\"comment\">//因为包含重复 先排序</span></span><br><span class=\"line\">    Arrays.sort(nums);</span><br><span class=\"line\">    backtrack(list, <span class=\"keyword\">new</span> ArrayList&lt;&gt;(), nums, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">backtrack</span><span class=\"params\">(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, <span class=\"keyword\">int</span> [] nums, <span class=\"keyword\">int</span> start)</span></span>&#123;</span><br><span class=\"line\">    list.add(<span class=\"keyword\">new</span> ArrayList&lt;&gt;(tempList));</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = start; i &lt; nums.length; i++)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t  回溯过程中，如果当前节点和上一节点相同则剪枝</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i &gt; start &amp;&amp; nums[i] == nums[i-<span class=\"number\">1</span>]) <span class=\"keyword\">continue</span>;             \t\t\t  tempList.add(nums[i]);</span><br><span class=\"line\">        backtrack(list, tempList, nums, i + <span class=\"number\">1</span>);</span><br><span class=\"line\">        tempList.remove(tempList.size() - <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] nums = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>&#125;;</span><br><span class=\"line\">    List&lt;List&lt;Integer&gt;&gt; lists = subsetsWithDup(nums);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (List l1: lists)&#123;</span><br><span class=\"line\">        System.out.println(l1.toString());  <span class=\"comment\">//打印</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"Permutations（leetcode-46）\"><a href=\"#Permutations（leetcode-46）\" class=\"headerlink\" title=\"Permutations（leetcode 46）\"></a>Permutations（leetcode 46）</h4><blockquote>\n<p>Given a collection of distinct integers, return all possible permutations.</p>\n</blockquote>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [1,2,3]</span><br><span class=\"line\">Output:</span><br><span class=\"line\">[</span><br><span class=\"line\">  [1,2,3],</span><br><span class=\"line\">  [1,3,2],</span><br><span class=\"line\">  [2,1,3],</span><br><span class=\"line\">  [2,3,1],</span><br><span class=\"line\">  [3,1,2],</span><br><span class=\"line\">  [3,2,1]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>描述：输入一个不重复数组，输出这个数组的全排列。</p>\n<p>问题分析：搜索解空间树，如果某一次搜索过程中结果的长度等于数组长度说明已经完成了一次从跟节点到叶节点的搜索，则把结果存储。如果在搜索过程中当前解已经存在于结果集，则剪枝。</p>\n<p>实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class=\"keyword\">int</span>[] nums) &#123;</span><br><span class=\"line\">    List&lt;List&lt;Integer&gt;&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    backtrack(list, <span class=\"keyword\">new</span> ArrayList&lt;&gt;(), nums);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">backtrack</span><span class=\"params\">(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, <span class=\"keyword\">int</span> [] nums)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(tempList.size() == nums.length)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//当list长度等于数组长度则加入结果集</span></span><br><span class=\"line\">        list.add(<span class=\"keyword\">new</span> ArrayList&lt;&gt;(tempList));</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//注意这里i从0开始</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//如果某一个结果已经包含这个数字 则剪枝</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(tempList.contains(nums[i])) <span class=\"keyword\">continue</span>; </span><br><span class=\"line\">            tempList.add(nums[i]);</span><br><span class=\"line\">            backtrack(list, tempList, nums);</span><br><span class=\"line\">            tempList.remove(tempList.size() - <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] nums = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;;</span><br><span class=\"line\">    List&lt;List&lt;Integer&gt;&gt; lists = permute(nums);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (List l1: lists)&#123;</span><br><span class=\"line\">        System.out.println(l1.toString());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"Permutations-II-leetcode-47\"><a href=\"#Permutations-II-leetcode-47\" class=\"headerlink\" title=\"Permutations II (leetcode 47)\"></a>Permutations II (leetcode 47)</h4><blockquote>\n<p>Given a collection of numbers that might contain duplicates, return all possible unique permutations.</p>\n</blockquote>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: [1,1,2]</span><br><span class=\"line\">Output:</span><br><span class=\"line\">[</span><br><span class=\"line\">  [1,1,2],</span><br><span class=\"line\">  [1,2,1],</span><br><span class=\"line\">  [2,1,1]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>描述：与上一题不同的是，这里的输入是包含重复的，输出同样是不重复的全部排列</p>\n<p>分析：既然包含重复的，则搜索算法执行之前要对数组进行排序，以便在后续剪枝。开启一个boolen数组存储搜索过程中某个元素是否已经被使用。</p>\n<p>剪枝规则：除了对已经包含在临时队列中的元素进行剪枝，还有对下一个元素和当前元素相等的搜素路径进行剪枝</p>\n<p>实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class=\"keyword\">int</span>[] nums) &#123;</span><br><span class=\"line\">    List&lt;List&lt;Integer&gt;&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    <span class=\"comment\">//排序</span></span><br><span class=\"line\">    Arrays.sort(nums);</span><br><span class=\"line\">    backtrack(list, <span class=\"keyword\">new</span> ArrayList&lt;&gt;(), nums, <span class=\"keyword\">new</span> <span class=\"keyword\">boolean</span>[nums.length]);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">backtrack</span><span class=\"params\">(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, <span class=\"keyword\">int</span> [] nums, <span class=\"keyword\">boolean</span> [] used)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(tempList.size() == nums.length)&#123;</span><br><span class=\"line\">        list.add(<span class=\"keyword\">new</span> ArrayList&lt;&gt;(tempList));</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class=\"line\">        \t\t<span class=\"comment\">//如果已经使用过 </span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(used[i] || i &gt; <span class=\"number\">0</span> &amp;&amp; nums[i] == nums[i-<span class=\"number\">1</span>] &amp;&amp; !used[i - <span class=\"number\">1</span>]) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            used[i] = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            tempList.add(nums[i]);</span><br><span class=\"line\">            backtrack(list, tempList, nums, used);</span><br><span class=\"line\">            used[i] = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            tempList.remove(tempList.size() - <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] nums = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>&#125;;</span><br><span class=\"line\">    List&lt;List&lt;Integer&gt;&gt; lists = permuteUnique(nums);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (List l1: lists)&#123;</span><br><span class=\"line\">        System.out.println(l1.toString());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>分析：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(used[i] || i &gt; <span class=\"number\">0</span> &amp;&amp; nums[i] == nums[i-<span class=\"number\">1</span>] &amp;&amp; !used[i - <span class=\"number\">1</span>]) <span class=\"keyword\">continue</span>;</span><br></pre></td></tr></table></figure>\n<p>如果按照上面题目的模式，将剪枝规则写为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(i &gt; <span class=\"number\">0</span> &amp;&amp; nums[i] == nums[i-<span class=\"number\">1</span>] &amp;&amp; tempList.contains(nums[i])) <span class=\"keyword\">continue</span>;</span><br></pre></td></tr></table></figure>\n<p>则结果为：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">[1, 1, 1]</span><br><span class=\"line\">[1, 1, 2]</span><br><span class=\"line\">[1, 1, 2]</span><br><span class=\"line\">[1, 2, 1]</span><br><span class=\"line\">[1, 2, 2]</span><br><span class=\"line\">[1, 2, 1]</span><br><span class=\"line\">[1, 2, 2]</span><br><span class=\"line\">[2, 1, 1]</span><br><span class=\"line\">[2, 1, 2]</span><br><span class=\"line\">[2, 2, 1]</span><br><span class=\"line\">[2, 2, 2]</span><br><span class=\"line\">[2, 1, 1]</span><br><span class=\"line\">[2, 1, 2]</span><br><span class=\"line\">[2, 2, 1]</span><br><span class=\"line\">[2, 2, 2]</span><br></pre></td></tr></table></figure>\n<p>产生这种情况的原因是：因为输入是可重复的，所以每一个全排列组合是允许出现重复元素的，如果单单只是判断是不是包含在某个结果中，会导致元素的重复使用。</p>\n<h4 id=\"Combination-Sum（leetcode-39）\"><a href=\"#Combination-Sum（leetcode-39）\" class=\"headerlink\" title=\"Combination Sum（leetcode 39）\"></a>Combination Sum（leetcode 39）</h4><blockquote>\n<p>Given a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.</p>\n</blockquote>\n<blockquote>\n<p>The same repeated number may be chosen from candidates unlimited number of times.</p>\n</blockquote>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: candidates = [2,3,6,7], target = 7,</span><br><span class=\"line\">A solution <span class=\"built_in\">set</span> is:</span><br><span class=\"line\">[</span><br><span class=\"line\">  [7],</span><br><span class=\"line\">  [2,2,3]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>描述：输入一个不重复的数组和一个目标整数，求数组中所有加起来等于目标整数的集合，其中数组内的数可以多次使用。</p>\n<p>设计思路：搜索解空间时，用target 减去当前节点值，当值为0，就是其中一个解。如果小于0，则剪枝。排序是为了加快执行效率。</p>\n<p>实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> target) &#123;</span><br><span class=\"line\">    List&lt;List&lt;Integer&gt;&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    Arrays.sort(nums);</span><br><span class=\"line\">    backtrack(list, <span class=\"keyword\">new</span> ArrayList&lt;&gt;(), nums, target, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">backtrack</span><span class=\"params\">(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, <span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> remain, <span class=\"keyword\">int</span> start)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (remain &lt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (remain == <span class=\"number\">0</span>) list.add(<span class=\"keyword\">new</span> ArrayList&lt;&gt;(tempList));</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = start; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">            tempList.add(nums[i]);</span><br><span class=\"line\">            backtrack(list, tempList, nums, remain - nums[i], i); <span class=\"comment\">// not i + 1 because we can reuse same elements</span></span><br><span class=\"line\">            tempList.remove(tempList.size() - <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] nums = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>&#125;;</span><br><span class=\"line\">    List&lt;List&lt;Integer&gt;&gt; lists = combinationSum(nums,<span class=\"number\">7</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (List l1 : lists) &#123;</span><br><span class=\"line\">        System.out.println(l1.toString());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"Combination-Sum-II（leetcode-40）\"><a href=\"#Combination-Sum-II（leetcode-40）\" class=\"headerlink\" title=\"Combination Sum II（leetcode 40）\"></a>Combination Sum II（leetcode 40）</h4><blockquote>\n<p>Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.</p>\n</blockquote>\n<blockquote>\n<p>Each number in candidates may only be used once in the combination.</p>\n</blockquote>\n<figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">Input: candidates = [10,1,2,7,6,1,5], target = 8,</span><br><span class=\"line\">A solution <span class=\"built_in\">set</span> is:</span><br><span class=\"line\">[</span><br><span class=\"line\">  [1, 7],</span><br><span class=\"line\">  [1, 2, 5],</span><br><span class=\"line\">  [2, 6],</span><br><span class=\"line\">  [1, 1, 6]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>描述：输入一个<strong>可重复</strong>的数组和一个目标整数，求数组中所有加起来等于目标整数的集合，<strong>其中数组内的数不可以多次使用</strong>。</p>\n<p>设计思路：和上题类似，只是可使用的元素使用前会判断，如果和上一个元素相同则剪枝</p>\n<p>实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> List&lt;List&lt;Integer&gt;&gt; combinationSum2(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> target) &#123;</span><br><span class=\"line\">    List&lt;List&lt;Integer&gt;&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    Arrays.sort(nums);</span><br><span class=\"line\">    backtrack(list, <span class=\"keyword\">new</span> ArrayList&lt;&gt;(), nums, target, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> list;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">backtrack</span><span class=\"params\">(List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; tempList, <span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> remain, <span class=\"keyword\">int</span> start)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (remain &lt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (remain == <span class=\"number\">0</span>) list.add(<span class=\"keyword\">new</span> ArrayList&lt;&gt;(tempList));</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = start; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i &gt; start &amp;&amp; nums[i] == nums[i - <span class=\"number\">1</span>]) <span class=\"keyword\">continue</span>; <span class=\"comment\">// 剪枝</span></span><br><span class=\"line\">            tempList.add(nums[i]);</span><br><span class=\"line\">            backtrack(list, tempList, nums, remain - nums[i], i + <span class=\"number\">1</span>);</span><br><span class=\"line\">            tempList.remove(tempList.size() - <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] nums = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;<span class=\"number\">10</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">7</span>, <span class=\"number\">6</span>, <span class=\"number\">1</span>, <span class=\"number\">5</span>&#125;;</span><br><span class=\"line\">    List&lt;List&lt;Integer&gt;&gt; lists = combinationSum2(nums, <span class=\"number\">8</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (List l1 : lists) &#123;</span><br><span class=\"line\">        System.out.println(l1.toString());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"layout":"post","title":"轻量级权限管理框架之Shiro","date":"2018-03-23T04:00:00.000Z","author":"Gubaidan","header-img":"","cdn":"header-on","_content":"# 关于Shiro\n\n\n\nShiro是Apache公司旗下产品，与Apache项目结合起来稳定可靠，使用灵活，可以独立于任何项目独立存在，粒度比较大，对于普通的web项目足够满足需求。与Shiro相对应的是Spring-security，Spring-security对Spring结合较好，如果项目用的springmvc，使用起来很方便。但是 如果项目中没有用到spring，那就不要考虑它了，而且粒度很细不适用于小型项目。\n\n## Shiro的总体架构：\n\n![shiro-frame.png](http://epoch-night.oss-cn-hangzhou.aliyuncs.com/PostImg/shiro-frame.png)\n\nShiro主要组件包括：Subject，SecurityManager，Authenticator，Authorizer，SessionManager，CacheManager，Cryptography，Realms\n\n* Subject表示与系统交互的对象，一般是登录系统的操作用户，也可能是另外一个软件系统\n* SecurityManager是Shiro架构最核心的组件。实际上，SecurityManager就是Shiro框架的控制器，协调其他组件一起完成认证和授权\n* Authenticator用于认证，协调一个或者多个Realm，从Realm指定的数据源取得数据之后进行执行具体的认证# Maven项目中Shiro的使用\n* Authorizer用户访问控制授权，决定用户是否拥有执行指定操作的权限\n* Shiro与生俱来就支持会话管理，这在安全类框架中都是独一无二的功能。即便不存在web容器环境，shiro都可以使用自己的会话管理机制，提供相同的会话API\n* Shiro提供了一个加解密的命令行工具jar包，需要单独下载使用。\n详见  [https://shiro.apache.org/download.html\n](https://shiro.apache.org/download.html\n)\n\n## 一个常见的登陆过程：\n\n![login](http://epoch-night.oss-cn-hangzhou.aliyuncs.com/PostImg/login.png)\n\n1）使用用户的登录信息创建令牌\n\n```java\nSubject subject = SecurityUtils.getSubject(); //获得操作主题\nUsernamePasswordToken token = new UsernamePasswordToken(user.getUsername(), user.getPassward());\n```\n\ntoken可以理解为用户令牌，登录的过程被抽象为Shiro验证令牌是否具有合法身份以及相关权限。\n\n2）执行登陆操作\n\n```java\nsubject.login(token);\n```\n\n\nShiro的核心部分是SecurityManager，它负责安全认证与授权。Shiro本身已经实现了所有的细节，用户可以完全把它当做一个黑盒来使用。SecurityUtils对象，本质上就是一个工厂类似Spring中的ApplicationContext。Subject是初学者比较难于理解的对象，很多人以为它可以等同于User，其实不然。Subject中文翻译：项目，而正确的理解也恰恰如此。它是你目前所设计的需要通过Shiro保护的项目的一个抽象概念。通过令牌（token）与项目（subject）的登陆（login）关系，Shiro保证了项目整体的安全。\n\n3）检查角色\n\n```java\nsubject.checkRole(\"admin\"); //此处admin是通过数据库得来\n```\n\n4）检查权限\n\n```java\nsubject.checkPermission(\"user:delete\"); //此处的权限信息也来自数据库\n```\n\n\n\n\n# Maven项目中使用Shiro\n\n## 在pom.xml中配置依赖包\n\n```xml\n\t<!--Shiro核心依赖-->\n\t<dependency>\n        <groupId>org.apache.shiro</groupId>\n        <artifactId>shiro-core</artifactId>\n        <version>1.4.0</version>\n    </dependency>\n    \n    <!--Shiro与spring整合包-->\n    <dependency>\n        <groupId>org.apache.shiro</groupId>\n        <artifactId>shiro-spring</artifactId>\n        <version>1.4.0</version>\n    </dependency>\n    \n    <!--Shiro web依赖包-->\n    <dependency>\n        <groupId>org.apache.shiro</groupId>\n        <artifactId>shiro-web</artifactId>\n        <version>1.4.0</version>\n    </dependency>\n```\n## 在Spring.xml中配置相关bean\n\n```xml\n    <!--shiro自带过滤器-->\n<bean id=\"shiroFilter\" class=\"org.apache.shiro.spring.web.ShiroFilterFactoryBean\">\n    <property name=\"securityManager\" ref=\"securityManager\"/>\n    <property name=\"loginUrl\" value=\"login.html\"/>\n    <property name=\"unauthorizedUrl\" value=\"403.html\"/>\n    <property name=\"filterChainDefinitions\">\n        <value>\n            /login.html = anon\n            /subLogin = anon\n            /* = authc\n        </value>\n    </property>\n</bean>\n\n<!--自定义过滤器-->\n<bean class=\"filter.RolesOrFilter\" id=\"rolesOrFilter\"/>\n```\n\n\n```xml\n<!--创建SecurityMananger对象-->\n<bean id=\"securityManager\" class=\"org.apache.shiro.web.mgt.DefaultWebSecurityManager\">\n    <!--设置自定义Realm-->\n    <property name=\"realm\" ref=\"realm\"/>\n</bean>\n\n<!--定义自定义的Realm-->\n<bean id=\"realm\" class=\"realm.CustomRealm\">\n    <property name=\"credentialsMatcher\" ref=\"credentialsMatcher\"/>\n</bean>\n\n<!--设置加密的算法-->\n<bean class=\"org.apache.shiro.authc.credential.HashedCredentialsMatcher\"\n      id=\"credentialsMatcher\">\n    <property name=\"hashAlgorithmName\" value=\"md5\"/>\n    <property name=\"hashIterations\" value=\"1\"/>\n</bean>\n```\n\n需要注意filterChainDefinitions过滤器中对于路径的配置是有顺序的，当找到匹配的条目之后容器不会再继续寻找。因此带有通配符的路径要放在后面。三条配置的含义是： /authc/admin需要用户有用admin权限、/authc/**用户必须登录才能访问、/**其他所有路径任何人都可以访问\n\n\n## spring-mvc.xml配置\n\n```xml\n <!--配置基于注解的shiro-->\n<aop:config proxy-target-class=\"true\"/>\n<bean class=\"org.apache.shiro.spring.LifecycleBeanPostProcessor\"/>\n<bean class=\"org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor\" >\n    <property name=\"securityManager\" ref=\"securityManager\"/>\n</bean>\n```\n\n\n## 缓存机制ehcache.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<ehcache name=\"shirocache\">\n<diskStore path=\"java.io.tmpdir\" /> \n    <cache name=\"passwordRetryCache\"\n           maxEntriesLocalHeap=\"2000\"\n           eternal=\"false\"\n           timeToIdleSeconds=\"1800\"\n           timeToLiveSeconds=\"0\"\n           overflowToDisk=\"false\"\n           statistics=\"true\">\n    </cache>\n</ehcache>\n```\n\ntimeToLiveSeconds为缓存的最大生存时间，timeToIdleSeconds为缓存的最大空闲时间，当eternal为false时ttl和tti才可以生效\n## 散列算法与加密算法\n\n```xml\n    <!--设置加密的算法-->\n<bean class=\"org.apache.shiro.authc.credential.HashedCredentialsMatcher\"\n      id=\"credentialsMatcher\">\n    <property name=\"hashAlgorithmName\" value=\"md5\"/>\n    <property name=\"hashIterations\" value=\"1\"/>\n</bean>\n```\n\n## web.xml\n\n```xml\n<web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n     xmlns=\"http://java.sun.com/xml/ns/javaee\"\n     xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\"\n     id=\"WebApp_ID\" version=\"3.0\">\n<!-将Shiro的配置文件交给Spring监听器初始化->\n<context-param>\n    <param-name>contextConfigLocation</param-name>\n    <param-value>classpath*:spring/spring.xml</param-value>\n</context-param>\n\n<listener>\n    <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>\n</listener>\n\n<listener>\n    <listener-class>org.springframework.web.context.request.RequestContextListener</listener-class>\n</listener>\n\n<filter>\n    <filter-name>shiroFilter</filter-name>\n    <filter-class>org.springframework.web.filter.DelegatingFilterProxy</filter-class>\n</filter>\n\n<filter-mapping>\n    <filter-name>shiroFilter</filter-name>\n    <url-pattern>/*</url-pattern>\n</filter-mapping>\n\n<!-- The front controller of this Spring Web application, responsible for handling all application requests -->\n<servlet>\n    <servlet-name>springDispatcherServlet</servlet-name>\n    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n    <init-param>\n        <param-name>contextConfigLocation</param-name>\n        <param-value>classpath*:spring/spring-mvc.xml</param-value>\n    </init-param>\n    <load-on-startup>1</load-on-startup>\n</servlet>\n\n<!-- Map all requests to the DispatcherServlet for handling -->\n<servlet-mapping>\n    <servlet-name>springDispatcherServlet</servlet-name>\n    <url-pattern>/</url-pattern>\n</servlet-mapping>\n\n</web-app>\t\n```\n\n## 基于JDBC的自定义reaml\n\n\n```java\npublic class CustomRealm extends AuthorizingRealm {\n\n@Resource\nprivate UserDao userDao;\n\nprotected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {\n    // 获得认证数据中的用户名\n    String username = (String) principals.getPrimaryPrincipal();\n    Set<String> permissions = new HashSet<>();\n    Set<String> roles = getUserRolesByName(username);\n    for(String s:roles){\n        Set<String> tem = getUserPermissionByName(s);\n        permissions.addAll(tem);\n    }\n```\n\n\n\n```java\n    SimpleAuthorizationInfo authorizationInfo = new SimpleAuthorizationInfo();\n    authorizationInfo.setStringPermissions(permissions);\n    authorizationInfo.setRoles(roles);\n    return authorizationInfo;\n}\n\nprivate Set<String> getUserPermissionByName(String username) {\n    List<String> list = userDao.getPermissionByName(username);\n    Set<String> permission = new HashSet<String>(list);\n    return  permission;\n}\n\nprivate Set<String> getUserRolesByName(String username) {\n    List<String> list = userDao.getRolesByName(username);\n    Set<String> roles = new HashSet<String>(list);\n    return roles;\n}\n\nprotected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {\n    // 获得认证数据中的用户名\n    String username = (String) token.getPrincipal();\n\n    // 通过用户名获取数据库密码\n    String passwd = getUserPasswdByName(username);\n    if(passwd == null){\n        return null;\n    }\n    SimpleAuthenticationInfo authenticationInfo = new SimpleAuthenticationInfo(username,passwd,\"custom\");\n//设置盐为用户名        authenticationInfo.setCredentialsSalt(ByteSource.Util.bytes(username));\n    return authenticationInfo;\n}\n\nprivate String getUserPasswdByName(String name) {\n\n    User user = userDao.getUserByName(name);\n    if(user != null){\n        return user.getPassward();\n    }\n    return null;\n}\n\n//生成MD5 并加盐\npublic static void main(String[] args) {\n    Md5Hash md5Hash = new Md5Hash(\"what\",\"what\");\n    System.out.println(md5Hash.toString());\n}\n}\n```\n\n根据Shiro的设计思路，用户与角色之前的关系为多对多，角色与权限之间的关系也是多对多。在数据库中需要因此建立5张表，分别是用户表（存储用户名，密码，盐等）、角色表（角色名称，相关描述等）、权限表（权限名称，相关描述等）、用户-角色对应中间表（以用户ID和角色ID作为联合主键）、角色-权限对应中间表（以角色ID和权限ID作为联合主键）。具体dao与service的实现本文不提供。总之结论就是，Shiro需要根据用户名和密码首先判断登录的用户是否合法，然后再对合法用户授权。而这个过程就是Realm的实现过程。\n\n## Shiro会话管理\n\nshiro实现了简单的会话管理，由于自带的会话管理需要多次查询数据库，在实际项目中对性能影响过大，所以结合redis 实现会话管理时比较好的选择，当然也可以实现一个二级缓存进一步提升性能。在shiro中配置和实现如下：\n\n* spring配置文件中配置自定义sessionManagement（可以用注解方式实现）\n\n\n```xml\n    <!-自定义SessionDAO->\n\t<bean class=\"session.RedisSessionDao\" id=\"redisSessionDao\"/>\n\n\t<!-自定义SessionManager->\n\t<bean class=\"session.CustomSessionManager\" id=\"sessionManager\">\n    <property name=\"sessionDAO\" ref=\"redisSessionDao\"/>\n\t</bean>\n```\n\n* 在securityManager中添加如下属性\n\n![securitityManagement](http://epoch-night.oss-cn-hangzhou.aliyuncs.com/PostImg/securitityManagement.png)\n\n自定义Management\n\n\n```java\n/**\n * 如果用默认的DefaultWebSessionManager ，会多次从Redis中读取数据 造成资源浪费 ，所有重写retrieveSession（）方法\n * retrieveSession该方法为读取Session方法\n * 参数SessionKey 中包含request对象，所有在第一次请求时从Redis中读取，之后都从request读取\n */\npublic class CustomSessionManager extends DefaultWebSessionManager {\n    @Override\n    protected Session retrieveSession(SessionKey sessionKey) throws UnknownSessionException {\n        Serializable sessionId = getSessionId(sessionKey);\n        ServletRequest request = null;\n        if (sessionKey instanceof WebSessionKey){\n            request = ((WebSessionKey)sessionKey).getServletRequest();\n        }\n        if (request != null && sessionId != null){\n            Session session =  (Session) request.getAttribute(sessionId.toString());\n            if (session != null){\n                return session;\n            }\n        }\n        Session session = super.retrieveSession(sessionKey);\n        if(request != null && sessionId != null){\n            request.setAttribute(sessionId.toString(), session);\n        }\n        return session;\n    }\n}\n```\n\n\n​\t\n\n## 自定义Cache实现权限和角色数据缓存\n\n虽然角色缓存和权限下缓存包含的数据可能并不多，但是有效的减少了对数据库的访问次数，而且速度更快。\n\n实现Shiro 自带CacheManager 接口\n```java\n/**\n * 缓存角色和权限数据\n*/\n@Component\npublic class RedisCacheManager<K, V> implements CacheManager {\n\t@Resource\n\tprivate RedisCache redisCache;\n\n\n\t@Override\n    public <K, V> Cache<K, V> getCache(String s) throws CacheException {\n         return redisCache;\n    }\n}\n```\n\nspring 中配置如下：\n\n```xml\n<!--自定义cacheManager-->\n<bean class=\"cache.RedisCacheManager\" id=\"cacheManager\"/>\n```\n\n\n\n# 一个简单的DEMO\n\n基于Spring的实现Demo[Demo](https://github.com/Gubaidan/Shiro)\n\n\n","source":"_posts/2018-03-23-Shiro.mrkdown.md","raw":"---\nlayout: post\ntitle: \"轻量级权限管理框架之Shiro\"\ndate: 2018-03-23 12:00\nauthor: \"Gubaidan\"\nheader-img: \"\"\ncdn: 'header-on'\ntags:\n\t- web\n---\n# 关于Shiro\n\n\n\nShiro是Apache公司旗下产品，与Apache项目结合起来稳定可靠，使用灵活，可以独立于任何项目独立存在，粒度比较大，对于普通的web项目足够满足需求。与Shiro相对应的是Spring-security，Spring-security对Spring结合较好，如果项目用的springmvc，使用起来很方便。但是 如果项目中没有用到spring，那就不要考虑它了，而且粒度很细不适用于小型项目。\n\n## Shiro的总体架构：\n\n![shiro-frame.png](http://epoch-night.oss-cn-hangzhou.aliyuncs.com/PostImg/shiro-frame.png)\n\nShiro主要组件包括：Subject，SecurityManager，Authenticator，Authorizer，SessionManager，CacheManager，Cryptography，Realms\n\n* Subject表示与系统交互的对象，一般是登录系统的操作用户，也可能是另外一个软件系统\n* SecurityManager是Shiro架构最核心的组件。实际上，SecurityManager就是Shiro框架的控制器，协调其他组件一起完成认证和授权\n* Authenticator用于认证，协调一个或者多个Realm，从Realm指定的数据源取得数据之后进行执行具体的认证# Maven项目中Shiro的使用\n* Authorizer用户访问控制授权，决定用户是否拥有执行指定操作的权限\n* Shiro与生俱来就支持会话管理，这在安全类框架中都是独一无二的功能。即便不存在web容器环境，shiro都可以使用自己的会话管理机制，提供相同的会话API\n* Shiro提供了一个加解密的命令行工具jar包，需要单独下载使用。\n详见  [https://shiro.apache.org/download.html\n](https://shiro.apache.org/download.html\n)\n\n## 一个常见的登陆过程：\n\n![login](http://epoch-night.oss-cn-hangzhou.aliyuncs.com/PostImg/login.png)\n\n1）使用用户的登录信息创建令牌\n\n```java\nSubject subject = SecurityUtils.getSubject(); //获得操作主题\nUsernamePasswordToken token = new UsernamePasswordToken(user.getUsername(), user.getPassward());\n```\n\ntoken可以理解为用户令牌，登录的过程被抽象为Shiro验证令牌是否具有合法身份以及相关权限。\n\n2）执行登陆操作\n\n```java\nsubject.login(token);\n```\n\n\nShiro的核心部分是SecurityManager，它负责安全认证与授权。Shiro本身已经实现了所有的细节，用户可以完全把它当做一个黑盒来使用。SecurityUtils对象，本质上就是一个工厂类似Spring中的ApplicationContext。Subject是初学者比较难于理解的对象，很多人以为它可以等同于User，其实不然。Subject中文翻译：项目，而正确的理解也恰恰如此。它是你目前所设计的需要通过Shiro保护的项目的一个抽象概念。通过令牌（token）与项目（subject）的登陆（login）关系，Shiro保证了项目整体的安全。\n\n3）检查角色\n\n```java\nsubject.checkRole(\"admin\"); //此处admin是通过数据库得来\n```\n\n4）检查权限\n\n```java\nsubject.checkPermission(\"user:delete\"); //此处的权限信息也来自数据库\n```\n\n\n\n\n# Maven项目中使用Shiro\n\n## 在pom.xml中配置依赖包\n\n```xml\n\t<!--Shiro核心依赖-->\n\t<dependency>\n        <groupId>org.apache.shiro</groupId>\n        <artifactId>shiro-core</artifactId>\n        <version>1.4.0</version>\n    </dependency>\n    \n    <!--Shiro与spring整合包-->\n    <dependency>\n        <groupId>org.apache.shiro</groupId>\n        <artifactId>shiro-spring</artifactId>\n        <version>1.4.0</version>\n    </dependency>\n    \n    <!--Shiro web依赖包-->\n    <dependency>\n        <groupId>org.apache.shiro</groupId>\n        <artifactId>shiro-web</artifactId>\n        <version>1.4.0</version>\n    </dependency>\n```\n## 在Spring.xml中配置相关bean\n\n```xml\n    <!--shiro自带过滤器-->\n<bean id=\"shiroFilter\" class=\"org.apache.shiro.spring.web.ShiroFilterFactoryBean\">\n    <property name=\"securityManager\" ref=\"securityManager\"/>\n    <property name=\"loginUrl\" value=\"login.html\"/>\n    <property name=\"unauthorizedUrl\" value=\"403.html\"/>\n    <property name=\"filterChainDefinitions\">\n        <value>\n            /login.html = anon\n            /subLogin = anon\n            /* = authc\n        </value>\n    </property>\n</bean>\n\n<!--自定义过滤器-->\n<bean class=\"filter.RolesOrFilter\" id=\"rolesOrFilter\"/>\n```\n\n\n```xml\n<!--创建SecurityMananger对象-->\n<bean id=\"securityManager\" class=\"org.apache.shiro.web.mgt.DefaultWebSecurityManager\">\n    <!--设置自定义Realm-->\n    <property name=\"realm\" ref=\"realm\"/>\n</bean>\n\n<!--定义自定义的Realm-->\n<bean id=\"realm\" class=\"realm.CustomRealm\">\n    <property name=\"credentialsMatcher\" ref=\"credentialsMatcher\"/>\n</bean>\n\n<!--设置加密的算法-->\n<bean class=\"org.apache.shiro.authc.credential.HashedCredentialsMatcher\"\n      id=\"credentialsMatcher\">\n    <property name=\"hashAlgorithmName\" value=\"md5\"/>\n    <property name=\"hashIterations\" value=\"1\"/>\n</bean>\n```\n\n需要注意filterChainDefinitions过滤器中对于路径的配置是有顺序的，当找到匹配的条目之后容器不会再继续寻找。因此带有通配符的路径要放在后面。三条配置的含义是： /authc/admin需要用户有用admin权限、/authc/**用户必须登录才能访问、/**其他所有路径任何人都可以访问\n\n\n## spring-mvc.xml配置\n\n```xml\n <!--配置基于注解的shiro-->\n<aop:config proxy-target-class=\"true\"/>\n<bean class=\"org.apache.shiro.spring.LifecycleBeanPostProcessor\"/>\n<bean class=\"org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor\" >\n    <property name=\"securityManager\" ref=\"securityManager\"/>\n</bean>\n```\n\n\n## 缓存机制ehcache.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<ehcache name=\"shirocache\">\n<diskStore path=\"java.io.tmpdir\" /> \n    <cache name=\"passwordRetryCache\"\n           maxEntriesLocalHeap=\"2000\"\n           eternal=\"false\"\n           timeToIdleSeconds=\"1800\"\n           timeToLiveSeconds=\"0\"\n           overflowToDisk=\"false\"\n           statistics=\"true\">\n    </cache>\n</ehcache>\n```\n\ntimeToLiveSeconds为缓存的最大生存时间，timeToIdleSeconds为缓存的最大空闲时间，当eternal为false时ttl和tti才可以生效\n## 散列算法与加密算法\n\n```xml\n    <!--设置加密的算法-->\n<bean class=\"org.apache.shiro.authc.credential.HashedCredentialsMatcher\"\n      id=\"credentialsMatcher\">\n    <property name=\"hashAlgorithmName\" value=\"md5\"/>\n    <property name=\"hashIterations\" value=\"1\"/>\n</bean>\n```\n\n## web.xml\n\n```xml\n<web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n     xmlns=\"http://java.sun.com/xml/ns/javaee\"\n     xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\"\n     id=\"WebApp_ID\" version=\"3.0\">\n<!-将Shiro的配置文件交给Spring监听器初始化->\n<context-param>\n    <param-name>contextConfigLocation</param-name>\n    <param-value>classpath*:spring/spring.xml</param-value>\n</context-param>\n\n<listener>\n    <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>\n</listener>\n\n<listener>\n    <listener-class>org.springframework.web.context.request.RequestContextListener</listener-class>\n</listener>\n\n<filter>\n    <filter-name>shiroFilter</filter-name>\n    <filter-class>org.springframework.web.filter.DelegatingFilterProxy</filter-class>\n</filter>\n\n<filter-mapping>\n    <filter-name>shiroFilter</filter-name>\n    <url-pattern>/*</url-pattern>\n</filter-mapping>\n\n<!-- The front controller of this Spring Web application, responsible for handling all application requests -->\n<servlet>\n    <servlet-name>springDispatcherServlet</servlet-name>\n    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n    <init-param>\n        <param-name>contextConfigLocation</param-name>\n        <param-value>classpath*:spring/spring-mvc.xml</param-value>\n    </init-param>\n    <load-on-startup>1</load-on-startup>\n</servlet>\n\n<!-- Map all requests to the DispatcherServlet for handling -->\n<servlet-mapping>\n    <servlet-name>springDispatcherServlet</servlet-name>\n    <url-pattern>/</url-pattern>\n</servlet-mapping>\n\n</web-app>\t\n```\n\n## 基于JDBC的自定义reaml\n\n\n```java\npublic class CustomRealm extends AuthorizingRealm {\n\n@Resource\nprivate UserDao userDao;\n\nprotected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {\n    // 获得认证数据中的用户名\n    String username = (String) principals.getPrimaryPrincipal();\n    Set<String> permissions = new HashSet<>();\n    Set<String> roles = getUserRolesByName(username);\n    for(String s:roles){\n        Set<String> tem = getUserPermissionByName(s);\n        permissions.addAll(tem);\n    }\n```\n\n\n\n```java\n    SimpleAuthorizationInfo authorizationInfo = new SimpleAuthorizationInfo();\n    authorizationInfo.setStringPermissions(permissions);\n    authorizationInfo.setRoles(roles);\n    return authorizationInfo;\n}\n\nprivate Set<String> getUserPermissionByName(String username) {\n    List<String> list = userDao.getPermissionByName(username);\n    Set<String> permission = new HashSet<String>(list);\n    return  permission;\n}\n\nprivate Set<String> getUserRolesByName(String username) {\n    List<String> list = userDao.getRolesByName(username);\n    Set<String> roles = new HashSet<String>(list);\n    return roles;\n}\n\nprotected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {\n    // 获得认证数据中的用户名\n    String username = (String) token.getPrincipal();\n\n    // 通过用户名获取数据库密码\n    String passwd = getUserPasswdByName(username);\n    if(passwd == null){\n        return null;\n    }\n    SimpleAuthenticationInfo authenticationInfo = new SimpleAuthenticationInfo(username,passwd,\"custom\");\n//设置盐为用户名        authenticationInfo.setCredentialsSalt(ByteSource.Util.bytes(username));\n    return authenticationInfo;\n}\n\nprivate String getUserPasswdByName(String name) {\n\n    User user = userDao.getUserByName(name);\n    if(user != null){\n        return user.getPassward();\n    }\n    return null;\n}\n\n//生成MD5 并加盐\npublic static void main(String[] args) {\n    Md5Hash md5Hash = new Md5Hash(\"what\",\"what\");\n    System.out.println(md5Hash.toString());\n}\n}\n```\n\n根据Shiro的设计思路，用户与角色之前的关系为多对多，角色与权限之间的关系也是多对多。在数据库中需要因此建立5张表，分别是用户表（存储用户名，密码，盐等）、角色表（角色名称，相关描述等）、权限表（权限名称，相关描述等）、用户-角色对应中间表（以用户ID和角色ID作为联合主键）、角色-权限对应中间表（以角色ID和权限ID作为联合主键）。具体dao与service的实现本文不提供。总之结论就是，Shiro需要根据用户名和密码首先判断登录的用户是否合法，然后再对合法用户授权。而这个过程就是Realm的实现过程。\n\n## Shiro会话管理\n\nshiro实现了简单的会话管理，由于自带的会话管理需要多次查询数据库，在实际项目中对性能影响过大，所以结合redis 实现会话管理时比较好的选择，当然也可以实现一个二级缓存进一步提升性能。在shiro中配置和实现如下：\n\n* spring配置文件中配置自定义sessionManagement（可以用注解方式实现）\n\n\n```xml\n    <!-自定义SessionDAO->\n\t<bean class=\"session.RedisSessionDao\" id=\"redisSessionDao\"/>\n\n\t<!-自定义SessionManager->\n\t<bean class=\"session.CustomSessionManager\" id=\"sessionManager\">\n    <property name=\"sessionDAO\" ref=\"redisSessionDao\"/>\n\t</bean>\n```\n\n* 在securityManager中添加如下属性\n\n![securitityManagement](http://epoch-night.oss-cn-hangzhou.aliyuncs.com/PostImg/securitityManagement.png)\n\n自定义Management\n\n\n```java\n/**\n * 如果用默认的DefaultWebSessionManager ，会多次从Redis中读取数据 造成资源浪费 ，所有重写retrieveSession（）方法\n * retrieveSession该方法为读取Session方法\n * 参数SessionKey 中包含request对象，所有在第一次请求时从Redis中读取，之后都从request读取\n */\npublic class CustomSessionManager extends DefaultWebSessionManager {\n    @Override\n    protected Session retrieveSession(SessionKey sessionKey) throws UnknownSessionException {\n        Serializable sessionId = getSessionId(sessionKey);\n        ServletRequest request = null;\n        if (sessionKey instanceof WebSessionKey){\n            request = ((WebSessionKey)sessionKey).getServletRequest();\n        }\n        if (request != null && sessionId != null){\n            Session session =  (Session) request.getAttribute(sessionId.toString());\n            if (session != null){\n                return session;\n            }\n        }\n        Session session = super.retrieveSession(sessionKey);\n        if(request != null && sessionId != null){\n            request.setAttribute(sessionId.toString(), session);\n        }\n        return session;\n    }\n}\n```\n\n\n​\t\n\n## 自定义Cache实现权限和角色数据缓存\n\n虽然角色缓存和权限下缓存包含的数据可能并不多，但是有效的减少了对数据库的访问次数，而且速度更快。\n\n实现Shiro 自带CacheManager 接口\n```java\n/**\n * 缓存角色和权限数据\n*/\n@Component\npublic class RedisCacheManager<K, V> implements CacheManager {\n\t@Resource\n\tprivate RedisCache redisCache;\n\n\n\t@Override\n    public <K, V> Cache<K, V> getCache(String s) throws CacheException {\n         return redisCache;\n    }\n}\n```\n\nspring 中配置如下：\n\n```xml\n<!--自定义cacheManager-->\n<bean class=\"cache.RedisCacheManager\" id=\"cacheManager\"/>\n```\n\n\n\n# 一个简单的DEMO\n\n基于Spring的实现Demo[Demo](https://github.com/Gubaidan/Shiro)\n\n\n","slug":"2018-03-23-Shiro.mrkdown","published":1,"updated":"2019-05-05T12:42:26.518Z","comments":1,"photos":[],"link":"","_id":"cjvayvwgd0026m46aacrrs2ii","content":"<h1 id=\"关于Shiro\"><a href=\"#关于Shiro\" class=\"headerlink\" title=\"关于Shiro\"></a>关于Shiro</h1><p>Shiro是Apache公司旗下产品，与Apache项目结合起来稳定可靠，使用灵活，可以独立于任何项目独立存在，粒度比较大，对于普通的web项目足够满足需求。与Shiro相对应的是Spring-security，Spring-security对Spring结合较好，如果项目用的springmvc，使用起来很方便。但是 如果项目中没有用到spring，那就不要考虑它了，而且粒度很细不适用于小型项目。</p>\n<h2 id=\"Shiro的总体架构：\"><a href=\"#Shiro的总体架构：\" class=\"headerlink\" title=\"Shiro的总体架构：\"></a>Shiro的总体架构：</h2><p><img src=\"http://epoch-night.oss-cn-hangzhou.aliyuncs.com/PostImg/shiro-frame.png\" alt=\"shiro-frame.png\"></p>\n<p>Shiro主要组件包括：Subject，SecurityManager，Authenticator，Authorizer，SessionManager，CacheManager，Cryptography，Realms</p>\n<ul>\n<li>Subject表示与系统交互的对象，一般是登录系统的操作用户，也可能是另外一个软件系统</li>\n<li>SecurityManager是Shiro架构最核心的组件。实际上，SecurityManager就是Shiro框架的控制器，协调其他组件一起完成认证和授权</li>\n<li>Authenticator用于认证，协调一个或者多个Realm，从Realm指定的数据源取得数据之后进行执行具体的认证# Maven项目中Shiro的使用</li>\n<li>Authorizer用户访问控制授权，决定用户是否拥有执行指定操作的权限</li>\n<li>Shiro与生俱来就支持会话管理，这在安全类框架中都是独一无二的功能。即便不存在web容器环境，shiro都可以使用自己的会话管理机制，提供相同的会话API</li>\n<li>Shiro提供了一个加解密的命令行工具jar包，需要单独下载使用。<br>详见  <a href=\"https://shiro.apache.org/download.html\" target=\"_blank\" rel=\"noopener\">https://shiro.apache.org/download.html\n</a></li>\n</ul>\n<h2 id=\"一个常见的登陆过程：\"><a href=\"#一个常见的登陆过程：\" class=\"headerlink\" title=\"一个常见的登陆过程：\"></a>一个常见的登陆过程：</h2><p><img src=\"http://epoch-night.oss-cn-hangzhou.aliyuncs.com/PostImg/login.png\" alt=\"login\"></p>\n<p>1）使用用户的登录信息创建令牌</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Subject subject = SecurityUtils.getSubject(); <span class=\"comment\">//获得操作主题</span></span><br><span class=\"line\">UsernamePasswordToken token = <span class=\"keyword\">new</span> UsernamePasswordToken(user.getUsername(), user.getPassward());</span><br></pre></td></tr></table></figure>\n<p>token可以理解为用户令牌，登录的过程被抽象为Shiro验证令牌是否具有合法身份以及相关权限。</p>\n<p>2）执行登陆操作</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">subject.login(token);</span><br></pre></td></tr></table></figure>\n<p>Shiro的核心部分是SecurityManager，它负责安全认证与授权。Shiro本身已经实现了所有的细节，用户可以完全把它当做一个黑盒来使用。SecurityUtils对象，本质上就是一个工厂类似Spring中的ApplicationContext。Subject是初学者比较难于理解的对象，很多人以为它可以等同于User，其实不然。Subject中文翻译：项目，而正确的理解也恰恰如此。它是你目前所设计的需要通过Shiro保护的项目的一个抽象概念。通过令牌（token）与项目（subject）的登陆（login）关系，Shiro保证了项目整体的安全。</p>\n<p>3）检查角色</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">subject.checkRole(<span class=\"string\">\"admin\"</span>); <span class=\"comment\">//此处admin是通过数据库得来</span></span><br></pre></td></tr></table></figure>\n<p>4）检查权限</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">subject.checkPermission(<span class=\"string\">\"user:delete\"</span>); <span class=\"comment\">//此处的权限信息也来自数据库</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"Maven项目中使用Shiro\"><a href=\"#Maven项目中使用Shiro\" class=\"headerlink\" title=\"Maven项目中使用Shiro\"></a>Maven项目中使用Shiro</h1><h2 id=\"在pom-xml中配置依赖包\"><a href=\"#在pom-xml中配置依赖包\" class=\"headerlink\" title=\"在pom.xml中配置依赖包\"></a>在pom.xml中配置依赖包</h2><figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--Shiro核心依赖--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.shiro<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>shiro-core<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.4.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"comment\">&lt;!--Shiro与spring整合包--&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.shiro<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>shiro-spring<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.4.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"comment\">&lt;!--Shiro web依赖包--&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.shiro<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>shiro-web<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.4.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"在Spring-xml中配置相关bean\"><a href=\"#在Spring-xml中配置相关bean\" class=\"headerlink\" title=\"在Spring.xml中配置相关bean\"></a>在Spring.xml中配置相关bean</h2><figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\">    <span class=\"comment\">&lt;!--shiro自带过滤器--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"shiroFilter\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.apache.shiro.spring.web.ShiroFilterFactoryBean\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"securityManager\"</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"securityManager\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"loginUrl\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"login.html\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"unauthorizedUrl\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"403.html\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"filterChainDefinitions\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">            /login.html = anon</span><br><span class=\"line\">            /subLogin = anon</span><br><span class=\"line\">            /* = authc</span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!--自定义过滤器--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">\"filter.RolesOrFilter\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"rolesOrFilter\"</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--创建SecurityMananger对象--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"securityManager\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.apache.shiro.web.mgt.DefaultWebSecurityManager\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--设置自定义Realm--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"realm\"</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"realm\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!--定义自定义的Realm--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"realm\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"realm.CustomRealm\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"credentialsMatcher\"</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"credentialsMatcher\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!--设置加密的算法--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.apache.shiro.authc.credential.HashedCredentialsMatcher\"</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">id</span>=<span class=\"string\">\"credentialsMatcher\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"hashAlgorithmName\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"md5\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"hashIterations\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"1\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>需要注意filterChainDefinitions过滤器中对于路径的配置是有顺序的，当找到匹配的条目之后容器不会再继续寻找。因此带有通配符的路径要放在后面。三条配置的含义是： /authc/admin需要用户有用admin权限、/authc/<strong>用户必须登录才能访问、/</strong>其他所有路径任何人都可以访问</p>\n<h2 id=\"spring-mvc-xml配置\"><a href=\"#spring-mvc-xml配置\" class=\"headerlink\" title=\"spring-mvc.xml配置\"></a>spring-mvc.xml配置</h2><figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">&lt;!--配置基于注解的shiro--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">aop:config</span> <span class=\"attr\">proxy-target-class</span>=<span class=\"string\">\"true\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.apache.shiro.spring.LifecycleBeanPostProcessor\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor\"</span> &gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"securityManager\"</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"securityManager\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"缓存机制ehcache-xml\"><a href=\"#缓存机制ehcache-xml\" class=\"headerlink\" title=\"缓存机制ehcache.xml\"></a>缓存机制ehcache.xml</h2><figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ehcache</span> <span class=\"attr\">name</span>=<span class=\"string\">\"shirocache\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">diskStore</span> <span class=\"attr\">path</span>=<span class=\"string\">\"java.io.tmpdir\"</span> /&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">cache</span> <span class=\"attr\">name</span>=<span class=\"string\">\"passwordRetryCache\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">maxEntriesLocalHeap</span>=<span class=\"string\">\"2000\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">eternal</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">timeToIdleSeconds</span>=<span class=\"string\">\"1800\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">timeToLiveSeconds</span>=<span class=\"string\">\"0\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">overflowToDisk</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">statistics</span>=<span class=\"string\">\"true\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">cache</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ehcache</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>timeToLiveSeconds为缓存的最大生存时间，timeToIdleSeconds为缓存的最大空闲时间，当eternal为false时ttl和tti才可以生效</p>\n<h2 id=\"散列算法与加密算法\"><a href=\"#散列算法与加密算法\" class=\"headerlink\" title=\"散列算法与加密算法\"></a>散列算法与加密算法</h2><figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\">    <span class=\"comment\">&lt;!--设置加密的算法--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.apache.shiro.authc.credential.HashedCredentialsMatcher\"</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">id</span>=<span class=\"string\">\"credentialsMatcher\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"hashAlgorithmName\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"md5\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"hashIterations\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"1\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"web-xml\"><a href=\"#web-xml\" class=\"headerlink\" title=\"web.xml\"></a>web.xml</h2><figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">web-app</span> <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span></span><br><span class=\"line\"><span class=\"tag\">     <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://java.sun.com/xml/ns/javaee\"</span></span></span><br><span class=\"line\"><span class=\"tag\">     <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\"</span></span></span><br><span class=\"line\"><span class=\"tag\">     <span class=\"attr\">id</span>=<span class=\"string\">\"WebApp_ID\"</span> <span class=\"attr\">version</span>=<span class=\"string\">\"3.0\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">!-将Shiro的配置文件交给Spring监听器初始化-</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">context-param</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>contextConfigLocation<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>classpath*:spring/spring.xml<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">context-param</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">listener</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class=\"tag\">&lt;/<span class=\"name\">listener-class</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">listener</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">listener</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">listener-class</span>&gt;</span>org.springframework.web.context.request.RequestContextListener<span class=\"tag\">&lt;/<span class=\"name\">listener-class</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">listener</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">filter</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>shiroFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter-class</span>&gt;</span>org.springframework.web.filter.DelegatingFilterProxy<span class=\"tag\">&lt;/<span class=\"name\">filter-class</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">filter</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">filter-mapping</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>shiroFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/*<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">filter-mapping</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- The front controller of this Spring Web application, responsible for handling all application requests --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>springDispatcherServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>contextConfigLocation<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>classpath*:spring/spring-mvc.xml<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">load-on-startup</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">load-on-startup</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- Map all requests to the DispatcherServlet for handling --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>springDispatcherServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"基于JDBC的自定义reaml\"><a href=\"#基于JDBC的自定义reaml\" class=\"headerlink\" title=\"基于JDBC的自定义reaml\"></a>基于JDBC的自定义reaml</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CustomRealm</span> <span class=\"keyword\">extends</span> <span class=\"title\">AuthorizingRealm</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Resource</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> UserDao userDao;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> AuthorizationInfo <span class=\"title\">doGetAuthorizationInfo</span><span class=\"params\">(PrincipalCollection principals)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获得认证数据中的用户名</span></span><br><span class=\"line\">    String username = (String) principals.getPrimaryPrincipal();</span><br><span class=\"line\">    Set&lt;String&gt; permissions = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\">    Set&lt;String&gt; roles = getUserRolesByName(username);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(String s:roles)&#123;</span><br><span class=\"line\">        Set&lt;String&gt; tem = getUserPermissionByName(s);</span><br><span class=\"line\">        permissions.addAll(tem);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">    SimpleAuthorizationInfo authorizationInfo = <span class=\"keyword\">new</span> SimpleAuthorizationInfo();</span><br><span class=\"line\">    authorizationInfo.setStringPermissions(permissions);</span><br><span class=\"line\">    authorizationInfo.setRoles(roles);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> authorizationInfo;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Set&lt;String&gt; <span class=\"title\">getUserPermissionByName</span><span class=\"params\">(String username)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;String&gt; list = userDao.getPermissionByName(username);</span><br><span class=\"line\">    Set&lt;String&gt; permission = <span class=\"keyword\">new</span> HashSet&lt;String&gt;(list);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>  permission;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Set&lt;String&gt; <span class=\"title\">getUserRolesByName</span><span class=\"params\">(String username)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;String&gt; list = userDao.getRolesByName(username);</span><br><span class=\"line\">    Set&lt;String&gt; roles = <span class=\"keyword\">new</span> HashSet&lt;String&gt;(list);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> roles;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> AuthenticationInfo <span class=\"title\">doGetAuthenticationInfo</span><span class=\"params\">(AuthenticationToken token)</span> <span class=\"keyword\">throws</span> AuthenticationException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获得认证数据中的用户名</span></span><br><span class=\"line\">    String username = (String) token.getPrincipal();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 通过用户名获取数据库密码</span></span><br><span class=\"line\">    String passwd = getUserPasswdByName(username);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(passwd == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    SimpleAuthenticationInfo authenticationInfo = <span class=\"keyword\">new</span> SimpleAuthenticationInfo(username,passwd,<span class=\"string\">\"custom\"</span>);</span><br><span class=\"line\"><span class=\"comment\">//设置盐为用户名        authenticationInfo.setCredentialsSalt(ByteSource.Util.bytes(username));</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> authenticationInfo;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> String <span class=\"title\">getUserPasswdByName</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    User user = userDao.getUserByName(name);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(user != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> user.getPassward();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//生成MD5 并加盐</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    Md5Hash md5Hash = <span class=\"keyword\">new</span> Md5Hash(<span class=\"string\">\"what\"</span>,<span class=\"string\">\"what\"</span>);</span><br><span class=\"line\">    System.out.println(md5Hash.toString());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>根据Shiro的设计思路，用户与角色之前的关系为多对多，角色与权限之间的关系也是多对多。在数据库中需要因此建立5张表，分别是用户表（存储用户名，密码，盐等）、角色表（角色名称，相关描述等）、权限表（权限名称，相关描述等）、用户-角色对应中间表（以用户ID和角色ID作为联合主键）、角色-权限对应中间表（以角色ID和权限ID作为联合主键）。具体dao与service的实现本文不提供。总之结论就是，Shiro需要根据用户名和密码首先判断登录的用户是否合法，然后再对合法用户授权。而这个过程就是Realm的实现过程。</p>\n<h2 id=\"Shiro会话管理\"><a href=\"#Shiro会话管理\" class=\"headerlink\" title=\"Shiro会话管理\"></a>Shiro会话管理</h2><p>shiro实现了简单的会话管理，由于自带的会话管理需要多次查询数据库，在实际项目中对性能影响过大，所以结合redis 实现会话管理时比较好的选择，当然也可以实现一个二级缓存进一步提升性能。在shiro中配置和实现如下：</p>\n<ul>\n<li>spring配置文件中配置自定义sessionManagement（可以用注解方式实现）</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">!-自定义SessionDAO-</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">\"session.RedisSessionDao\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"redisSessionDao\"</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">!-自定义SessionManager-</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">\"session.CustomSessionManager\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"sessionManager\"</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"sessionDAO\"</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"redisSessionDao\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>在securityManager中添加如下属性</li>\n</ul>\n<p><img src=\"http://epoch-night.oss-cn-hangzhou.aliyuncs.com/PostImg/securitityManagement.png\" alt=\"securitityManagement\"></p>\n<p>自定义Management</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 如果用默认的DefaultWebSessionManager ，会多次从Redis中读取数据 造成资源浪费 ，所有重写retrieveSession（）方法</span></span><br><span class=\"line\"><span class=\"comment\"> * retrieveSession该方法为读取Session方法</span></span><br><span class=\"line\"><span class=\"comment\"> * 参数SessionKey 中包含request对象，所有在第一次请求时从Redis中读取，之后都从request读取</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CustomSessionManager</span> <span class=\"keyword\">extends</span> <span class=\"title\">DefaultWebSessionManager</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> Session <span class=\"title\">retrieveSession</span><span class=\"params\">(SessionKey sessionKey)</span> <span class=\"keyword\">throws</span> UnknownSessionException </span>&#123;</span><br><span class=\"line\">        Serializable sessionId = getSessionId(sessionKey);</span><br><span class=\"line\">        ServletRequest request = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sessionKey <span class=\"keyword\">instanceof</span> WebSessionKey)&#123;</span><br><span class=\"line\">            request = ((WebSessionKey)sessionKey).getServletRequest();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (request != <span class=\"keyword\">null</span> &amp;&amp; sessionId != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            Session session =  (Session) request.getAttribute(sessionId.toString());</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (session != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> session;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Session session = <span class=\"keyword\">super</span>.retrieveSession(sessionKey);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(request != <span class=\"keyword\">null</span> &amp;&amp; sessionId != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            request.setAttribute(sessionId.toString(), session);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> session;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>​    </p>\n<h2 id=\"自定义Cache实现权限和角色数据缓存\"><a href=\"#自定义Cache实现权限和角色数据缓存\" class=\"headerlink\" title=\"自定义Cache实现权限和角色数据缓存\"></a>自定义Cache实现权限和角色数据缓存</h2><p>虽然角色缓存和权限下缓存包含的数据可能并不多，但是有效的减少了对数据库的访问次数，而且速度更快。</p>\n<p>实现Shiro 自带CacheManager 接口<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 缓存角色和权限数据</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RedisCacheManager</span>&lt;<span class=\"title\">K</span>, <span class=\"title\">V</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">CacheManager</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Resource</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> RedisCache redisCache;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> &lt;K, V&gt; <span class=\"function\">Cache&lt;K, V&gt; <span class=\"title\">getCache</span><span class=\"params\">(String s)</span> <span class=\"keyword\">throws</span> CacheException </span>&#123;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> redisCache;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>spring 中配置如下：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--自定义cacheManager--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">\"cache.RedisCacheManager\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"cacheManager\"</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"一个简单的DEMO\"><a href=\"#一个简单的DEMO\" class=\"headerlink\" title=\"一个简单的DEMO\"></a>一个简单的DEMO</h1><p>基于Spring的实现Demo<a href=\"https://github.com/Gubaidan/Shiro\" target=\"_blank\" rel=\"noopener\">Demo</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"关于Shiro\"><a href=\"#关于Shiro\" class=\"headerlink\" title=\"关于Shiro\"></a>关于Shiro</h1><p>Shiro是Apache公司旗下产品，与Apache项目结合起来稳定可靠，使用灵活，可以独立于任何项目独立存在，粒度比较大，对于普通的web项目足够满足需求。与Shiro相对应的是Spring-security，Spring-security对Spring结合较好，如果项目用的springmvc，使用起来很方便。但是 如果项目中没有用到spring，那就不要考虑它了，而且粒度很细不适用于小型项目。</p>\n<h2 id=\"Shiro的总体架构：\"><a href=\"#Shiro的总体架构：\" class=\"headerlink\" title=\"Shiro的总体架构：\"></a>Shiro的总体架构：</h2><p><img src=\"http://epoch-night.oss-cn-hangzhou.aliyuncs.com/PostImg/shiro-frame.png\" alt=\"shiro-frame.png\"></p>\n<p>Shiro主要组件包括：Subject，SecurityManager，Authenticator，Authorizer，SessionManager，CacheManager，Cryptography，Realms</p>\n<ul>\n<li>Subject表示与系统交互的对象，一般是登录系统的操作用户，也可能是另外一个软件系统</li>\n<li>SecurityManager是Shiro架构最核心的组件。实际上，SecurityManager就是Shiro框架的控制器，协调其他组件一起完成认证和授权</li>\n<li>Authenticator用于认证，协调一个或者多个Realm，从Realm指定的数据源取得数据之后进行执行具体的认证# Maven项目中Shiro的使用</li>\n<li>Authorizer用户访问控制授权，决定用户是否拥有执行指定操作的权限</li>\n<li>Shiro与生俱来就支持会话管理，这在安全类框架中都是独一无二的功能。即便不存在web容器环境，shiro都可以使用自己的会话管理机制，提供相同的会话API</li>\n<li>Shiro提供了一个加解密的命令行工具jar包，需要单独下载使用。<br>详见  <a href=\"https://shiro.apache.org/download.html\" target=\"_blank\" rel=\"noopener\">https://shiro.apache.org/download.html\n</a></li>\n</ul>\n<h2 id=\"一个常见的登陆过程：\"><a href=\"#一个常见的登陆过程：\" class=\"headerlink\" title=\"一个常见的登陆过程：\"></a>一个常见的登陆过程：</h2><p><img src=\"http://epoch-night.oss-cn-hangzhou.aliyuncs.com/PostImg/login.png\" alt=\"login\"></p>\n<p>1）使用用户的登录信息创建令牌</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Subject subject = SecurityUtils.getSubject(); <span class=\"comment\">//获得操作主题</span></span><br><span class=\"line\">UsernamePasswordToken token = <span class=\"keyword\">new</span> UsernamePasswordToken(user.getUsername(), user.getPassward());</span><br></pre></td></tr></table></figure>\n<p>token可以理解为用户令牌，登录的过程被抽象为Shiro验证令牌是否具有合法身份以及相关权限。</p>\n<p>2）执行登陆操作</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">subject.login(token);</span><br></pre></td></tr></table></figure>\n<p>Shiro的核心部分是SecurityManager，它负责安全认证与授权。Shiro本身已经实现了所有的细节，用户可以完全把它当做一个黑盒来使用。SecurityUtils对象，本质上就是一个工厂类似Spring中的ApplicationContext。Subject是初学者比较难于理解的对象，很多人以为它可以等同于User，其实不然。Subject中文翻译：项目，而正确的理解也恰恰如此。它是你目前所设计的需要通过Shiro保护的项目的一个抽象概念。通过令牌（token）与项目（subject）的登陆（login）关系，Shiro保证了项目整体的安全。</p>\n<p>3）检查角色</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">subject.checkRole(<span class=\"string\">\"admin\"</span>); <span class=\"comment\">//此处admin是通过数据库得来</span></span><br></pre></td></tr></table></figure>\n<p>4）检查权限</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">subject.checkPermission(<span class=\"string\">\"user:delete\"</span>); <span class=\"comment\">//此处的权限信息也来自数据库</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"Maven项目中使用Shiro\"><a href=\"#Maven项目中使用Shiro\" class=\"headerlink\" title=\"Maven项目中使用Shiro\"></a>Maven项目中使用Shiro</h1><h2 id=\"在pom-xml中配置依赖包\"><a href=\"#在pom-xml中配置依赖包\" class=\"headerlink\" title=\"在pom.xml中配置依赖包\"></a>在pom.xml中配置依赖包</h2><figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--Shiro核心依赖--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.shiro<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>shiro-core<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.4.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"comment\">&lt;!--Shiro与spring整合包--&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.shiro<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>shiro-spring<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.4.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"comment\">&lt;!--Shiro web依赖包--&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.shiro<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>shiro-web<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.4.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"在Spring-xml中配置相关bean\"><a href=\"#在Spring-xml中配置相关bean\" class=\"headerlink\" title=\"在Spring.xml中配置相关bean\"></a>在Spring.xml中配置相关bean</h2><figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\">    <span class=\"comment\">&lt;!--shiro自带过滤器--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"shiroFilter\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.apache.shiro.spring.web.ShiroFilterFactoryBean\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"securityManager\"</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"securityManager\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"loginUrl\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"login.html\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"unauthorizedUrl\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"403.html\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"filterChainDefinitions\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">            /login.html = anon</span><br><span class=\"line\">            /subLogin = anon</span><br><span class=\"line\">            /* = authc</span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!--自定义过滤器--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">\"filter.RolesOrFilter\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"rolesOrFilter\"</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--创建SecurityMananger对象--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"securityManager\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.apache.shiro.web.mgt.DefaultWebSecurityManager\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--设置自定义Realm--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"realm\"</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"realm\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!--定义自定义的Realm--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"realm\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"realm.CustomRealm\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"credentialsMatcher\"</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"credentialsMatcher\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!--设置加密的算法--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.apache.shiro.authc.credential.HashedCredentialsMatcher\"</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">id</span>=<span class=\"string\">\"credentialsMatcher\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"hashAlgorithmName\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"md5\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"hashIterations\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"1\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>需要注意filterChainDefinitions过滤器中对于路径的配置是有顺序的，当找到匹配的条目之后容器不会再继续寻找。因此带有通配符的路径要放在后面。三条配置的含义是： /authc/admin需要用户有用admin权限、/authc/<strong>用户必须登录才能访问、/</strong>其他所有路径任何人都可以访问</p>\n<h2 id=\"spring-mvc-xml配置\"><a href=\"#spring-mvc-xml配置\" class=\"headerlink\" title=\"spring-mvc.xml配置\"></a>spring-mvc.xml配置</h2><figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">&lt;!--配置基于注解的shiro--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">aop:config</span> <span class=\"attr\">proxy-target-class</span>=<span class=\"string\">\"true\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.apache.shiro.spring.LifecycleBeanPostProcessor\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor\"</span> &gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"securityManager\"</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"securityManager\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"缓存机制ehcache-xml\"><a href=\"#缓存机制ehcache-xml\" class=\"headerlink\" title=\"缓存机制ehcache.xml\"></a>缓存机制ehcache.xml</h2><figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ehcache</span> <span class=\"attr\">name</span>=<span class=\"string\">\"shirocache\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">diskStore</span> <span class=\"attr\">path</span>=<span class=\"string\">\"java.io.tmpdir\"</span> /&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">cache</span> <span class=\"attr\">name</span>=<span class=\"string\">\"passwordRetryCache\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">maxEntriesLocalHeap</span>=<span class=\"string\">\"2000\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">eternal</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">timeToIdleSeconds</span>=<span class=\"string\">\"1800\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">timeToLiveSeconds</span>=<span class=\"string\">\"0\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">overflowToDisk</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">           <span class=\"attr\">statistics</span>=<span class=\"string\">\"true\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">cache</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ehcache</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>timeToLiveSeconds为缓存的最大生存时间，timeToIdleSeconds为缓存的最大空闲时间，当eternal为false时ttl和tti才可以生效</p>\n<h2 id=\"散列算法与加密算法\"><a href=\"#散列算法与加密算法\" class=\"headerlink\" title=\"散列算法与加密算法\"></a>散列算法与加密算法</h2><figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\">    <span class=\"comment\">&lt;!--设置加密的算法--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.apache.shiro.authc.credential.HashedCredentialsMatcher\"</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">id</span>=<span class=\"string\">\"credentialsMatcher\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"hashAlgorithmName\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"md5\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"hashIterations\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"1\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"web-xml\"><a href=\"#web-xml\" class=\"headerlink\" title=\"web.xml\"></a>web.xml</h2><figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">web-app</span> <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span></span><br><span class=\"line\"><span class=\"tag\">     <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://java.sun.com/xml/ns/javaee\"</span></span></span><br><span class=\"line\"><span class=\"tag\">     <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\"</span></span></span><br><span class=\"line\"><span class=\"tag\">     <span class=\"attr\">id</span>=<span class=\"string\">\"WebApp_ID\"</span> <span class=\"attr\">version</span>=<span class=\"string\">\"3.0\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">!-将Shiro的配置文件交给Spring监听器初始化-</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">context-param</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>contextConfigLocation<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>classpath*:spring/spring.xml<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">context-param</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">listener</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class=\"tag\">&lt;/<span class=\"name\">listener-class</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">listener</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">listener</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">listener-class</span>&gt;</span>org.springframework.web.context.request.RequestContextListener<span class=\"tag\">&lt;/<span class=\"name\">listener-class</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">listener</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">filter</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>shiroFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter-class</span>&gt;</span>org.springframework.web.filter.DelegatingFilterProxy<span class=\"tag\">&lt;/<span class=\"name\">filter-class</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">filter</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">filter-mapping</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>shiroFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/*<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">filter-mapping</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- The front controller of this Spring Web application, responsible for handling all application requests --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>springDispatcherServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>contextConfigLocation<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>classpath*:spring/spring-mvc.xml<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">load-on-startup</span>&gt;</span>1<span class=\"tag\">&lt;/<span class=\"name\">load-on-startup</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- Map all requests to the DispatcherServlet for handling --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>springDispatcherServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"基于JDBC的自定义reaml\"><a href=\"#基于JDBC的自定义reaml\" class=\"headerlink\" title=\"基于JDBC的自定义reaml\"></a>基于JDBC的自定义reaml</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CustomRealm</span> <span class=\"keyword\">extends</span> <span class=\"title\">AuthorizingRealm</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Resource</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> UserDao userDao;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> AuthorizationInfo <span class=\"title\">doGetAuthorizationInfo</span><span class=\"params\">(PrincipalCollection principals)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获得认证数据中的用户名</span></span><br><span class=\"line\">    String username = (String) principals.getPrimaryPrincipal();</span><br><span class=\"line\">    Set&lt;String&gt; permissions = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\">    Set&lt;String&gt; roles = getUserRolesByName(username);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(String s:roles)&#123;</span><br><span class=\"line\">        Set&lt;String&gt; tem = getUserPermissionByName(s);</span><br><span class=\"line\">        permissions.addAll(tem);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">    SimpleAuthorizationInfo authorizationInfo = <span class=\"keyword\">new</span> SimpleAuthorizationInfo();</span><br><span class=\"line\">    authorizationInfo.setStringPermissions(permissions);</span><br><span class=\"line\">    authorizationInfo.setRoles(roles);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> authorizationInfo;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Set&lt;String&gt; <span class=\"title\">getUserPermissionByName</span><span class=\"params\">(String username)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;String&gt; list = userDao.getPermissionByName(username);</span><br><span class=\"line\">    Set&lt;String&gt; permission = <span class=\"keyword\">new</span> HashSet&lt;String&gt;(list);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>  permission;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Set&lt;String&gt; <span class=\"title\">getUserRolesByName</span><span class=\"params\">(String username)</span> </span>&#123;</span><br><span class=\"line\">    List&lt;String&gt; list = userDao.getRolesByName(username);</span><br><span class=\"line\">    Set&lt;String&gt; roles = <span class=\"keyword\">new</span> HashSet&lt;String&gt;(list);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> roles;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> AuthenticationInfo <span class=\"title\">doGetAuthenticationInfo</span><span class=\"params\">(AuthenticationToken token)</span> <span class=\"keyword\">throws</span> AuthenticationException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获得认证数据中的用户名</span></span><br><span class=\"line\">    String username = (String) token.getPrincipal();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 通过用户名获取数据库密码</span></span><br><span class=\"line\">    String passwd = getUserPasswdByName(username);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(passwd == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    SimpleAuthenticationInfo authenticationInfo = <span class=\"keyword\">new</span> SimpleAuthenticationInfo(username,passwd,<span class=\"string\">\"custom\"</span>);</span><br><span class=\"line\"><span class=\"comment\">//设置盐为用户名        authenticationInfo.setCredentialsSalt(ByteSource.Util.bytes(username));</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> authenticationInfo;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> String <span class=\"title\">getUserPasswdByName</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    User user = userDao.getUserByName(name);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(user != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> user.getPassward();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//生成MD5 并加盐</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    Md5Hash md5Hash = <span class=\"keyword\">new</span> Md5Hash(<span class=\"string\">\"what\"</span>,<span class=\"string\">\"what\"</span>);</span><br><span class=\"line\">    System.out.println(md5Hash.toString());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>根据Shiro的设计思路，用户与角色之前的关系为多对多，角色与权限之间的关系也是多对多。在数据库中需要因此建立5张表，分别是用户表（存储用户名，密码，盐等）、角色表（角色名称，相关描述等）、权限表（权限名称，相关描述等）、用户-角色对应中间表（以用户ID和角色ID作为联合主键）、角色-权限对应中间表（以角色ID和权限ID作为联合主键）。具体dao与service的实现本文不提供。总之结论就是，Shiro需要根据用户名和密码首先判断登录的用户是否合法，然后再对合法用户授权。而这个过程就是Realm的实现过程。</p>\n<h2 id=\"Shiro会话管理\"><a href=\"#Shiro会话管理\" class=\"headerlink\" title=\"Shiro会话管理\"></a>Shiro会话管理</h2><p>shiro实现了简单的会话管理，由于自带的会话管理需要多次查询数据库，在实际项目中对性能影响过大，所以结合redis 实现会话管理时比较好的选择，当然也可以实现一个二级缓存进一步提升性能。在shiro中配置和实现如下：</p>\n<ul>\n<li>spring配置文件中配置自定义sessionManagement（可以用注解方式实现）</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">!-自定义SessionDAO-</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">\"session.RedisSessionDao\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"redisSessionDao\"</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">!-自定义SessionManager-</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">\"session.CustomSessionManager\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"sessionManager\"</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"sessionDAO\"</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"redisSessionDao\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>在securityManager中添加如下属性</li>\n</ul>\n<p><img src=\"http://epoch-night.oss-cn-hangzhou.aliyuncs.com/PostImg/securitityManagement.png\" alt=\"securitityManagement\"></p>\n<p>自定义Management</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 如果用默认的DefaultWebSessionManager ，会多次从Redis中读取数据 造成资源浪费 ，所有重写retrieveSession（）方法</span></span><br><span class=\"line\"><span class=\"comment\"> * retrieveSession该方法为读取Session方法</span></span><br><span class=\"line\"><span class=\"comment\"> * 参数SessionKey 中包含request对象，所有在第一次请求时从Redis中读取，之后都从request读取</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CustomSessionManager</span> <span class=\"keyword\">extends</span> <span class=\"title\">DefaultWebSessionManager</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> Session <span class=\"title\">retrieveSession</span><span class=\"params\">(SessionKey sessionKey)</span> <span class=\"keyword\">throws</span> UnknownSessionException </span>&#123;</span><br><span class=\"line\">        Serializable sessionId = getSessionId(sessionKey);</span><br><span class=\"line\">        ServletRequest request = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sessionKey <span class=\"keyword\">instanceof</span> WebSessionKey)&#123;</span><br><span class=\"line\">            request = ((WebSessionKey)sessionKey).getServletRequest();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (request != <span class=\"keyword\">null</span> &amp;&amp; sessionId != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            Session session =  (Session) request.getAttribute(sessionId.toString());</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (session != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> session;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Session session = <span class=\"keyword\">super</span>.retrieveSession(sessionKey);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(request != <span class=\"keyword\">null</span> &amp;&amp; sessionId != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            request.setAttribute(sessionId.toString(), session);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> session;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>​    </p>\n<h2 id=\"自定义Cache实现权限和角色数据缓存\"><a href=\"#自定义Cache实现权限和角色数据缓存\" class=\"headerlink\" title=\"自定义Cache实现权限和角色数据缓存\"></a>自定义Cache实现权限和角色数据缓存</h2><p>虽然角色缓存和权限下缓存包含的数据可能并不多，但是有效的减少了对数据库的访问次数，而且速度更快。</p>\n<p>实现Shiro 自带CacheManager 接口<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 缓存角色和权限数据</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RedisCacheManager</span>&lt;<span class=\"title\">K</span>, <span class=\"title\">V</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">CacheManager</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Resource</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> RedisCache redisCache;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> &lt;K, V&gt; <span class=\"function\">Cache&lt;K, V&gt; <span class=\"title\">getCache</span><span class=\"params\">(String s)</span> <span class=\"keyword\">throws</span> CacheException </span>&#123;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> redisCache;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>spring 中配置如下：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--自定义cacheManager--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">class</span>=<span class=\"string\">\"cache.RedisCacheManager\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"cacheManager\"</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"一个简单的DEMO\"><a href=\"#一个简单的DEMO\" class=\"headerlink\" title=\"一个简单的DEMO\"></a>一个简单的DEMO</h1><p>基于Spring的实现Demo<a href=\"https://github.com/Gubaidan/Shiro\" target=\"_blank\" rel=\"noopener\">Demo</a></p>\n"},{"layout":"post","title":"Spring | 事务管理","date":"2017-11-13T09:08:00.000Z","author":"Gubaidan","header-img":"/Header/2nojJdJoADk.png","cdn":"header-on","_content":"\n# 什么是事务\n\n\n事务(Transaction) 通俗的理解就是一件事情。 做事情要有始有终，不能半途而费。事务也是这样，要么做完，要么不做， 不要做一半留半，也就是说事务必须是一个不可分割的整体，就像我们在化学课里学到的原子，是构成物质的最小单位， 人们就归纳出事务的第一 个特性:**原子性(Atomicit)**。\n\n特别是在数据库领域，事务是一个非常重要的概念，除了原子性以外，它还有一个极其重要的特性，那就是**一致性(Cosisteney)**。也就是说，执行完数据库操作后，数据不会被破坏，打个比方，如果从A账户转账到B账户，不可能因为A账户扣了钱，而B账户没有加钱。如果出现了这类事情，后果很严重。\n\n当我们对数据库的数据进行操作后，数据需要永久的保存不能丢失，这就是**持久性(Duability)**。\n\n当我们编写了一条update语句，提交到数据库的一刹那， 有可能别人也提交了条delete语句到数据库中。也许我们都是对同一条记录进行操作， 可以想象，如果不稍加控制，就会出大麻烦。我们必须保证数据库操作之间是“隔离”的(线程之间有时也要做到隔离)，彼此之向没有任何干扰，这就是**隔离性(Isolation)**。\n\n要想真正做到操作之间完全没有任何干扰是很难的，于是，数据库权威专家制定一个规范，这个规范就是**事务隔离级别(Trasaction Iolation Level):**\n\n- **READ UNCOMMITTED**\n\n\n- **READ COMMITTED**\n\n\n- **REPEATABLE READ**\n\n\n-  **SERIALIZABLE**\n\n\n从上往下，级别越来越高，并发性越来越差，安全性越来越高。\n\n这四个特性称为**ACID**  ，其中：原子性是基础，隔离性是手段，持久性是目的，这三个真正服务于一致性。\n\n# 事务面临的问题\n\n\nACID 四个特性中，隔离性是保证一致性的手段，所以四个隔离级别用来解决高并发情况下产生的问题：\n\n- Dirty Read（脏读）\n- Unrepeatable（不可重读读）\n- Phantom（幻读）\n\n**脏读** ：脏读就是指当A事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，B事务也访问这个数据，然后使用了这个数据。\n\n例子：会计小王正在清算账单，清算到一半时结果被上报给老板，显然这个被上报的结果是不正确的。\n\n**不可重复读** ：是指在一个事务内，多次读同一数据。A事务读了两次数据，在A第一次读完数据后，B事务修改了数据。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。（即不能读到相同的数据内容）\n\n例子 ：会计小王正在清算账单，老板十分钟前和十分钟后看到的结果不一样。\n\n**幻读** ：是指当事务不是独立执行时发生的一种现象。A事务对一个表中的数据行数进行了统计（这种修改涉及到表中的全部数据行）。 同时，B事务向表中插入一行新数据。如果A事务再次进行统计后就会发现数据多了一行，就好象发生了幻觉一样。\n\n例子：会计小王正在清算账单后，老板又入了一笔账，如果会计小王再一次统计就会发现清算结果变了，像幻觉一样。\n\n\n\n<p style=\"text-align:center;\">√: 可能出现    ×: 不会出现</p>\n\n| 隔离级别         | 脏读 | 不可重复读 | 幻读 |\n| :--------------- | ---- | ---------- | ---- |\n| Read uncommitted | √    | √          | √    |\n| Read committed   | ×    | √          | √    |\n| Repeatable read  | ×    | ×          | √    |\n| Serializable     | ×    | ×          | ×    |\n\n \n\n# Spring事务传播行为\n\n\n\nSpring在TransactionDefinition接口中定义了七个事务传播行为。\n\n\n\n- **PROPAGATION_REQUIRED** 如果存在一个事务，则支持当前事务。如果没有事务则开启一个新的事务。\n\n- **PROPAGATION_SUPPORTS** 如果存在一个事务，支持当前事务。如果没有事务，则非事务的执行。但是对于事务同步的事务管理器，PROPAGATION_SUPPORTS与不使用事务有少许不同。\n\n- **PROPAGATION_MANDATORY** 如果已经存在一个事务，支持当前事务。如果没有一个活动的事务，则抛出异常。\n\n- **PROPAGATION_REQUIRES_NEW** 总是开启一个新的事务。如果一个事务已经存在，则将这个存在的事务挂起。\n\n- **PROPAGATION_NOT_SUPPORTED** 总是非事务地执行，并挂起任何存在的事务。\n\n- **PROPAGATION_NEVER** 总是非事务地执行，如果存在一个活动事务，则抛出异常\n\n- **PROPAGATION_NESTED** 如果一个活动的事务存在，则运行在一个嵌套的事务中. 如果没有活动事务, 则按**PROPAGATION_REQUIRED** 属性执行\n\n事务是逻辑处理原子性的保证手段，通过使用事务控制，可以极大的避免出现逻辑处理失败导致的脏数据等问题。\n\n事务最重要的两个特性，是事务的传播级别和数据隔离级别。传播级别定义的是事务的控制范围，事务隔离级别定义的是事务在数据库读写方面的控制范围。\n\n## 事务的七种传播级别详解\n\n1. PROPAGATION_REQUIRED ，默认的spring事务传播级别，使用该级别的特点是，如果上下文中已经存在事务，那么就加入到事务中执行，如果当前上下文中不存在事务，则新建事务执行。所以这个级别通常能满足处理大多数的业务场景。\n\n2. PROPAGATION_SUPPORTS ，从字面意思就知道，supports，支持，该传播级别的特点是，如果上下文存在事务，则支持事务加入事务，如果没有事务，则使用非事务的方式执行。所以说，并非所有的包在transactionTemplate.execute中的代码都会有事务支持。这个通常是用来处理那些并非原子性的非核心业务逻辑操作。应用场景较少。\n\n3. PROPAGATION_MANDATORY ， 该级别的事务要求上下文中必须要存在事务，否则就会抛出异常！配置该方式的传播级别是有效的控制上下文调用代码遗漏添加事务控制的保证手段。比如一段代码不能单独被调用执行，但是一旦被调用，就必须有事务包含的情况，就可以使用这个传播级别。\n\n4. PROPAGATION_REQUIRES_NEW ，从字面即可知道，new，每次都要一个新事务，该传播级别的特点是，每次都会新建一个事务，并且同时将上下文中的事务挂起，执行当前新建事务完成以后，上下文事务恢复再执行。\n\n   这是一个很有用的传播级别，举一个应用场景：现在有一个发送100个红包的操作，在发送之前，要做一些系统的初始化、验证、数据记录操作，然后发送100封红包，然后再记录发送日志，发送日志要求100%的准确，如果日志不准确，那么整个父事务逻辑需要回滚。\n   怎么处理整个业务需求呢？就是通过这个PROPAGATION_REQUIRES_NEW 级别的事务传播控制就可以完成。发送红包的子事务不会直接影响到父事务的提交和回滚。\n\n5. PROPAGATION_NOT_SUPPORTED ，这个也可以从字面得知，not supported ，不支持，当前级别的特点就是上下文中存在事务，则挂起事务，执行当前逻辑，结束后恢复上下文的事务。\n\n   这个级别有什么好处？可以帮助你将事务极可能的缩小。我们知道一个事务越大，它存在的风险也就越多。所以在处理事务的过程中，要保证尽可能的缩小范围。比如一段代码，是每次逻辑操作都必须调用的，比如循环1000次的某个非核心业务逻辑操作。这样的代码如果包在事务中，势必造成事务太大，导致出现一些难以考虑周全的异常情况。所以这个事务这个级别的传播级别就派上用场了。用当前级别的事务模板抱起来就可以了。\n\n6. PROPAGATION_NEVER ，该事务更严格，上面一个事务传播级别只是不支持而已，有事务就挂起，而PROPAGATION_NEVER传播级别要求上下文中不能存在事务，一旦有事务，就抛出runtime异常，强制停止执行！这个级别上辈子跟事务有仇。\n\n7. PROPAGATION_NESTED ，字面也可知道，nested，嵌套级别事务。该传播级别特征是，如果上下文中存在事务，则嵌套事务执行，如果不存在事务，则新建事务。\n\n那么什么是嵌套事务呢？很多人都不理解，我看过一些博客，都是有些理解偏差。\n\n嵌套是子事务套在父事务中执行，子事务是父事务的一部分，在进入子事务之前，父事务建立一个回滚点，叫save point，然后执行子事务，这个子事务的执行也算是父事务的一部分，然后子事务执行结束，父事务继续执行。重点就在于那个save point。看几个问题就明了了：\n\n如果子事务回滚，会发生什么？\n\n父事务会回滚到进入子事务前建立的save point，然后尝试其他的事务或者其他的业务逻辑，父事务之前的操作不会受到影响，更不会自动回滚。\n\n如果父事务回滚，会发生什么？\n\n父事务回滚，子事务也会跟着回滚！为什么呢，因为父事务结束之前，子事务是不会提交的，我们说子事务是父事务的一部分，正是这个道理。那么：\n\n事务的提交，是什么情况？\n\n是父事务先提交，然后子事务提交，还是子事务先提交，父事务再提交？答案是第二种情况，还是那句话，子事务是父事务的一部分，由父事务统一提交。\n\n以上是事务的7个传播级别，在日常应用中，通常可以满足各种业务需求，但是除了传播级别，在读取数据库的过程中，如果两个事务并发执行，那么彼此之间的数据是如何影响的呢？\n\n这就需要了解一下事务的另一个特性：数据隔离级别ACID\n\n# Spring配置声明式事务\n\n-  配置DataSource\n- 配置事务管理器\n- 事务的传播特性\n- 那些类那些方法使用事务\n\nSpring配置文件中关于事务配置总是由三个组成部分，分别是DataSource、TransactionManager和代理机制这三部分，无论哪种配置方式，一般变化的只是代理机制这部分。\n\nDataSource、TransactionManager这两部分只是会根据数据访问方式有所变化，比如使用MyBatis进行数据访问 时，DataSource实际为SqlSessionFactoryBean，TransactionManager的实现为 DataSourceTransactionManager。\n\n根据代理机制的不同，Spring事务的配置又有几种不同的方式：\n\n第一种方式：每个Bean都有一个代理\n\n 第二种方式：所有Bean共享一个代理基类\n\n第三种方式：使用拦截器\n\n第四种方式：使用tx标签配置的拦截器\n\n第五种方式：全注解\n\n## 使用tx标签配置的拦截器\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\"\n\txmlns:tx=\"http://www.springframework.org/schema/tx\"\n\txsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.0.xsd\">\n\t<!-- configure transaction -->\n \n\t<tx:advice id=\"defaultTxAdvice\" transaction-manager=\"transactionManager\">\n\t\t<tx:attributes>\n\t\t\t<tx:method name=\"get*\" read-only=\"true\" />\n\t\t\t<tx:method name=\"query*\" read-only=\"true\" />\n\t\t\t<tx:method name=\"find*\" read-only=\"true\" />\n\t\t\t<tx:method name=\"*\" propagation=\"REQUIRED\" rollback-for=\"java.lang.Exception\" />\n\t\t</tx:attributes>\n\t</tx:advice>\n \n\t<tx:advice id=\"logTxAdvice\" transaction-manager=\"transactionManager\">\n\t\t<tx:attributes>\n\t\t\t<tx:method name=\"get*\" read-only=\"true\" />\n\t\t\t<tx:method name=\"query*\" read-only=\"true\" />\n\t\t\t<tx:method name=\"find*\" read-only=\"true\" />\n\t\t\t<tx:method name=\"*\" propagation=\"REQUIRES_NEW\"\n\t\t\t\trollback-for=\"java.lang.Exception\" />\n\t\t</tx:attributes>\n\t</tx:advice>\n \n\t<aop:config>\n\t\t<aop:pointcut id=\"defaultOperation\"\n\t\t\texpression=\"@within(com.homent.util.DefaultTransaction)\" />\n\t\t<aop:pointcut id=\"logServiceOperation\"\n\t\t\texpression=\"execution(* com.homent.service.LogService.*(..))\" />\n\t\t\t\n\t\t<aop:advisor advice-ref=\"defaultTxAdvice\" pointcut-ref=\"defaultOperation\" />\n\t\t<aop:advisor advice-ref=\"logTxAdvice\" pointcut-ref=\"logServiceOperation\" />\n\t</aop:config>\n</beans>\n```\n\n如上面的Spring配置文件所示，日志服务的事务策略配置为propagation=\"REQUIRES_NEW\"，告诉Spring不管上下文是否有事务，Log Service被调用时都要求一个完全新的只属于Log Service自己的事务。通过该事务策略，Log Service可以独立的记录日志信息，不再受到业务逻辑事务的干扰。\n\n## @Transactional注解\n\n@Transactional属性 \n\n| 属性                   | 类型                               | 描述                                   |\n| ---------------------- | ---------------------------------- | -------------------------------------- |\n| value                  | String                             | 可选的限定描述符，指定使用的事务管理器 |\n| propagation            | enum: Propagation                  | 可选的事务传播行为设置                 |\n| isolation              | enum: Isolation                    | 可选的事务隔离级别设置                 |\n| readOnly               | boolean                            | 读写或只读事务，默认读写               |\n| timeout                | int (in seconds granularity)       | 事务超时时间设置                       |\n| rollbackFor            | Class对象数组，必须继承自Throwable | 导致事务回滚的异常类数组               |\n| rollbackForClassName   | 类名数组，必须继承自Throwable      | 导致事务回滚的异常类名字数组           |\n| noRollbackFor          | Class对象数组，必须继承自Throwable | 不会导致事务回滚的异常类数组           |\n| noRollbackForClassName | 类名数组，必须继承自Throwable      | 不会导致事务回滚的异常类名字数组       |\n\n **用法**:\n\n​       @Transactional 可以作用于接口、接口方法、类以及类方法上。当作用于类上时，该类的所有 public 方法将都具有该类型的事务属性，同时，我们也可以在方法级别使用该标注来覆盖类级别的定义。\n\n​         虽然 @Transactional 注解可以作用于接口、接口方法、类以及类方法上，但是 Spring 建议不要在接口或者接口方法上使用该注解，因为这只有在使用基于接口的代理时它才会生效。另外， @Transactional 注解应该只被应用到 public 方法上，这是由 Spring AOP 的本质决定的。如果你在 protected、private 或者默认可见性的方法上使用 @Transactional 注解，这将被忽略，也不会抛出任何异常。\n\n​        默认情况下，只有来自外部的方法调用才会被AOP代理捕获，也就是，类内部方法调用本类内部的其他方法并不会引起事务行为，即使被调用方法使用@Transactional注解进行修饰。\n\n```java\n\t@Autowired\n\tprivate MyBatisDao dao;\n\t\n\t@Transactional\n\t@Override\n\tpublic void insert(Test test) {\n\t\tdao.insert(test);\n\t\tthrow new RuntimeException(\"test\");//抛出unchecked异常，触发事物，回滚\n\t}\n```\n\nnoRollbackFor:\n\n```java\n@Transactional(noRollbackFor=RuntimeException.class)\n\t@Override\n\tpublic void insert(Test test) {\n\t\tdao.insert(test);\n\t\t//抛出unchecked异常，触发事物，noRollbackFor=RuntimeException.class,不回滚\n\t\tthrow new RuntimeException(\"test\");\n\t}\n```\n\nClass，当作用于类上时，该类的所有 public 方法将都具有该类型的事务属性:\n\n```java\n@Transactional\npublic class MyBatisServiceImpl implements MyBatisService {\n \n\t@Autowired\n\tprivate MyBatisDao dao;\n\t\n\t\n\t@Override\n\tpublic void insert(Test test) {\n\t\tdao.insert(test);\n\t\t//抛出unchecked异常，触发事物，回滚\n\t\tthrow new RuntimeException(\"test\");\n\t}\n```\n\npropagation=Propagation.NOT_SUPPORTED:\n\n```java\n\t@Transactional(propagation=Propagation.NOT_SUPPORTED)\n\t@Override\n\tpublic void insert(Test test) {\n\t\t//事物传播行为是PROPAGATION_NOT_SUPPORTED，以非事务方式运行，不会存入数据库\n\t\tdao.insert(test);\n\t}\n```\n\n\n\n# Spring事务典型问题\n\n1、spring事务控制放在service层，在service方法中一个方法调用service中的另一个方法，默认开启几个事务？\n\nspring的事务传播方式默认是PROPAGATION_REQUIRED，判断当前是否已开启一个新事务，有则加入当前事务，否则新开一个事务（如果没有就开启一个新事务），所以答案是开启了一个事务。\n\n2、spring 什么情况下进行事务回滚？\n\nSpring、EJB的声明式事务默认情况下都是在抛出unchecked exception后才会触发事务的回滚\n\nunchecked异常,即运行时异常runntimeException 回滚事务;\n\nchecked异常,即Exception可try{}捕获的不会回滚.当然也可配置spring参数让其回滚。\n\nspring的事务边界是在调用业务方法之前开始的，业务方法执行完毕之后来执行commit or rollback(Spring默认取决于是否抛出runtime异常).\n\n如果抛出runtime exception 并在你的业务方法中没有catch到的话，事务会回滚。\n\n一般不需要在业务方法中catch异常，如果非要catch，在做完你想做的工作后（比如关闭文件等）一定要抛出runtime exception，否则spring会将你的操作commit,这样就会产生脏数据.所以你的catch代码是画蛇添足。\n\n \n\n> 参考：《Spring 技术内幕》、《架构探险》\n>\n> [深入理解事务--Spring事务的传播机制](https://blog.csdn.net/yuanlaishini2010/article/details/45792069)","source":"_posts/2017-11-13-transmanager.markdown","raw":"---\nlayout: post\ntitle: \"Spring | 事务管理\"\ndate: 2017-11-13 17:08\nauthor: \"Gubaidan\"\nheader-img: \"/Header/2nojJdJoADk.png\"\ncdn: 'header-on'\ntags:\n\t- Spring\n---\n\n# 什么是事务\n\n\n事务(Transaction) 通俗的理解就是一件事情。 做事情要有始有终，不能半途而费。事务也是这样，要么做完，要么不做， 不要做一半留半，也就是说事务必须是一个不可分割的整体，就像我们在化学课里学到的原子，是构成物质的最小单位， 人们就归纳出事务的第一 个特性:**原子性(Atomicit)**。\n\n特别是在数据库领域，事务是一个非常重要的概念，除了原子性以外，它还有一个极其重要的特性，那就是**一致性(Cosisteney)**。也就是说，执行完数据库操作后，数据不会被破坏，打个比方，如果从A账户转账到B账户，不可能因为A账户扣了钱，而B账户没有加钱。如果出现了这类事情，后果很严重。\n\n当我们对数据库的数据进行操作后，数据需要永久的保存不能丢失，这就是**持久性(Duability)**。\n\n当我们编写了一条update语句，提交到数据库的一刹那， 有可能别人也提交了条delete语句到数据库中。也许我们都是对同一条记录进行操作， 可以想象，如果不稍加控制，就会出大麻烦。我们必须保证数据库操作之间是“隔离”的(线程之间有时也要做到隔离)，彼此之向没有任何干扰，这就是**隔离性(Isolation)**。\n\n要想真正做到操作之间完全没有任何干扰是很难的，于是，数据库权威专家制定一个规范，这个规范就是**事务隔离级别(Trasaction Iolation Level):**\n\n- **READ UNCOMMITTED**\n\n\n- **READ COMMITTED**\n\n\n- **REPEATABLE READ**\n\n\n-  **SERIALIZABLE**\n\n\n从上往下，级别越来越高，并发性越来越差，安全性越来越高。\n\n这四个特性称为**ACID**  ，其中：原子性是基础，隔离性是手段，持久性是目的，这三个真正服务于一致性。\n\n# 事务面临的问题\n\n\nACID 四个特性中，隔离性是保证一致性的手段，所以四个隔离级别用来解决高并发情况下产生的问题：\n\n- Dirty Read（脏读）\n- Unrepeatable（不可重读读）\n- Phantom（幻读）\n\n**脏读** ：脏读就是指当A事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，B事务也访问这个数据，然后使用了这个数据。\n\n例子：会计小王正在清算账单，清算到一半时结果被上报给老板，显然这个被上报的结果是不正确的。\n\n**不可重复读** ：是指在一个事务内，多次读同一数据。A事务读了两次数据，在A第一次读完数据后，B事务修改了数据。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。（即不能读到相同的数据内容）\n\n例子 ：会计小王正在清算账单，老板十分钟前和十分钟后看到的结果不一样。\n\n**幻读** ：是指当事务不是独立执行时发生的一种现象。A事务对一个表中的数据行数进行了统计（这种修改涉及到表中的全部数据行）。 同时，B事务向表中插入一行新数据。如果A事务再次进行统计后就会发现数据多了一行，就好象发生了幻觉一样。\n\n例子：会计小王正在清算账单后，老板又入了一笔账，如果会计小王再一次统计就会发现清算结果变了，像幻觉一样。\n\n\n\n<p style=\"text-align:center;\">√: 可能出现    ×: 不会出现</p>\n\n| 隔离级别         | 脏读 | 不可重复读 | 幻读 |\n| :--------------- | ---- | ---------- | ---- |\n| Read uncommitted | √    | √          | √    |\n| Read committed   | ×    | √          | √    |\n| Repeatable read  | ×    | ×          | √    |\n| Serializable     | ×    | ×          | ×    |\n\n \n\n# Spring事务传播行为\n\n\n\nSpring在TransactionDefinition接口中定义了七个事务传播行为。\n\n\n\n- **PROPAGATION_REQUIRED** 如果存在一个事务，则支持当前事务。如果没有事务则开启一个新的事务。\n\n- **PROPAGATION_SUPPORTS** 如果存在一个事务，支持当前事务。如果没有事务，则非事务的执行。但是对于事务同步的事务管理器，PROPAGATION_SUPPORTS与不使用事务有少许不同。\n\n- **PROPAGATION_MANDATORY** 如果已经存在一个事务，支持当前事务。如果没有一个活动的事务，则抛出异常。\n\n- **PROPAGATION_REQUIRES_NEW** 总是开启一个新的事务。如果一个事务已经存在，则将这个存在的事务挂起。\n\n- **PROPAGATION_NOT_SUPPORTED** 总是非事务地执行，并挂起任何存在的事务。\n\n- **PROPAGATION_NEVER** 总是非事务地执行，如果存在一个活动事务，则抛出异常\n\n- **PROPAGATION_NESTED** 如果一个活动的事务存在，则运行在一个嵌套的事务中. 如果没有活动事务, 则按**PROPAGATION_REQUIRED** 属性执行\n\n事务是逻辑处理原子性的保证手段，通过使用事务控制，可以极大的避免出现逻辑处理失败导致的脏数据等问题。\n\n事务最重要的两个特性，是事务的传播级别和数据隔离级别。传播级别定义的是事务的控制范围，事务隔离级别定义的是事务在数据库读写方面的控制范围。\n\n## 事务的七种传播级别详解\n\n1. PROPAGATION_REQUIRED ，默认的spring事务传播级别，使用该级别的特点是，如果上下文中已经存在事务，那么就加入到事务中执行，如果当前上下文中不存在事务，则新建事务执行。所以这个级别通常能满足处理大多数的业务场景。\n\n2. PROPAGATION_SUPPORTS ，从字面意思就知道，supports，支持，该传播级别的特点是，如果上下文存在事务，则支持事务加入事务，如果没有事务，则使用非事务的方式执行。所以说，并非所有的包在transactionTemplate.execute中的代码都会有事务支持。这个通常是用来处理那些并非原子性的非核心业务逻辑操作。应用场景较少。\n\n3. PROPAGATION_MANDATORY ， 该级别的事务要求上下文中必须要存在事务，否则就会抛出异常！配置该方式的传播级别是有效的控制上下文调用代码遗漏添加事务控制的保证手段。比如一段代码不能单独被调用执行，但是一旦被调用，就必须有事务包含的情况，就可以使用这个传播级别。\n\n4. PROPAGATION_REQUIRES_NEW ，从字面即可知道，new，每次都要一个新事务，该传播级别的特点是，每次都会新建一个事务，并且同时将上下文中的事务挂起，执行当前新建事务完成以后，上下文事务恢复再执行。\n\n   这是一个很有用的传播级别，举一个应用场景：现在有一个发送100个红包的操作，在发送之前，要做一些系统的初始化、验证、数据记录操作，然后发送100封红包，然后再记录发送日志，发送日志要求100%的准确，如果日志不准确，那么整个父事务逻辑需要回滚。\n   怎么处理整个业务需求呢？就是通过这个PROPAGATION_REQUIRES_NEW 级别的事务传播控制就可以完成。发送红包的子事务不会直接影响到父事务的提交和回滚。\n\n5. PROPAGATION_NOT_SUPPORTED ，这个也可以从字面得知，not supported ，不支持，当前级别的特点就是上下文中存在事务，则挂起事务，执行当前逻辑，结束后恢复上下文的事务。\n\n   这个级别有什么好处？可以帮助你将事务极可能的缩小。我们知道一个事务越大，它存在的风险也就越多。所以在处理事务的过程中，要保证尽可能的缩小范围。比如一段代码，是每次逻辑操作都必须调用的，比如循环1000次的某个非核心业务逻辑操作。这样的代码如果包在事务中，势必造成事务太大，导致出现一些难以考虑周全的异常情况。所以这个事务这个级别的传播级别就派上用场了。用当前级别的事务模板抱起来就可以了。\n\n6. PROPAGATION_NEVER ，该事务更严格，上面一个事务传播级别只是不支持而已，有事务就挂起，而PROPAGATION_NEVER传播级别要求上下文中不能存在事务，一旦有事务，就抛出runtime异常，强制停止执行！这个级别上辈子跟事务有仇。\n\n7. PROPAGATION_NESTED ，字面也可知道，nested，嵌套级别事务。该传播级别特征是，如果上下文中存在事务，则嵌套事务执行，如果不存在事务，则新建事务。\n\n那么什么是嵌套事务呢？很多人都不理解，我看过一些博客，都是有些理解偏差。\n\n嵌套是子事务套在父事务中执行，子事务是父事务的一部分，在进入子事务之前，父事务建立一个回滚点，叫save point，然后执行子事务，这个子事务的执行也算是父事务的一部分，然后子事务执行结束，父事务继续执行。重点就在于那个save point。看几个问题就明了了：\n\n如果子事务回滚，会发生什么？\n\n父事务会回滚到进入子事务前建立的save point，然后尝试其他的事务或者其他的业务逻辑，父事务之前的操作不会受到影响，更不会自动回滚。\n\n如果父事务回滚，会发生什么？\n\n父事务回滚，子事务也会跟着回滚！为什么呢，因为父事务结束之前，子事务是不会提交的，我们说子事务是父事务的一部分，正是这个道理。那么：\n\n事务的提交，是什么情况？\n\n是父事务先提交，然后子事务提交，还是子事务先提交，父事务再提交？答案是第二种情况，还是那句话，子事务是父事务的一部分，由父事务统一提交。\n\n以上是事务的7个传播级别，在日常应用中，通常可以满足各种业务需求，但是除了传播级别，在读取数据库的过程中，如果两个事务并发执行，那么彼此之间的数据是如何影响的呢？\n\n这就需要了解一下事务的另一个特性：数据隔离级别ACID\n\n# Spring配置声明式事务\n\n-  配置DataSource\n- 配置事务管理器\n- 事务的传播特性\n- 那些类那些方法使用事务\n\nSpring配置文件中关于事务配置总是由三个组成部分，分别是DataSource、TransactionManager和代理机制这三部分，无论哪种配置方式，一般变化的只是代理机制这部分。\n\nDataSource、TransactionManager这两部分只是会根据数据访问方式有所变化，比如使用MyBatis进行数据访问 时，DataSource实际为SqlSessionFactoryBean，TransactionManager的实现为 DataSourceTransactionManager。\n\n根据代理机制的不同，Spring事务的配置又有几种不同的方式：\n\n第一种方式：每个Bean都有一个代理\n\n 第二种方式：所有Bean共享一个代理基类\n\n第三种方式：使用拦截器\n\n第四种方式：使用tx标签配置的拦截器\n\n第五种方式：全注解\n\n## 使用tx标签配置的拦截器\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\"\n\txmlns:tx=\"http://www.springframework.org/schema/tx\"\n\txsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.0.xsd\">\n\t<!-- configure transaction -->\n \n\t<tx:advice id=\"defaultTxAdvice\" transaction-manager=\"transactionManager\">\n\t\t<tx:attributes>\n\t\t\t<tx:method name=\"get*\" read-only=\"true\" />\n\t\t\t<tx:method name=\"query*\" read-only=\"true\" />\n\t\t\t<tx:method name=\"find*\" read-only=\"true\" />\n\t\t\t<tx:method name=\"*\" propagation=\"REQUIRED\" rollback-for=\"java.lang.Exception\" />\n\t\t</tx:attributes>\n\t</tx:advice>\n \n\t<tx:advice id=\"logTxAdvice\" transaction-manager=\"transactionManager\">\n\t\t<tx:attributes>\n\t\t\t<tx:method name=\"get*\" read-only=\"true\" />\n\t\t\t<tx:method name=\"query*\" read-only=\"true\" />\n\t\t\t<tx:method name=\"find*\" read-only=\"true\" />\n\t\t\t<tx:method name=\"*\" propagation=\"REQUIRES_NEW\"\n\t\t\t\trollback-for=\"java.lang.Exception\" />\n\t\t</tx:attributes>\n\t</tx:advice>\n \n\t<aop:config>\n\t\t<aop:pointcut id=\"defaultOperation\"\n\t\t\texpression=\"@within(com.homent.util.DefaultTransaction)\" />\n\t\t<aop:pointcut id=\"logServiceOperation\"\n\t\t\texpression=\"execution(* com.homent.service.LogService.*(..))\" />\n\t\t\t\n\t\t<aop:advisor advice-ref=\"defaultTxAdvice\" pointcut-ref=\"defaultOperation\" />\n\t\t<aop:advisor advice-ref=\"logTxAdvice\" pointcut-ref=\"logServiceOperation\" />\n\t</aop:config>\n</beans>\n```\n\n如上面的Spring配置文件所示，日志服务的事务策略配置为propagation=\"REQUIRES_NEW\"，告诉Spring不管上下文是否有事务，Log Service被调用时都要求一个完全新的只属于Log Service自己的事务。通过该事务策略，Log Service可以独立的记录日志信息，不再受到业务逻辑事务的干扰。\n\n## @Transactional注解\n\n@Transactional属性 \n\n| 属性                   | 类型                               | 描述                                   |\n| ---------------------- | ---------------------------------- | -------------------------------------- |\n| value                  | String                             | 可选的限定描述符，指定使用的事务管理器 |\n| propagation            | enum: Propagation                  | 可选的事务传播行为设置                 |\n| isolation              | enum: Isolation                    | 可选的事务隔离级别设置                 |\n| readOnly               | boolean                            | 读写或只读事务，默认读写               |\n| timeout                | int (in seconds granularity)       | 事务超时时间设置                       |\n| rollbackFor            | Class对象数组，必须继承自Throwable | 导致事务回滚的异常类数组               |\n| rollbackForClassName   | 类名数组，必须继承自Throwable      | 导致事务回滚的异常类名字数组           |\n| noRollbackFor          | Class对象数组，必须继承自Throwable | 不会导致事务回滚的异常类数组           |\n| noRollbackForClassName | 类名数组，必须继承自Throwable      | 不会导致事务回滚的异常类名字数组       |\n\n **用法**:\n\n​       @Transactional 可以作用于接口、接口方法、类以及类方法上。当作用于类上时，该类的所有 public 方法将都具有该类型的事务属性，同时，我们也可以在方法级别使用该标注来覆盖类级别的定义。\n\n​         虽然 @Transactional 注解可以作用于接口、接口方法、类以及类方法上，但是 Spring 建议不要在接口或者接口方法上使用该注解，因为这只有在使用基于接口的代理时它才会生效。另外， @Transactional 注解应该只被应用到 public 方法上，这是由 Spring AOP 的本质决定的。如果你在 protected、private 或者默认可见性的方法上使用 @Transactional 注解，这将被忽略，也不会抛出任何异常。\n\n​        默认情况下，只有来自外部的方法调用才会被AOP代理捕获，也就是，类内部方法调用本类内部的其他方法并不会引起事务行为，即使被调用方法使用@Transactional注解进行修饰。\n\n```java\n\t@Autowired\n\tprivate MyBatisDao dao;\n\t\n\t@Transactional\n\t@Override\n\tpublic void insert(Test test) {\n\t\tdao.insert(test);\n\t\tthrow new RuntimeException(\"test\");//抛出unchecked异常，触发事物，回滚\n\t}\n```\n\nnoRollbackFor:\n\n```java\n@Transactional(noRollbackFor=RuntimeException.class)\n\t@Override\n\tpublic void insert(Test test) {\n\t\tdao.insert(test);\n\t\t//抛出unchecked异常，触发事物，noRollbackFor=RuntimeException.class,不回滚\n\t\tthrow new RuntimeException(\"test\");\n\t}\n```\n\nClass，当作用于类上时，该类的所有 public 方法将都具有该类型的事务属性:\n\n```java\n@Transactional\npublic class MyBatisServiceImpl implements MyBatisService {\n \n\t@Autowired\n\tprivate MyBatisDao dao;\n\t\n\t\n\t@Override\n\tpublic void insert(Test test) {\n\t\tdao.insert(test);\n\t\t//抛出unchecked异常，触发事物，回滚\n\t\tthrow new RuntimeException(\"test\");\n\t}\n```\n\npropagation=Propagation.NOT_SUPPORTED:\n\n```java\n\t@Transactional(propagation=Propagation.NOT_SUPPORTED)\n\t@Override\n\tpublic void insert(Test test) {\n\t\t//事物传播行为是PROPAGATION_NOT_SUPPORTED，以非事务方式运行，不会存入数据库\n\t\tdao.insert(test);\n\t}\n```\n\n\n\n# Spring事务典型问题\n\n1、spring事务控制放在service层，在service方法中一个方法调用service中的另一个方法，默认开启几个事务？\n\nspring的事务传播方式默认是PROPAGATION_REQUIRED，判断当前是否已开启一个新事务，有则加入当前事务，否则新开一个事务（如果没有就开启一个新事务），所以答案是开启了一个事务。\n\n2、spring 什么情况下进行事务回滚？\n\nSpring、EJB的声明式事务默认情况下都是在抛出unchecked exception后才会触发事务的回滚\n\nunchecked异常,即运行时异常runntimeException 回滚事务;\n\nchecked异常,即Exception可try{}捕获的不会回滚.当然也可配置spring参数让其回滚。\n\nspring的事务边界是在调用业务方法之前开始的，业务方法执行完毕之后来执行commit or rollback(Spring默认取决于是否抛出runtime异常).\n\n如果抛出runtime exception 并在你的业务方法中没有catch到的话，事务会回滚。\n\n一般不需要在业务方法中catch异常，如果非要catch，在做完你想做的工作后（比如关闭文件等）一定要抛出runtime exception，否则spring会将你的操作commit,这样就会产生脏数据.所以你的catch代码是画蛇添足。\n\n \n\n> 参考：《Spring 技术内幕》、《架构探险》\n>\n> [深入理解事务--Spring事务的传播机制](https://blog.csdn.net/yuanlaishini2010/article/details/45792069)","slug":"2017-11-13-transmanager","published":1,"updated":"2018-07-14T07:38:46.746Z","comments":1,"photos":[],"link":"","_id":"cjvayvwgo002am46a819kcpdy","content":"<h1 id=\"什么是事务\"><a href=\"#什么是事务\" class=\"headerlink\" title=\"什么是事务\"></a>什么是事务</h1><p>事务(Transaction) 通俗的理解就是一件事情。 做事情要有始有终，不能半途而费。事务也是这样，要么做完，要么不做， 不要做一半留半，也就是说事务必须是一个不可分割的整体，就像我们在化学课里学到的原子，是构成物质的最小单位， 人们就归纳出事务的第一 个特性:<strong>原子性(Atomicit)</strong>。</p>\n<p>特别是在数据库领域，事务是一个非常重要的概念，除了原子性以外，它还有一个极其重要的特性，那就是<strong>一致性(Cosisteney)</strong>。也就是说，执行完数据库操作后，数据不会被破坏，打个比方，如果从A账户转账到B账户，不可能因为A账户扣了钱，而B账户没有加钱。如果出现了这类事情，后果很严重。</p>\n<p>当我们对数据库的数据进行操作后，数据需要永久的保存不能丢失，这就是<strong>持久性(Duability)</strong>。</p>\n<p>当我们编写了一条update语句，提交到数据库的一刹那， 有可能别人也提交了条delete语句到数据库中。也许我们都是对同一条记录进行操作， 可以想象，如果不稍加控制，就会出大麻烦。我们必须保证数据库操作之间是“隔离”的(线程之间有时也要做到隔离)，彼此之向没有任何干扰，这就是<strong>隔离性(Isolation)</strong>。</p>\n<p>要想真正做到操作之间完全没有任何干扰是很难的，于是，数据库权威专家制定一个规范，这个规范就是<strong>事务隔离级别(Trasaction Iolation Level):</strong></p>\n<ul>\n<li><strong>READ UNCOMMITTED</strong></li>\n</ul>\n<ul>\n<li><strong>READ COMMITTED</strong></li>\n</ul>\n<ul>\n<li><strong>REPEATABLE READ</strong></li>\n</ul>\n<ul>\n<li><strong>SERIALIZABLE</strong></li>\n</ul>\n<p>从上往下，级别越来越高，并发性越来越差，安全性越来越高。</p>\n<p>这四个特性称为<strong>ACID</strong>  ，其中：原子性是基础，隔离性是手段，持久性是目的，这三个真正服务于一致性。</p>\n<h1 id=\"事务面临的问题\"><a href=\"#事务面临的问题\" class=\"headerlink\" title=\"事务面临的问题\"></a>事务面临的问题</h1><p>ACID 四个特性中，隔离性是保证一致性的手段，所以四个隔离级别用来解决高并发情况下产生的问题：</p>\n<ul>\n<li>Dirty Read（脏读）</li>\n<li>Unrepeatable（不可重读读）</li>\n<li>Phantom（幻读）</li>\n</ul>\n<p><strong>脏读</strong> ：脏读就是指当A事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，B事务也访问这个数据，然后使用了这个数据。</p>\n<p>例子：会计小王正在清算账单，清算到一半时结果被上报给老板，显然这个被上报的结果是不正确的。</p>\n<p><strong>不可重复读</strong> ：是指在一个事务内，多次读同一数据。A事务读了两次数据，在A第一次读完数据后，B事务修改了数据。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。（即不能读到相同的数据内容）</p>\n<p>例子 ：会计小王正在清算账单，老板十分钟前和十分钟后看到的结果不一样。</p>\n<p><strong>幻读</strong> ：是指当事务不是独立执行时发生的一种现象。A事务对一个表中的数据行数进行了统计（这种修改涉及到表中的全部数据行）。 同时，B事务向表中插入一行新数据。如果A事务再次进行统计后就会发现数据多了一行，就好象发生了幻觉一样。</p>\n<p>例子：会计小王正在清算账单后，老板又入了一笔账，如果会计小王再一次统计就会发现清算结果变了，像幻觉一样。</p>\n<p style=\"text-align:center;\">√: 可能出现    ×: 不会出现</p>\n\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">隔离级别</th>\n<th>脏读</th>\n<th>不可重复读</th>\n<th>幻读</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">Read uncommitted</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Read committed</td>\n<td>×</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Repeatable read</td>\n<td>×</td>\n<td>×</td>\n<td>√</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Serializable</td>\n<td>×</td>\n<td>×</td>\n<td>×</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"Spring事务传播行为\"><a href=\"#Spring事务传播行为\" class=\"headerlink\" title=\"Spring事务传播行为\"></a>Spring事务传播行为</h1><p>Spring在TransactionDefinition接口中定义了七个事务传播行为。</p>\n<ul>\n<li><p><strong>PROPAGATION_REQUIRED</strong> 如果存在一个事务，则支持当前事务。如果没有事务则开启一个新的事务。</p>\n</li>\n<li><p><strong>PROPAGATION_SUPPORTS</strong> 如果存在一个事务，支持当前事务。如果没有事务，则非事务的执行。但是对于事务同步的事务管理器，PROPAGATION_SUPPORTS与不使用事务有少许不同。</p>\n</li>\n<li><p><strong>PROPAGATION_MANDATORY</strong> 如果已经存在一个事务，支持当前事务。如果没有一个活动的事务，则抛出异常。</p>\n</li>\n<li><p><strong>PROPAGATION_REQUIRES_NEW</strong> 总是开启一个新的事务。如果一个事务已经存在，则将这个存在的事务挂起。</p>\n</li>\n<li><p><strong>PROPAGATION_NOT_SUPPORTED</strong> 总是非事务地执行，并挂起任何存在的事务。</p>\n</li>\n<li><p><strong>PROPAGATION_NEVER</strong> 总是非事务地执行，如果存在一个活动事务，则抛出异常</p>\n</li>\n<li><p><strong>PROPAGATION_NESTED</strong> 如果一个活动的事务存在，则运行在一个嵌套的事务中. 如果没有活动事务, 则按<strong>PROPAGATION_REQUIRED</strong> 属性执行</p>\n</li>\n</ul>\n<p>事务是逻辑处理原子性的保证手段，通过使用事务控制，可以极大的避免出现逻辑处理失败导致的脏数据等问题。</p>\n<p>事务最重要的两个特性，是事务的传播级别和数据隔离级别。传播级别定义的是事务的控制范围，事务隔离级别定义的是事务在数据库读写方面的控制范围。</p>\n<h2 id=\"事务的七种传播级别详解\"><a href=\"#事务的七种传播级别详解\" class=\"headerlink\" title=\"事务的七种传播级别详解\"></a>事务的七种传播级别详解</h2><ol>\n<li><p>PROPAGATION_REQUIRED ，默认的spring事务传播级别，使用该级别的特点是，如果上下文中已经存在事务，那么就加入到事务中执行，如果当前上下文中不存在事务，则新建事务执行。所以这个级别通常能满足处理大多数的业务场景。</p>\n</li>\n<li><p>PROPAGATION_SUPPORTS ，从字面意思就知道，supports，支持，该传播级别的特点是，如果上下文存在事务，则支持事务加入事务，如果没有事务，则使用非事务的方式执行。所以说，并非所有的包在transactionTemplate.execute中的代码都会有事务支持。这个通常是用来处理那些并非原子性的非核心业务逻辑操作。应用场景较少。</p>\n</li>\n<li><p>PROPAGATION_MANDATORY ， 该级别的事务要求上下文中必须要存在事务，否则就会抛出异常！配置该方式的传播级别是有效的控制上下文调用代码遗漏添加事务控制的保证手段。比如一段代码不能单独被调用执行，但是一旦被调用，就必须有事务包含的情况，就可以使用这个传播级别。</p>\n</li>\n<li><p>PROPAGATION_REQUIRES_NEW ，从字面即可知道，new，每次都要一个新事务，该传播级别的特点是，每次都会新建一个事务，并且同时将上下文中的事务挂起，执行当前新建事务完成以后，上下文事务恢复再执行。</p>\n<p>这是一个很有用的传播级别，举一个应用场景：现在有一个发送100个红包的操作，在发送之前，要做一些系统的初始化、验证、数据记录操作，然后发送100封红包，然后再记录发送日志，发送日志要求100%的准确，如果日志不准确，那么整个父事务逻辑需要回滚。<br>怎么处理整个业务需求呢？就是通过这个PROPAGATION_REQUIRES_NEW 级别的事务传播控制就可以完成。发送红包的子事务不会直接影响到父事务的提交和回滚。</p>\n</li>\n<li><p>PROPAGATION_NOT_SUPPORTED ，这个也可以从字面得知，not supported ，不支持，当前级别的特点就是上下文中存在事务，则挂起事务，执行当前逻辑，结束后恢复上下文的事务。</p>\n<p>这个级别有什么好处？可以帮助你将事务极可能的缩小。我们知道一个事务越大，它存在的风险也就越多。所以在处理事务的过程中，要保证尽可能的缩小范围。比如一段代码，是每次逻辑操作都必须调用的，比如循环1000次的某个非核心业务逻辑操作。这样的代码如果包在事务中，势必造成事务太大，导致出现一些难以考虑周全的异常情况。所以这个事务这个级别的传播级别就派上用场了。用当前级别的事务模板抱起来就可以了。</p>\n</li>\n<li><p>PROPAGATION_NEVER ，该事务更严格，上面一个事务传播级别只是不支持而已，有事务就挂起，而PROPAGATION_NEVER传播级别要求上下文中不能存在事务，一旦有事务，就抛出runtime异常，强制停止执行！这个级别上辈子跟事务有仇。</p>\n</li>\n<li><p>PROPAGATION_NESTED ，字面也可知道，nested，嵌套级别事务。该传播级别特征是，如果上下文中存在事务，则嵌套事务执行，如果不存在事务，则新建事务。</p>\n</li>\n</ol>\n<p>那么什么是嵌套事务呢？很多人都不理解，我看过一些博客，都是有些理解偏差。</p>\n<p>嵌套是子事务套在父事务中执行，子事务是父事务的一部分，在进入子事务之前，父事务建立一个回滚点，叫save point，然后执行子事务，这个子事务的执行也算是父事务的一部分，然后子事务执行结束，父事务继续执行。重点就在于那个save point。看几个问题就明了了：</p>\n<p>如果子事务回滚，会发生什么？</p>\n<p>父事务会回滚到进入子事务前建立的save point，然后尝试其他的事务或者其他的业务逻辑，父事务之前的操作不会受到影响，更不会自动回滚。</p>\n<p>如果父事务回滚，会发生什么？</p>\n<p>父事务回滚，子事务也会跟着回滚！为什么呢，因为父事务结束之前，子事务是不会提交的，我们说子事务是父事务的一部分，正是这个道理。那么：</p>\n<p>事务的提交，是什么情况？</p>\n<p>是父事务先提交，然后子事务提交，还是子事务先提交，父事务再提交？答案是第二种情况，还是那句话，子事务是父事务的一部分，由父事务统一提交。</p>\n<p>以上是事务的7个传播级别，在日常应用中，通常可以满足各种业务需求，但是除了传播级别，在读取数据库的过程中，如果两个事务并发执行，那么彼此之间的数据是如何影响的呢？</p>\n<p>这就需要了解一下事务的另一个特性：数据隔离级别ACID</p>\n<h1 id=\"Spring配置声明式事务\"><a href=\"#Spring配置声明式事务\" class=\"headerlink\" title=\"Spring配置声明式事务\"></a>Spring配置声明式事务</h1><ul>\n<li>配置DataSource</li>\n<li>配置事务管理器</li>\n<li>事务的传播特性</li>\n<li>那些类那些方法使用事务</li>\n</ul>\n<p>Spring配置文件中关于事务配置总是由三个组成部分，分别是DataSource、TransactionManager和代理机制这三部分，无论哪种配置方式，一般变化的只是代理机制这部分。</p>\n<p>DataSource、TransactionManager这两部分只是会根据数据访问方式有所变化，比如使用MyBatis进行数据访问 时，DataSource实际为SqlSessionFactoryBean，TransactionManager的实现为 DataSourceTransactionManager。</p>\n<p>根据代理机制的不同，Spring事务的配置又有几种不同的方式：</p>\n<p>第一种方式：每个Bean都有一个代理</p>\n<p> 第二种方式：所有Bean共享一个代理基类</p>\n<p>第三种方式：使用拦截器</p>\n<p>第四种方式：使用tx标签配置的拦截器</p>\n<p>第五种方式：全注解</p>\n<h2 id=\"使用tx标签配置的拦截器\"><a href=\"#使用tx标签配置的拦截器\" class=\"headerlink\" title=\"使用tx标签配置的拦截器\"></a>使用tx标签配置的拦截器</h2><figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans\"</span></span></span><br><span class=\"line\"><span class=\"tag\">\t<span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span> <span class=\"attr\">xmlns:aop</span>=<span class=\"string\">\"http://www.springframework.org/schema/aop\"</span></span></span><br><span class=\"line\"><span class=\"tag\">\t<span class=\"attr\">xmlns:tx</span>=<span class=\"string\">\"http://www.springframework.org/schema/tx\"</span></span></span><br><span class=\"line\"><span class=\"tag\">\t<span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.0.xsd\"</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"comment\">&lt;!-- configure transaction --&gt;</span></span><br><span class=\"line\"> </span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">tx:advice</span> <span class=\"attr\">id</span>=<span class=\"string\">\"defaultTxAdvice\"</span> <span class=\"attr\">transaction-manager</span>=<span class=\"string\">\"transactionManager\"</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">tx:attributes</span>&gt;</span></span><br><span class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">tx:method</span> <span class=\"attr\">name</span>=<span class=\"string\">\"get*\"</span> <span class=\"attr\">read-only</span>=<span class=\"string\">\"true\"</span> /&gt;</span></span><br><span class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">tx:method</span> <span class=\"attr\">name</span>=<span class=\"string\">\"query*\"</span> <span class=\"attr\">read-only</span>=<span class=\"string\">\"true\"</span> /&gt;</span></span><br><span class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">tx:method</span> <span class=\"attr\">name</span>=<span class=\"string\">\"find*\"</span> <span class=\"attr\">read-only</span>=<span class=\"string\">\"true\"</span> /&gt;</span></span><br><span class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">tx:method</span> <span class=\"attr\">name</span>=<span class=\"string\">\"*\"</span> <span class=\"attr\">propagation</span>=<span class=\"string\">\"REQUIRED\"</span> <span class=\"attr\">rollback-for</span>=<span class=\"string\">\"java.lang.Exception\"</span> /&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">tx:attributes</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">tx:advice</span>&gt;</span></span><br><span class=\"line\"> </span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">tx:advice</span> <span class=\"attr\">id</span>=<span class=\"string\">\"logTxAdvice\"</span> <span class=\"attr\">transaction-manager</span>=<span class=\"string\">\"transactionManager\"</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">tx:attributes</span>&gt;</span></span><br><span class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">tx:method</span> <span class=\"attr\">name</span>=<span class=\"string\">\"get*\"</span> <span class=\"attr\">read-only</span>=<span class=\"string\">\"true\"</span> /&gt;</span></span><br><span class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">tx:method</span> <span class=\"attr\">name</span>=<span class=\"string\">\"query*\"</span> <span class=\"attr\">read-only</span>=<span class=\"string\">\"true\"</span> /&gt;</span></span><br><span class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">tx:method</span> <span class=\"attr\">name</span>=<span class=\"string\">\"find*\"</span> <span class=\"attr\">read-only</span>=<span class=\"string\">\"true\"</span> /&gt;</span></span><br><span class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">tx:method</span> <span class=\"attr\">name</span>=<span class=\"string\">\"*\"</span> <span class=\"attr\">propagation</span>=<span class=\"string\">\"REQUIRES_NEW\"</span></span></span><br><span class=\"line\"><span class=\"tag\">\t\t\t\t<span class=\"attr\">rollback-for</span>=<span class=\"string\">\"java.lang.Exception\"</span> /&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">tx:attributes</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">tx:advice</span>&gt;</span></span><br><span class=\"line\"> </span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">aop:config</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">aop:pointcut</span> <span class=\"attr\">id</span>=<span class=\"string\">\"defaultOperation\"</span></span></span><br><span class=\"line\"><span class=\"tag\">\t\t\t<span class=\"attr\">expression</span>=<span class=\"string\">\"@within(com.homent.util.DefaultTransaction)\"</span> /&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">aop:pointcut</span> <span class=\"attr\">id</span>=<span class=\"string\">\"logServiceOperation\"</span></span></span><br><span class=\"line\"><span class=\"tag\">\t\t\t<span class=\"attr\">expression</span>=<span class=\"string\">\"execution(* com.homent.service.LogService.*(..))\"</span> /&gt;</span></span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">aop:advisor</span> <span class=\"attr\">advice-ref</span>=<span class=\"string\">\"defaultTxAdvice\"</span> <span class=\"attr\">pointcut-ref</span>=<span class=\"string\">\"defaultOperation\"</span> /&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">aop:advisor</span> <span class=\"attr\">advice-ref</span>=<span class=\"string\">\"logTxAdvice\"</span> <span class=\"attr\">pointcut-ref</span>=<span class=\"string\">\"logServiceOperation\"</span> /&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">aop:config</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>如上面的Spring配置文件所示，日志服务的事务策略配置为propagation=”REQUIRES_NEW”，告诉Spring不管上下文是否有事务，Log Service被调用时都要求一个完全新的只属于Log Service自己的事务。通过该事务策略，Log Service可以独立的记录日志信息，不再受到业务逻辑事务的干扰。</p>\n<h2 id=\"Transactional注解\"><a href=\"#Transactional注解\" class=\"headerlink\" title=\"@Transactional注解\"></a>@Transactional注解</h2><p>@Transactional属性 </p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>类型</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>value</td>\n<td>String</td>\n<td>可选的限定描述符，指定使用的事务管理器</td>\n</tr>\n<tr>\n<td>propagation</td>\n<td>enum: Propagation</td>\n<td>可选的事务传播行为设置</td>\n</tr>\n<tr>\n<td>isolation</td>\n<td>enum: Isolation</td>\n<td>可选的事务隔离级别设置</td>\n</tr>\n<tr>\n<td>readOnly</td>\n<td>boolean</td>\n<td>读写或只读事务，默认读写</td>\n</tr>\n<tr>\n<td>timeout</td>\n<td>int (in seconds granularity)</td>\n<td>事务超时时间设置</td>\n</tr>\n<tr>\n<td>rollbackFor</td>\n<td>Class对象数组，必须继承自Throwable</td>\n<td>导致事务回滚的异常类数组</td>\n</tr>\n<tr>\n<td>rollbackForClassName</td>\n<td>类名数组，必须继承自Throwable</td>\n<td>导致事务回滚的异常类名字数组</td>\n</tr>\n<tr>\n<td>noRollbackFor</td>\n<td>Class对象数组，必须继承自Throwable</td>\n<td>不会导致事务回滚的异常类数组</td>\n</tr>\n<tr>\n<td>noRollbackForClassName</td>\n<td>类名数组，必须继承自Throwable</td>\n<td>不会导致事务回滚的异常类名字数组</td>\n</tr>\n</tbody>\n</table>\n<p> <strong>用法</strong>:</p>\n<p>​       @Transactional 可以作用于接口、接口方法、类以及类方法上。当作用于类上时，该类的所有 public 方法将都具有该类型的事务属性，同时，我们也可以在方法级别使用该标注来覆盖类级别的定义。</p>\n<p>​         虽然 @Transactional 注解可以作用于接口、接口方法、类以及类方法上，但是 Spring 建议不要在接口或者接口方法上使用该注解，因为这只有在使用基于接口的代理时它才会生效。另外， @Transactional 注解应该只被应用到 public 方法上，这是由 Spring AOP 的本质决定的。如果你在 protected、private 或者默认可见性的方法上使用 @Transactional 注解，这将被忽略，也不会抛出任何异常。</p>\n<p>​        默认情况下，只有来自外部的方法调用才会被AOP代理捕获，也就是，类内部方法调用本类内部的其他方法并不会引起事务行为，即使被调用方法使用@Transactional注解进行修饰。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> MyBatisDao dao;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Transactional</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(Test test)</span> </span>&#123;</span><br><span class=\"line\">\tdao.insert(test);</span><br><span class=\"line\">\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"test\"</span>);<span class=\"comment\">//抛出unchecked异常，触发事物，回滚</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>noRollbackFor:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Transactional</span>(noRollbackFor=RuntimeException.class)</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(Test test)</span> </span>&#123;</span><br><span class=\"line\">\t\tdao.insert(test);</span><br><span class=\"line\">\t\t<span class=\"comment\">//抛出unchecked异常，触发事物，noRollbackFor=RuntimeException.class,不回滚</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"test\"</span>);</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n<p>Class，当作用于类上时，该类的所有 public 方法将都具有该类型的事务属性:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Transactional</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyBatisServiceImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">MyBatisService</span> </span>&#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t<span class=\"meta\">@Autowired</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> MyBatisDao dao;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(Test test)</span> </span>&#123;</span><br><span class=\"line\">\t\tdao.insert(test);</span><br><span class=\"line\">\t\t<span class=\"comment\">//抛出unchecked异常，触发事物，回滚</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"test\"</span>);</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n<p>propagation=Propagation.NOT_SUPPORTED:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Transactional</span>(propagation=Propagation.NOT_SUPPORTED)</span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(Test test)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//事物传播行为是PROPAGATION_NOT_SUPPORTED，以非事务方式运行，不会存入数据库</span></span><br><span class=\"line\">\tdao.insert(test);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"Spring事务典型问题\"><a href=\"#Spring事务典型问题\" class=\"headerlink\" title=\"Spring事务典型问题\"></a>Spring事务典型问题</h1><p>1、spring事务控制放在service层，在service方法中一个方法调用service中的另一个方法，默认开启几个事务？</p>\n<p>spring的事务传播方式默认是PROPAGATION_REQUIRED，判断当前是否已开启一个新事务，有则加入当前事务，否则新开一个事务（如果没有就开启一个新事务），所以答案是开启了一个事务。</p>\n<p>2、spring 什么情况下进行事务回滚？</p>\n<p>Spring、EJB的声明式事务默认情况下都是在抛出unchecked exception后才会触发事务的回滚</p>\n<p>unchecked异常,即运行时异常runntimeException 回滚事务;</p>\n<p>checked异常,即Exception可try{}捕获的不会回滚.当然也可配置spring参数让其回滚。</p>\n<p>spring的事务边界是在调用业务方法之前开始的，业务方法执行完毕之后来执行commit or rollback(Spring默认取决于是否抛出runtime异常).</p>\n<p>如果抛出runtime exception 并在你的业务方法中没有catch到的话，事务会回滚。</p>\n<p>一般不需要在业务方法中catch异常，如果非要catch，在做完你想做的工作后（比如关闭文件等）一定要抛出runtime exception，否则spring会将你的操作commit,这样就会产生脏数据.所以你的catch代码是画蛇添足。</p>\n<blockquote>\n<p>参考：《Spring 技术内幕》、《架构探险》</p>\n<p><a href=\"https://blog.csdn.net/yuanlaishini2010/article/details/45792069\" target=\"_blank\" rel=\"noopener\">深入理解事务–Spring事务的传播机制</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"什么是事务\"><a href=\"#什么是事务\" class=\"headerlink\" title=\"什么是事务\"></a>什么是事务</h1><p>事务(Transaction) 通俗的理解就是一件事情。 做事情要有始有终，不能半途而费。事务也是这样，要么做完，要么不做， 不要做一半留半，也就是说事务必须是一个不可分割的整体，就像我们在化学课里学到的原子，是构成物质的最小单位， 人们就归纳出事务的第一 个特性:<strong>原子性(Atomicit)</strong>。</p>\n<p>特别是在数据库领域，事务是一个非常重要的概念，除了原子性以外，它还有一个极其重要的特性，那就是<strong>一致性(Cosisteney)</strong>。也就是说，执行完数据库操作后，数据不会被破坏，打个比方，如果从A账户转账到B账户，不可能因为A账户扣了钱，而B账户没有加钱。如果出现了这类事情，后果很严重。</p>\n<p>当我们对数据库的数据进行操作后，数据需要永久的保存不能丢失，这就是<strong>持久性(Duability)</strong>。</p>\n<p>当我们编写了一条update语句，提交到数据库的一刹那， 有可能别人也提交了条delete语句到数据库中。也许我们都是对同一条记录进行操作， 可以想象，如果不稍加控制，就会出大麻烦。我们必须保证数据库操作之间是“隔离”的(线程之间有时也要做到隔离)，彼此之向没有任何干扰，这就是<strong>隔离性(Isolation)</strong>。</p>\n<p>要想真正做到操作之间完全没有任何干扰是很难的，于是，数据库权威专家制定一个规范，这个规范就是<strong>事务隔离级别(Trasaction Iolation Level):</strong></p>\n<ul>\n<li><strong>READ UNCOMMITTED</strong></li>\n</ul>\n<ul>\n<li><strong>READ COMMITTED</strong></li>\n</ul>\n<ul>\n<li><strong>REPEATABLE READ</strong></li>\n</ul>\n<ul>\n<li><strong>SERIALIZABLE</strong></li>\n</ul>\n<p>从上往下，级别越来越高，并发性越来越差，安全性越来越高。</p>\n<p>这四个特性称为<strong>ACID</strong>  ，其中：原子性是基础，隔离性是手段，持久性是目的，这三个真正服务于一致性。</p>\n<h1 id=\"事务面临的问题\"><a href=\"#事务面临的问题\" class=\"headerlink\" title=\"事务面临的问题\"></a>事务面临的问题</h1><p>ACID 四个特性中，隔离性是保证一致性的手段，所以四个隔离级别用来解决高并发情况下产生的问题：</p>\n<ul>\n<li>Dirty Read（脏读）</li>\n<li>Unrepeatable（不可重读读）</li>\n<li>Phantom（幻读）</li>\n</ul>\n<p><strong>脏读</strong> ：脏读就是指当A事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，B事务也访问这个数据，然后使用了这个数据。</p>\n<p>例子：会计小王正在清算账单，清算到一半时结果被上报给老板，显然这个被上报的结果是不正确的。</p>\n<p><strong>不可重复读</strong> ：是指在一个事务内，多次读同一数据。A事务读了两次数据，在A第一次读完数据后，B事务修改了数据。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。（即不能读到相同的数据内容）</p>\n<p>例子 ：会计小王正在清算账单，老板十分钟前和十分钟后看到的结果不一样。</p>\n<p><strong>幻读</strong> ：是指当事务不是独立执行时发生的一种现象。A事务对一个表中的数据行数进行了统计（这种修改涉及到表中的全部数据行）。 同时，B事务向表中插入一行新数据。如果A事务再次进行统计后就会发现数据多了一行，就好象发生了幻觉一样。</p>\n<p>例子：会计小王正在清算账单后，老板又入了一笔账，如果会计小王再一次统计就会发现清算结果变了，像幻觉一样。</p>\n<p style=\"text-align:center;\">√: 可能出现    ×: 不会出现</p>\n\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">隔离级别</th>\n<th>脏读</th>\n<th>不可重复读</th>\n<th>幻读</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">Read uncommitted</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Read committed</td>\n<td>×</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Repeatable read</td>\n<td>×</td>\n<td>×</td>\n<td>√</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Serializable</td>\n<td>×</td>\n<td>×</td>\n<td>×</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"Spring事务传播行为\"><a href=\"#Spring事务传播行为\" class=\"headerlink\" title=\"Spring事务传播行为\"></a>Spring事务传播行为</h1><p>Spring在TransactionDefinition接口中定义了七个事务传播行为。</p>\n<ul>\n<li><p><strong>PROPAGATION_REQUIRED</strong> 如果存在一个事务，则支持当前事务。如果没有事务则开启一个新的事务。</p>\n</li>\n<li><p><strong>PROPAGATION_SUPPORTS</strong> 如果存在一个事务，支持当前事务。如果没有事务，则非事务的执行。但是对于事务同步的事务管理器，PROPAGATION_SUPPORTS与不使用事务有少许不同。</p>\n</li>\n<li><p><strong>PROPAGATION_MANDATORY</strong> 如果已经存在一个事务，支持当前事务。如果没有一个活动的事务，则抛出异常。</p>\n</li>\n<li><p><strong>PROPAGATION_REQUIRES_NEW</strong> 总是开启一个新的事务。如果一个事务已经存在，则将这个存在的事务挂起。</p>\n</li>\n<li><p><strong>PROPAGATION_NOT_SUPPORTED</strong> 总是非事务地执行，并挂起任何存在的事务。</p>\n</li>\n<li><p><strong>PROPAGATION_NEVER</strong> 总是非事务地执行，如果存在一个活动事务，则抛出异常</p>\n</li>\n<li><p><strong>PROPAGATION_NESTED</strong> 如果一个活动的事务存在，则运行在一个嵌套的事务中. 如果没有活动事务, 则按<strong>PROPAGATION_REQUIRED</strong> 属性执行</p>\n</li>\n</ul>\n<p>事务是逻辑处理原子性的保证手段，通过使用事务控制，可以极大的避免出现逻辑处理失败导致的脏数据等问题。</p>\n<p>事务最重要的两个特性，是事务的传播级别和数据隔离级别。传播级别定义的是事务的控制范围，事务隔离级别定义的是事务在数据库读写方面的控制范围。</p>\n<h2 id=\"事务的七种传播级别详解\"><a href=\"#事务的七种传播级别详解\" class=\"headerlink\" title=\"事务的七种传播级别详解\"></a>事务的七种传播级别详解</h2><ol>\n<li><p>PROPAGATION_REQUIRED ，默认的spring事务传播级别，使用该级别的特点是，如果上下文中已经存在事务，那么就加入到事务中执行，如果当前上下文中不存在事务，则新建事务执行。所以这个级别通常能满足处理大多数的业务场景。</p>\n</li>\n<li><p>PROPAGATION_SUPPORTS ，从字面意思就知道，supports，支持，该传播级别的特点是，如果上下文存在事务，则支持事务加入事务，如果没有事务，则使用非事务的方式执行。所以说，并非所有的包在transactionTemplate.execute中的代码都会有事务支持。这个通常是用来处理那些并非原子性的非核心业务逻辑操作。应用场景较少。</p>\n</li>\n<li><p>PROPAGATION_MANDATORY ， 该级别的事务要求上下文中必须要存在事务，否则就会抛出异常！配置该方式的传播级别是有效的控制上下文调用代码遗漏添加事务控制的保证手段。比如一段代码不能单独被调用执行，但是一旦被调用，就必须有事务包含的情况，就可以使用这个传播级别。</p>\n</li>\n<li><p>PROPAGATION_REQUIRES_NEW ，从字面即可知道，new，每次都要一个新事务，该传播级别的特点是，每次都会新建一个事务，并且同时将上下文中的事务挂起，执行当前新建事务完成以后，上下文事务恢复再执行。</p>\n<p>这是一个很有用的传播级别，举一个应用场景：现在有一个发送100个红包的操作，在发送之前，要做一些系统的初始化、验证、数据记录操作，然后发送100封红包，然后再记录发送日志，发送日志要求100%的准确，如果日志不准确，那么整个父事务逻辑需要回滚。<br>怎么处理整个业务需求呢？就是通过这个PROPAGATION_REQUIRES_NEW 级别的事务传播控制就可以完成。发送红包的子事务不会直接影响到父事务的提交和回滚。</p>\n</li>\n<li><p>PROPAGATION_NOT_SUPPORTED ，这个也可以从字面得知，not supported ，不支持，当前级别的特点就是上下文中存在事务，则挂起事务，执行当前逻辑，结束后恢复上下文的事务。</p>\n<p>这个级别有什么好处？可以帮助你将事务极可能的缩小。我们知道一个事务越大，它存在的风险也就越多。所以在处理事务的过程中，要保证尽可能的缩小范围。比如一段代码，是每次逻辑操作都必须调用的，比如循环1000次的某个非核心业务逻辑操作。这样的代码如果包在事务中，势必造成事务太大，导致出现一些难以考虑周全的异常情况。所以这个事务这个级别的传播级别就派上用场了。用当前级别的事务模板抱起来就可以了。</p>\n</li>\n<li><p>PROPAGATION_NEVER ，该事务更严格，上面一个事务传播级别只是不支持而已，有事务就挂起，而PROPAGATION_NEVER传播级别要求上下文中不能存在事务，一旦有事务，就抛出runtime异常，强制停止执行！这个级别上辈子跟事务有仇。</p>\n</li>\n<li><p>PROPAGATION_NESTED ，字面也可知道，nested，嵌套级别事务。该传播级别特征是，如果上下文中存在事务，则嵌套事务执行，如果不存在事务，则新建事务。</p>\n</li>\n</ol>\n<p>那么什么是嵌套事务呢？很多人都不理解，我看过一些博客，都是有些理解偏差。</p>\n<p>嵌套是子事务套在父事务中执行，子事务是父事务的一部分，在进入子事务之前，父事务建立一个回滚点，叫save point，然后执行子事务，这个子事务的执行也算是父事务的一部分，然后子事务执行结束，父事务继续执行。重点就在于那个save point。看几个问题就明了了：</p>\n<p>如果子事务回滚，会发生什么？</p>\n<p>父事务会回滚到进入子事务前建立的save point，然后尝试其他的事务或者其他的业务逻辑，父事务之前的操作不会受到影响，更不会自动回滚。</p>\n<p>如果父事务回滚，会发生什么？</p>\n<p>父事务回滚，子事务也会跟着回滚！为什么呢，因为父事务结束之前，子事务是不会提交的，我们说子事务是父事务的一部分，正是这个道理。那么：</p>\n<p>事务的提交，是什么情况？</p>\n<p>是父事务先提交，然后子事务提交，还是子事务先提交，父事务再提交？答案是第二种情况，还是那句话，子事务是父事务的一部分，由父事务统一提交。</p>\n<p>以上是事务的7个传播级别，在日常应用中，通常可以满足各种业务需求，但是除了传播级别，在读取数据库的过程中，如果两个事务并发执行，那么彼此之间的数据是如何影响的呢？</p>\n<p>这就需要了解一下事务的另一个特性：数据隔离级别ACID</p>\n<h1 id=\"Spring配置声明式事务\"><a href=\"#Spring配置声明式事务\" class=\"headerlink\" title=\"Spring配置声明式事务\"></a>Spring配置声明式事务</h1><ul>\n<li>配置DataSource</li>\n<li>配置事务管理器</li>\n<li>事务的传播特性</li>\n<li>那些类那些方法使用事务</li>\n</ul>\n<p>Spring配置文件中关于事务配置总是由三个组成部分，分别是DataSource、TransactionManager和代理机制这三部分，无论哪种配置方式，一般变化的只是代理机制这部分。</p>\n<p>DataSource、TransactionManager这两部分只是会根据数据访问方式有所变化，比如使用MyBatis进行数据访问 时，DataSource实际为SqlSessionFactoryBean，TransactionManager的实现为 DataSourceTransactionManager。</p>\n<p>根据代理机制的不同，Spring事务的配置又有几种不同的方式：</p>\n<p>第一种方式：每个Bean都有一个代理</p>\n<p> 第二种方式：所有Bean共享一个代理基类</p>\n<p>第三种方式：使用拦截器</p>\n<p>第四种方式：使用tx标签配置的拦截器</p>\n<p>第五种方式：全注解</p>\n<h2 id=\"使用tx标签配置的拦截器\"><a href=\"#使用tx标签配置的拦截器\" class=\"headerlink\" title=\"使用tx标签配置的拦截器\"></a>使用tx标签配置的拦截器</h2><figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans\"</span></span></span><br><span class=\"line\"><span class=\"tag\">\t<span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span> <span class=\"attr\">xmlns:aop</span>=<span class=\"string\">\"http://www.springframework.org/schema/aop\"</span></span></span><br><span class=\"line\"><span class=\"tag\">\t<span class=\"attr\">xmlns:tx</span>=<span class=\"string\">\"http://www.springframework.org/schema/tx\"</span></span></span><br><span class=\"line\"><span class=\"tag\">\t<span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.0.xsd\"</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"comment\">&lt;!-- configure transaction --&gt;</span></span><br><span class=\"line\"> </span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">tx:advice</span> <span class=\"attr\">id</span>=<span class=\"string\">\"defaultTxAdvice\"</span> <span class=\"attr\">transaction-manager</span>=<span class=\"string\">\"transactionManager\"</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">tx:attributes</span>&gt;</span></span><br><span class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">tx:method</span> <span class=\"attr\">name</span>=<span class=\"string\">\"get*\"</span> <span class=\"attr\">read-only</span>=<span class=\"string\">\"true\"</span> /&gt;</span></span><br><span class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">tx:method</span> <span class=\"attr\">name</span>=<span class=\"string\">\"query*\"</span> <span class=\"attr\">read-only</span>=<span class=\"string\">\"true\"</span> /&gt;</span></span><br><span class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">tx:method</span> <span class=\"attr\">name</span>=<span class=\"string\">\"find*\"</span> <span class=\"attr\">read-only</span>=<span class=\"string\">\"true\"</span> /&gt;</span></span><br><span class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">tx:method</span> <span class=\"attr\">name</span>=<span class=\"string\">\"*\"</span> <span class=\"attr\">propagation</span>=<span class=\"string\">\"REQUIRED\"</span> <span class=\"attr\">rollback-for</span>=<span class=\"string\">\"java.lang.Exception\"</span> /&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">tx:attributes</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">tx:advice</span>&gt;</span></span><br><span class=\"line\"> </span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">tx:advice</span> <span class=\"attr\">id</span>=<span class=\"string\">\"logTxAdvice\"</span> <span class=\"attr\">transaction-manager</span>=<span class=\"string\">\"transactionManager\"</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">tx:attributes</span>&gt;</span></span><br><span class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">tx:method</span> <span class=\"attr\">name</span>=<span class=\"string\">\"get*\"</span> <span class=\"attr\">read-only</span>=<span class=\"string\">\"true\"</span> /&gt;</span></span><br><span class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">tx:method</span> <span class=\"attr\">name</span>=<span class=\"string\">\"query*\"</span> <span class=\"attr\">read-only</span>=<span class=\"string\">\"true\"</span> /&gt;</span></span><br><span class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">tx:method</span> <span class=\"attr\">name</span>=<span class=\"string\">\"find*\"</span> <span class=\"attr\">read-only</span>=<span class=\"string\">\"true\"</span> /&gt;</span></span><br><span class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">tx:method</span> <span class=\"attr\">name</span>=<span class=\"string\">\"*\"</span> <span class=\"attr\">propagation</span>=<span class=\"string\">\"REQUIRES_NEW\"</span></span></span><br><span class=\"line\"><span class=\"tag\">\t\t\t\t<span class=\"attr\">rollback-for</span>=<span class=\"string\">\"java.lang.Exception\"</span> /&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">tx:attributes</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">tx:advice</span>&gt;</span></span><br><span class=\"line\"> </span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">aop:config</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">aop:pointcut</span> <span class=\"attr\">id</span>=<span class=\"string\">\"defaultOperation\"</span></span></span><br><span class=\"line\"><span class=\"tag\">\t\t\t<span class=\"attr\">expression</span>=<span class=\"string\">\"@within(com.homent.util.DefaultTransaction)\"</span> /&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">aop:pointcut</span> <span class=\"attr\">id</span>=<span class=\"string\">\"logServiceOperation\"</span></span></span><br><span class=\"line\"><span class=\"tag\">\t\t\t<span class=\"attr\">expression</span>=<span class=\"string\">\"execution(* com.homent.service.LogService.*(..))\"</span> /&gt;</span></span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">aop:advisor</span> <span class=\"attr\">advice-ref</span>=<span class=\"string\">\"defaultTxAdvice\"</span> <span class=\"attr\">pointcut-ref</span>=<span class=\"string\">\"defaultOperation\"</span> /&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">aop:advisor</span> <span class=\"attr\">advice-ref</span>=<span class=\"string\">\"logTxAdvice\"</span> <span class=\"attr\">pointcut-ref</span>=<span class=\"string\">\"logServiceOperation\"</span> /&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">aop:config</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>如上面的Spring配置文件所示，日志服务的事务策略配置为propagation=”REQUIRES_NEW”，告诉Spring不管上下文是否有事务，Log Service被调用时都要求一个完全新的只属于Log Service自己的事务。通过该事务策略，Log Service可以独立的记录日志信息，不再受到业务逻辑事务的干扰。</p>\n<h2 id=\"Transactional注解\"><a href=\"#Transactional注解\" class=\"headerlink\" title=\"@Transactional注解\"></a>@Transactional注解</h2><p>@Transactional属性 </p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>类型</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>value</td>\n<td>String</td>\n<td>可选的限定描述符，指定使用的事务管理器</td>\n</tr>\n<tr>\n<td>propagation</td>\n<td>enum: Propagation</td>\n<td>可选的事务传播行为设置</td>\n</tr>\n<tr>\n<td>isolation</td>\n<td>enum: Isolation</td>\n<td>可选的事务隔离级别设置</td>\n</tr>\n<tr>\n<td>readOnly</td>\n<td>boolean</td>\n<td>读写或只读事务，默认读写</td>\n</tr>\n<tr>\n<td>timeout</td>\n<td>int (in seconds granularity)</td>\n<td>事务超时时间设置</td>\n</tr>\n<tr>\n<td>rollbackFor</td>\n<td>Class对象数组，必须继承自Throwable</td>\n<td>导致事务回滚的异常类数组</td>\n</tr>\n<tr>\n<td>rollbackForClassName</td>\n<td>类名数组，必须继承自Throwable</td>\n<td>导致事务回滚的异常类名字数组</td>\n</tr>\n<tr>\n<td>noRollbackFor</td>\n<td>Class对象数组，必须继承自Throwable</td>\n<td>不会导致事务回滚的异常类数组</td>\n</tr>\n<tr>\n<td>noRollbackForClassName</td>\n<td>类名数组，必须继承自Throwable</td>\n<td>不会导致事务回滚的异常类名字数组</td>\n</tr>\n</tbody>\n</table>\n<p> <strong>用法</strong>:</p>\n<p>​       @Transactional 可以作用于接口、接口方法、类以及类方法上。当作用于类上时，该类的所有 public 方法将都具有该类型的事务属性，同时，我们也可以在方法级别使用该标注来覆盖类级别的定义。</p>\n<p>​         虽然 @Transactional 注解可以作用于接口、接口方法、类以及类方法上，但是 Spring 建议不要在接口或者接口方法上使用该注解，因为这只有在使用基于接口的代理时它才会生效。另外， @Transactional 注解应该只被应用到 public 方法上，这是由 Spring AOP 的本质决定的。如果你在 protected、private 或者默认可见性的方法上使用 @Transactional 注解，这将被忽略，也不会抛出任何异常。</p>\n<p>​        默认情况下，只有来自外部的方法调用才会被AOP代理捕获，也就是，类内部方法调用本类内部的其他方法并不会引起事务行为，即使被调用方法使用@Transactional注解进行修饰。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> MyBatisDao dao;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Transactional</span></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(Test test)</span> </span>&#123;</span><br><span class=\"line\">\tdao.insert(test);</span><br><span class=\"line\">\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"test\"</span>);<span class=\"comment\">//抛出unchecked异常，触发事物，回滚</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>noRollbackFor:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Transactional</span>(noRollbackFor=RuntimeException.class)</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(Test test)</span> </span>&#123;</span><br><span class=\"line\">\t\tdao.insert(test);</span><br><span class=\"line\">\t\t<span class=\"comment\">//抛出unchecked异常，触发事物，noRollbackFor=RuntimeException.class,不回滚</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"test\"</span>);</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n<p>Class，当作用于类上时，该类的所有 public 方法将都具有该类型的事务属性:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Transactional</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyBatisServiceImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">MyBatisService</span> </span>&#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t<span class=\"meta\">@Autowired</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> MyBatisDao dao;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(Test test)</span> </span>&#123;</span><br><span class=\"line\">\t\tdao.insert(test);</span><br><span class=\"line\">\t\t<span class=\"comment\">//抛出unchecked异常，触发事物，回滚</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"test\"</span>);</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n<p>propagation=Propagation.NOT_SUPPORTED:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Transactional</span>(propagation=Propagation.NOT_SUPPORTED)</span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(Test test)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//事物传播行为是PROPAGATION_NOT_SUPPORTED，以非事务方式运行，不会存入数据库</span></span><br><span class=\"line\">\tdao.insert(test);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"Spring事务典型问题\"><a href=\"#Spring事务典型问题\" class=\"headerlink\" title=\"Spring事务典型问题\"></a>Spring事务典型问题</h1><p>1、spring事务控制放在service层，在service方法中一个方法调用service中的另一个方法，默认开启几个事务？</p>\n<p>spring的事务传播方式默认是PROPAGATION_REQUIRED，判断当前是否已开启一个新事务，有则加入当前事务，否则新开一个事务（如果没有就开启一个新事务），所以答案是开启了一个事务。</p>\n<p>2、spring 什么情况下进行事务回滚？</p>\n<p>Spring、EJB的声明式事务默认情况下都是在抛出unchecked exception后才会触发事务的回滚</p>\n<p>unchecked异常,即运行时异常runntimeException 回滚事务;</p>\n<p>checked异常,即Exception可try{}捕获的不会回滚.当然也可配置spring参数让其回滚。</p>\n<p>spring的事务边界是在调用业务方法之前开始的，业务方法执行完毕之后来执行commit or rollback(Spring默认取决于是否抛出runtime异常).</p>\n<p>如果抛出runtime exception 并在你的业务方法中没有catch到的话，事务会回滚。</p>\n<p>一般不需要在业务方法中catch异常，如果非要catch，在做完你想做的工作后（比如关闭文件等）一定要抛出runtime exception，否则spring会将你的操作commit,这样就会产生脏数据.所以你的catch代码是画蛇添足。</p>\n<blockquote>\n<p>参考：《Spring 技术内幕》、《架构探险》</p>\n<p><a href=\"https://blog.csdn.net/yuanlaishini2010/article/details/45792069\" target=\"_blank\" rel=\"noopener\">深入理解事务–Spring事务的传播机制</a></p>\n</blockquote>\n"},{"layout":"post","title":"Spring | AOP理解及实现","date":"2017-11-09T05:20:00.000Z","author":"Gubaidan","header-img":"/Header/RbM63-XsLUY.png","cdn":"header-on","_content":"\n# AOP是什么\n\n在简单的了解过AOP之后，被“面向方面编程”、“面向切面编程”、“切点”、“切面”这些术语搞的糊里糊涂，简单来说AOP是Aspect Origented Programing的简称，根据字面意思确实是面向切面编程，那么这个词到底又是什么意思？\n\n按照软件重构的思想，如果一个类在多个方法或者类中出现相同的代码，我们就认为可以将这些代码提取到父类，但是有些代码例如在代码执行前得到执行开始时间，执行后获得结束时间，这样用来统计执行时间的代码可能隐藏在一堆杂乱的代码之中，这样的话通过父类继承的方式是无法实现的，这也就是AOP将要解决的问题。\n\n> 我的通俗理解就是：**在某个方法执行前后动态的为其插入想要执行的方法或者代码。**\n\n# AOP术语\n\n**连接点（Joinpoint）:**特定点是程序执行的某个特定位置，如类开始初始化前，类初始化后，类的某个方法调用前/后，方法抛出异常后。一个类或一段代码拥有一些具有边界性质的特定点，这些代码中的特定点就被称为“连接点”。 \n\nSpring仅支持方法的连接点，即仅能在方法调用前，方法调用后，方法抛出异常时及方法调用前后这些程序执行点织入增强。 \n\n连接点由两个信息确定：一是用方法表示的程序执行点，二是用相对位置表示的方位。如在Test.foo()方法执行前的连接点，执行点为Test.foo(),方法为该方法执行前的位置。Spring使用切点对执行点进行定位，而方位则在增强类型中增强\n\n**切点(Pointcut）:**每个程序类都有多个连接点，如一个拥有两个方法的类，这两个方法就是连接点，即连接点是程序类中客观存在的事物。AOP通过“切点”定位特定的连接点。连接点相当于数据库中的记录，而切点相当于查询条件，一个切点可以匹配多个连接点。\n\n在Spring中，切点通过org.springframework.aop.Pointcut接口进行描述，它使用类和方法作为连接点的查询条件。Spring AOP的规则解析引擎负责解析切点所设定的查询条件，找到对应的连接点。确切地说，应该是执行点而非连接点，因为连接点是方法执行前/后等包括方位信息的具体程序执行点，而切点只定位到某个方法上，所以如果希望定位到具体的连接点上，需要提供方位信息\n\n**增强（Advice）:**增强是织入目标类连接点上的一段程序代码。在Spring中，增强除用于描述一段程序代码外，还拥有另一个和连接点相关的信息，就是执行点的方位。结合执行点的方位信息和切点信息，就可以找到特定的连接。 \n\n正因为增强即包含由于添加到目标连接点上的一段执行逻辑，又包含用于定位连接点的方位信息，所以Spring所提供的增强接口都是带方位名的，如BeforeAdivce，AfterReturningAdvice和ThrowsAdvice等。BeforeAdvice表示方法调用前的位置，而AfterReturningAdvice表示访问后的位置。 所以只有结合切点和增强，才能确定特定的连接点并实施逻辑增强。\n\n**目标对象(Target)  :**增强逻辑的织入目标类。如果没有AOP，那么目标业务类需要自己实现所有的逻辑.\n\n在AOP的帮助下，ForumService只实现那些非横切逻辑的程序逻辑，而性能监视和事务管理等这些横切逻辑就可以使用AOP动态织入特定的连接点上\n\n**引介（Introduction）:** 引介是一种特殊的增强，为类添加一些属性和方法。这样，即使一个业务类原本没有实现某个接口，通过AOP的引介功能，也可以动态地为该业务类添加接口的实现逻辑，使业务类成为这个接口的实现类\n\n**织入(Weaving)  :** 织入是将增强添加到目标类的具体连接点上的过程.AOP就像一台织布机，将目标类，增强或引介编织到一切。 \n\n**AOP有三种织入方式：** \n\n- 编译期织入，这要求使用特殊的Java编译器 \n- 类装载期织入，这要求使用特殊的类装载器 \n- 动态代理织入，在运行期为目标类添加增强生成子类的方式，Spring采用动态代理织入\n\n**代理（Proxy)  :** 一个类被AOP织入增强后，就产生一个结果类，它是融合了原类和增强逻辑的代理类。根据不同的代理方式，代理类既可能是和原类具有相同接口的类，也可能就是原类的子类，所以可以采用与调用原类相同的方式调用代理类。\n\n**切面（Aspect)  :**切面由切点和增强（引介）组成，既包括横切逻辑的定义，也包括连接点的定义。Spring AOP就是负责实施切面的框架，它将切面所定义的横切逻辑织入切面所指定的连接点中\n\n# 基础知识\n\nSpring AOP使用了两种代理机制：一种是基于JDK的动态代理；另一种是基于CGLib的动态代理。 \n之所以需要两种代理机制，是因为JDK本身只提供接口的代理，而不支持类的代理。\n\nCGLib所创建的动态代理对象的性能比JDK所创建的动态代理对象的性能高很多，但CGLib在创建代理对象时所花费的时间比JDK动态代理多。  对于singleton的代理对象或者具有实例池的代理，因为无需频繁地创建代理对象，所以比较适合采用CGLib动态代理技术；反之适合采用JDK动态代理技术。\n\n# 实现者\n\n按照增强在目标类方法中的连接点位置，可以分为5类：\n\n- 前置增强：org.springframework.aop.BeforeAdvice代表前置增强，因为Spring只支持方法级的增强，所以MethodBeforeAdvice是目前可用的前置增强，表示在目标方法执行前实施增强，而BeforeAdvice是为了将来版本扩展需要而定义的。\n\n- 后置增强：org.springframework.aop.AfterReturningAdvice代表后置增强，表示在目标方法执行后实施增强。\n\n- 环绕增强：org.aopalliance.intercept.MethodInterceptor代表环绕增强，表示在目标方法执行前后实施增强。\n\n- 异常抛出增强：org.springframework.aop.ThrowsAdvice代表抛出异常增强，表示在目标方法抛出异常后实施增强。\n\n- 引介增强：org.springframework.aop.IntroductionInterceptor代表引介增强，表示在目标类中添加一些新的方法和属性\n\n## BeforeAdvice\n\nperson接口：\n\n```java\npublic interface Person {\n    void speak(String name);\n    void run(String time);\n}\n```\n\n 具体实现类：\n\n```java\npublic class Man implements Person{\n    public void speak(String name) {\n        System.out.println(\"speak to \"+name);\n    }\n\n    public void run(String time) {\n        System.out.println(\"runing \"+time);\n    }\n}\n```\n\n增强类：执行Speak或者run方法之前执行\n\n```java\npublic class PersonBeforeAdvice implements MethodBeforeAdvice {\n    public void before(Method method, Object[] objects, Object obj) throws Throwable {\n        String name=(String)objects[0];\n        System.out.println(\"Hi! Mr \"+name);\n    }\n}\n```\n\nPersonBeforeAdvice接口仅定义了唯一的方法：before(Method method,Object[] args,Object obj)throws Throwable,其中method为目标类的方法；objects为目标类方法的入参，而obj为目标类实例。当方法发生异常时，将阻止目标类方法的执行。\n\nxml文件配置：\n\n```xml\n<bean id=\"manBefore\" class=\"com.aop.advice.ManBeforeAdvice\" />\n<bean id=\"target\" class=\"com.aop.advice.Man\" />\n<bean id=\"manman\" class=\"org.springframework.aop.framework.ProxyFactoryBean\"\n\t  p:interceptorNames=\"manBefore\"\n      p:proxyInterfaces=\"com.aop.advice.Person\" \n\t  p:target-ref=\"target\"\n\t  p:proxyTargetClass=\"true\"/>\n```\n\n测试类：\n\n```java\npublic class BeforeAdviceTest {\n    @Test\n    public void before(){\n        Person target=new Man();\n        BeforeAdvice advice=new ManBeforeAdvice();\n\n        //①Spring提供的代理工厂\n        ProxyFactory pf=new ProxyFactory();\n        //②设置代理目标\n        pf.setTarget(target);\n        //③为代理目标添加增强\n        pf.addAdvice(advice);\n        //④生成代理实例\n        Person proxy=(Person) pf.getProxy();\n        proxy.speak(\"gubaidan\");\n        proxy.run(\"2017-11-09\");\n    }\n}\n```\n\n输出：\n\n```shell\nHi Mr gubaidan        //增强效果\nspeak to gubaidan\nHi mr gubaidan        //增强效果\nrunning 2017-11-09\n```\n\n## 解析ProxyFactory\n\n在BeforeAdviceTest中，使用org.springframework.aop.framework.ProxyFactory代理工厂将GreetingBeforeAdvice的增强织入目标类NaiveWaiter中。ProxyFactory内部就是使用JDK或CGLib动态代理技术将增强应用到目标类中的。\n\nCglib2AopProxy使用CGLib动态代理技术创建代理，而JdkDynamicAopProxy使用JDK动态代理技术创建代理。 如果通过ProxyFactory的setInterfaces(Class[] interfaces)方法指定目标接口进行代理，则ProxyFactory使JdkDynamicAopProxy。\n\n> 如果是针对类的代理，则使用Cglib2AopProxy。 \n\n还可以通过ProxyFactory的setOptimize(true)方法让ProxyFactory启动优化代理方式，这样，针对接口的代理也会使用Cglib2AopProxy。\n\nBeforeAdviceTest使用的是CGLib动态代理技术，当我们指定接口进行代理时，将使用JDK动态代理技术\n\n```java\n//①Spring提供的代理工厂\nProxyFactory pf=new ProxyFactory();\n//②设置代理目标\npf.setInterfaces(target.getClass().getInterfaces());//指定接口进行代理\npf.setTarget(target);\n```\n\n如果指定启动代理优化，则ProxyFactory还将使用Cglib2AopProxy代理\n\n```java\n//①Spring提供的代理工厂\nProxyFactory pf=new ProxyFactory();\n//②设置代理目标\npf.setInterfaces(target.getClass().getInterfaces());//指定接口进行代理\npf.setTarget(target);\npf.setOpaque(true);   //启动优化\n```\n\nProxyFactory通过addAdvice(Advice)方法添加一个增强，可以使用该方法添加多个增强。多个增强形成一个增强链，它们的调用顺序和添加顺序一致，可以通过addAdvice(int ,Advice)方法将增强添加到增强链的具体位置(初始位置为0)\n\nProxyFactoryBean是FactoryBean接口的实现类，FactoryBean负责实例化一个Bean。ProxyFactoryBean负责为其他Bean创建代理实例，它在内部使用ProxyFactory来完成这项工作。\n\nProxyFactoryBean的几个常用的可配置属性 :\n\n- target：代理的目标对象 \n- proxyInterfaces：代理所要实现的接口，可以是多个接口 \n- interceptorNames：需要织入目标对象的Bean列表，采用Bean的名称指定。这些Bean必须是实现了org.aopalliance.intercept.MethodInterceptor或org.springframework.aop.Advisor的Bean，配置中的顺序对应调用的顺序。 \n- singleton：返回的代理是否单实例，默认为单实例。 \n- optimize：当设置为true时，强制使用CGLib动态代理。对于singleton的代理，推荐使用CGLib；对于其他作用域类型的代理，最好使用JDK动态代理 \n- proxyTargetClass：是否对类进行代理（而不是对接口进行代理）。当设置为true时，使用CGLib动态代理\n\n \n\n## 引介增强\n\n引介增强为目标类创建新的方法和属性，所以引介增强的连接点是类级别的，而非方法级别的。通过引介增强，可以为目标类添加一个接口的实现，可以为目标类创建实现某接口的代理。\n\nSpring定义了引介增强接口IntroductionInterceptor，该接口没有定义任何方法，Spring为其提供了DelagatingIntroductionInterceptor实现类。一般情况下，通过扩展该实现类定义自己的引介增强类。\n\n前面性能监视的例子，我们对所有的业务类都织入了性能监视的增强。由于性能监视会影响业务系统的性能，所以是否启动性能监视应该是可控的。现在通过引介增强来实现。\n\n首先定义一个用于标识目标类是否支持性能监视的接口：\n\n```java\npublic interface Monitorable {\n    void setMonitorActive(boolean active);\n}\n```\n\n通过setMonitorActive(boolean active)接口方法控制业务类性能监视功能的激活和关闭状态\n\n下面通过扩展DelegatingIntroductionInterceptor为目标类引入性能监视的可控功能\n\n```java\npublic class ControllablePerformanceMonitor extends DelegatingIntroductionInterceptor implements Monitorable{\n   private ThreadLocal<Boolean> MonitorStatusMap=new ThreadLocal<Boolean>(); //①\n\n   public void setMonitorActive(boolean active){   //②\n       MonitorStatusMap.set(active);\n   }\n\n   //③拦截方法\n    public Object invoke(MethodInvocation mi) throws Throwable {\n        Object obj=null;\n        //④对于支持性能监视可控代理，通过判断其状态决定是否开启性能监视功能\n        if(MonitorStatusMap.get()!=null&&MonitorStatusMap.get()){\n            PerformanceMonitor.begin(mi.getClass().getName()+\".\"+mi.getMethod().getName());\n            obj=super.invoke(mi);\n            PerformanceMonitor.end();\n        }else{\n            obj=super.invoke(mi);\n        }\n        return obj;\n    }\n}\n```\n\n\n\n扩展DelegatingIntroductionInterceptor的同时还实现了Monitorable接口，提供接口方法的实现。 \n在①定义了一个ThreadLocal类型的变量，用于保存性能监视开关状态，为了解决单实例singleton线程安全的问题，通过ThreadLocal让每个线程单独使用一个状态。\n\n在③中覆盖了父类中的invoke()方法，该方法用于拦截目标类方法的调用，根据开关状态有条件地对目标实例方法进行性能监视。 \n\n在④处，MonitorStatusMap.get()方法返回的Boolean被自动拆包为boolean类型的值\n\n通过Spring配置，将这个引介增强织入业务类ForumService中 \n\n```xml\n<bean id=\"pmonitor\" class=\"com.smart.introduce.ControllablePerformaceMonitor\" />\n<bean id=\"forumServiceTarget\" class=\"com.smart.introduce.ForumService\" />\n<bean id=\"forumService\" class=\"org.springframework.aop.framework.ProxyFactoryBean\"\n\tp:interfaces=\"com.smart.introduce.Monitorable\"\n\tp:target-ref=\"forumServiceTarget\"\n\tp:interceptorNames=\"pmonitor\" \n\tp:proxyTargetClass=\"true\" />\n```\n\n首先，需要指定引介增强所实现的接口，如①。其次，由于只能通过为目标创建子类的方法生成引介增强的代理，所以必须将proxyTargetClass设置为true\n\n如果没对ControllablePerformanceMonitor进行线程安全的特殊处理，就必须将singleton属性设置为true，让ProxyFactoryBean产生prototype作用域类型的代码。当CGLib动态创建代理的性能很低，而每次通过getBean()方法中从容器中获取作用域类型为prototype的Bean时都将返回一个新的代理实例，这种性能影响是巨大的，这就是为什么通过ThreadLocal对ControllablePerformanceMonitor的开关状态进行线程安全化处理的原因。 \n\n通过线程安全化处理后，就可以使用默认的singleton Bean作用域，这样创建代理的动作仅发生一次。\n\n```java\npublic class IntroduceTest {\n    @Test\n    public void introduce(){\n        String configPath=\"com/smart/introduce/beans.xml\";\n        ApplicationContext ctx=new ClassPathXmlApplicationContext(configPath);\n        ForumService forumService=(ForumService)ctx.getBean(\"forumService\");\n\n        forumService.removeForum(10);    //默认情况下未开启性能监视功能\n        forumService.removeTopic(1024);\n        Monitorable monitorable=(Monitorable)forumService;  //开启性能监视，实现了Monitorable接口\n        monitorable.setMonitorActive(true);\n        forumService.removeForum(10);\n        forumService.removeTopic(1024);\n    }\n}\n```\n\n ②处，强制性地将forumService转换为Monitorable类型，代码的成功执行表示从Spring容器中返回的代理确实引入了Monitorable接口方法的实现。\n\n\n\n# 以XML方式配置切面\n\n## 简介\n\n除了使用AspectJ注解声明切面，Spring也支持在bean配置文件中声明切面。这种声明是通过aop名称空间中的XML元素完成的。\n\n正常情况下，基于注解的声明要优先于基于XML的声明。通过AspectJ注解，切面可以与AspectJ兼容，而基于XML的配置则是Spring专有的。由于AspectJ得到\n\n越来越多的 AOP框架支持，所以以注解风格编写的切面将会有更多重用的机会。\n\n## 配置细节\n\n在bean配置文件中，所有的Spring AOP配置都必须定义在<aop:config>元素内部。对于每个切面而言，都要创建一个<aop:aspect>元素来为具体的切面实现\n\n引用后端bean实例。切面bean必须有一个标识符，供<aop:aspect>元素引用。\n\n```xml\n&lt;bean id=\"logAspect\" class=\"com.atguigu.aspect.LogAspect\"&gt;&lt;/bean&gt;\n&lt;bean id=\"validatorAspect\" class=\"com.atguigu.aspect.ValidatorAspect\"&gt;&lt;/bean&gt;\n&lt;bean id=\"mathCalulator\" class=\"com.atguigu.calulator.MathCalulator\"&gt;&lt;/bean&gt;\n&lt;aop:config&gt;\n\t&lt;aop:aspect ref=\"logAspect\"&gt;&lt;/aop:aspect&gt;\n\t&lt;aop:aspect ref=\"validatorAspect\"&gt;&lt;/aop:aspect&gt;\n&lt;/aop:config&gt;\n\n```\n\n## 声明切入点\n\n切入点使用<aop:pointcut>元素声明。 \n\n切入点必须定义在<aop:aspect>元素下，或者直接定义在<aop:config>元素下。 \n\n定义在<aop:aspect>元素下：只对当前切面有效 \n\n定义在<aop:config>元素下：对所有切面都有效 \n\n基于XML的AOP配置不允许在切入点表达式中用名称引用其他切入点。\n\n```xml\n&lt;aop:pointcut expression=\"execution(* *.*(..))\" id=\"mypoint\"/&gt;\n```\n\n\n\n## 声明通知\n\n在aop名称空间中，每种通知类型都对应一个特定的XML元素。 通知元素需要使用<pointcut-ref>来引用切入点，或用<pointcut>直接嵌入切入点表达式。 method属性指定切面类中通知方法的名称\n\n```xml\n&lt;aop:before method=\"logStart\" pointcut=\"execution(* *.*(..))\"/\n```\n\n\n# 最后\n\n编程的意义是解决和简化手工劳动，而AOP的意义则是简化代码开发。\n\n>参考：《Spring技术内幕》、《精通Spring 4.x 企业应用开发实战》","source":"_posts/2017-11-9-spring-aop.markdown","raw":"---\nlayout: post\ntitle: \"Spring | AOP理解及实现\"\ndate: 2017-11-09 13:20\nauthor: \"Gubaidan\"\nheader-img: \"/Header/RbM63-XsLUY.png\"\ncdn: 'header-on'\ntags:\n\t- Spring\n---\n\n# AOP是什么\n\n在简单的了解过AOP之后，被“面向方面编程”、“面向切面编程”、“切点”、“切面”这些术语搞的糊里糊涂，简单来说AOP是Aspect Origented Programing的简称，根据字面意思确实是面向切面编程，那么这个词到底又是什么意思？\n\n按照软件重构的思想，如果一个类在多个方法或者类中出现相同的代码，我们就认为可以将这些代码提取到父类，但是有些代码例如在代码执行前得到执行开始时间，执行后获得结束时间，这样用来统计执行时间的代码可能隐藏在一堆杂乱的代码之中，这样的话通过父类继承的方式是无法实现的，这也就是AOP将要解决的问题。\n\n> 我的通俗理解就是：**在某个方法执行前后动态的为其插入想要执行的方法或者代码。**\n\n# AOP术语\n\n**连接点（Joinpoint）:**特定点是程序执行的某个特定位置，如类开始初始化前，类初始化后，类的某个方法调用前/后，方法抛出异常后。一个类或一段代码拥有一些具有边界性质的特定点，这些代码中的特定点就被称为“连接点”。 \n\nSpring仅支持方法的连接点，即仅能在方法调用前，方法调用后，方法抛出异常时及方法调用前后这些程序执行点织入增强。 \n\n连接点由两个信息确定：一是用方法表示的程序执行点，二是用相对位置表示的方位。如在Test.foo()方法执行前的连接点，执行点为Test.foo(),方法为该方法执行前的位置。Spring使用切点对执行点进行定位，而方位则在增强类型中增强\n\n**切点(Pointcut）:**每个程序类都有多个连接点，如一个拥有两个方法的类，这两个方法就是连接点，即连接点是程序类中客观存在的事物。AOP通过“切点”定位特定的连接点。连接点相当于数据库中的记录，而切点相当于查询条件，一个切点可以匹配多个连接点。\n\n在Spring中，切点通过org.springframework.aop.Pointcut接口进行描述，它使用类和方法作为连接点的查询条件。Spring AOP的规则解析引擎负责解析切点所设定的查询条件，找到对应的连接点。确切地说，应该是执行点而非连接点，因为连接点是方法执行前/后等包括方位信息的具体程序执行点，而切点只定位到某个方法上，所以如果希望定位到具体的连接点上，需要提供方位信息\n\n**增强（Advice）:**增强是织入目标类连接点上的一段程序代码。在Spring中，增强除用于描述一段程序代码外，还拥有另一个和连接点相关的信息，就是执行点的方位。结合执行点的方位信息和切点信息，就可以找到特定的连接。 \n\n正因为增强即包含由于添加到目标连接点上的一段执行逻辑，又包含用于定位连接点的方位信息，所以Spring所提供的增强接口都是带方位名的，如BeforeAdivce，AfterReturningAdvice和ThrowsAdvice等。BeforeAdvice表示方法调用前的位置，而AfterReturningAdvice表示访问后的位置。 所以只有结合切点和增强，才能确定特定的连接点并实施逻辑增强。\n\n**目标对象(Target)  :**增强逻辑的织入目标类。如果没有AOP，那么目标业务类需要自己实现所有的逻辑.\n\n在AOP的帮助下，ForumService只实现那些非横切逻辑的程序逻辑，而性能监视和事务管理等这些横切逻辑就可以使用AOP动态织入特定的连接点上\n\n**引介（Introduction）:** 引介是一种特殊的增强，为类添加一些属性和方法。这样，即使一个业务类原本没有实现某个接口，通过AOP的引介功能，也可以动态地为该业务类添加接口的实现逻辑，使业务类成为这个接口的实现类\n\n**织入(Weaving)  :** 织入是将增强添加到目标类的具体连接点上的过程.AOP就像一台织布机，将目标类，增强或引介编织到一切。 \n\n**AOP有三种织入方式：** \n\n- 编译期织入，这要求使用特殊的Java编译器 \n- 类装载期织入，这要求使用特殊的类装载器 \n- 动态代理织入，在运行期为目标类添加增强生成子类的方式，Spring采用动态代理织入\n\n**代理（Proxy)  :** 一个类被AOP织入增强后，就产生一个结果类，它是融合了原类和增强逻辑的代理类。根据不同的代理方式，代理类既可能是和原类具有相同接口的类，也可能就是原类的子类，所以可以采用与调用原类相同的方式调用代理类。\n\n**切面（Aspect)  :**切面由切点和增强（引介）组成，既包括横切逻辑的定义，也包括连接点的定义。Spring AOP就是负责实施切面的框架，它将切面所定义的横切逻辑织入切面所指定的连接点中\n\n# 基础知识\n\nSpring AOP使用了两种代理机制：一种是基于JDK的动态代理；另一种是基于CGLib的动态代理。 \n之所以需要两种代理机制，是因为JDK本身只提供接口的代理，而不支持类的代理。\n\nCGLib所创建的动态代理对象的性能比JDK所创建的动态代理对象的性能高很多，但CGLib在创建代理对象时所花费的时间比JDK动态代理多。  对于singleton的代理对象或者具有实例池的代理，因为无需频繁地创建代理对象，所以比较适合采用CGLib动态代理技术；反之适合采用JDK动态代理技术。\n\n# 实现者\n\n按照增强在目标类方法中的连接点位置，可以分为5类：\n\n- 前置增强：org.springframework.aop.BeforeAdvice代表前置增强，因为Spring只支持方法级的增强，所以MethodBeforeAdvice是目前可用的前置增强，表示在目标方法执行前实施增强，而BeforeAdvice是为了将来版本扩展需要而定义的。\n\n- 后置增强：org.springframework.aop.AfterReturningAdvice代表后置增强，表示在目标方法执行后实施增强。\n\n- 环绕增强：org.aopalliance.intercept.MethodInterceptor代表环绕增强，表示在目标方法执行前后实施增强。\n\n- 异常抛出增强：org.springframework.aop.ThrowsAdvice代表抛出异常增强，表示在目标方法抛出异常后实施增强。\n\n- 引介增强：org.springframework.aop.IntroductionInterceptor代表引介增强，表示在目标类中添加一些新的方法和属性\n\n## BeforeAdvice\n\nperson接口：\n\n```java\npublic interface Person {\n    void speak(String name);\n    void run(String time);\n}\n```\n\n 具体实现类：\n\n```java\npublic class Man implements Person{\n    public void speak(String name) {\n        System.out.println(\"speak to \"+name);\n    }\n\n    public void run(String time) {\n        System.out.println(\"runing \"+time);\n    }\n}\n```\n\n增强类：执行Speak或者run方法之前执行\n\n```java\npublic class PersonBeforeAdvice implements MethodBeforeAdvice {\n    public void before(Method method, Object[] objects, Object obj) throws Throwable {\n        String name=(String)objects[0];\n        System.out.println(\"Hi! Mr \"+name);\n    }\n}\n```\n\nPersonBeforeAdvice接口仅定义了唯一的方法：before(Method method,Object[] args,Object obj)throws Throwable,其中method为目标类的方法；objects为目标类方法的入参，而obj为目标类实例。当方法发生异常时，将阻止目标类方法的执行。\n\nxml文件配置：\n\n```xml\n<bean id=\"manBefore\" class=\"com.aop.advice.ManBeforeAdvice\" />\n<bean id=\"target\" class=\"com.aop.advice.Man\" />\n<bean id=\"manman\" class=\"org.springframework.aop.framework.ProxyFactoryBean\"\n\t  p:interceptorNames=\"manBefore\"\n      p:proxyInterfaces=\"com.aop.advice.Person\" \n\t  p:target-ref=\"target\"\n\t  p:proxyTargetClass=\"true\"/>\n```\n\n测试类：\n\n```java\npublic class BeforeAdviceTest {\n    @Test\n    public void before(){\n        Person target=new Man();\n        BeforeAdvice advice=new ManBeforeAdvice();\n\n        //①Spring提供的代理工厂\n        ProxyFactory pf=new ProxyFactory();\n        //②设置代理目标\n        pf.setTarget(target);\n        //③为代理目标添加增强\n        pf.addAdvice(advice);\n        //④生成代理实例\n        Person proxy=(Person) pf.getProxy();\n        proxy.speak(\"gubaidan\");\n        proxy.run(\"2017-11-09\");\n    }\n}\n```\n\n输出：\n\n```shell\nHi Mr gubaidan        //增强效果\nspeak to gubaidan\nHi mr gubaidan        //增强效果\nrunning 2017-11-09\n```\n\n## 解析ProxyFactory\n\n在BeforeAdviceTest中，使用org.springframework.aop.framework.ProxyFactory代理工厂将GreetingBeforeAdvice的增强织入目标类NaiveWaiter中。ProxyFactory内部就是使用JDK或CGLib动态代理技术将增强应用到目标类中的。\n\nCglib2AopProxy使用CGLib动态代理技术创建代理，而JdkDynamicAopProxy使用JDK动态代理技术创建代理。 如果通过ProxyFactory的setInterfaces(Class[] interfaces)方法指定目标接口进行代理，则ProxyFactory使JdkDynamicAopProxy。\n\n> 如果是针对类的代理，则使用Cglib2AopProxy。 \n\n还可以通过ProxyFactory的setOptimize(true)方法让ProxyFactory启动优化代理方式，这样，针对接口的代理也会使用Cglib2AopProxy。\n\nBeforeAdviceTest使用的是CGLib动态代理技术，当我们指定接口进行代理时，将使用JDK动态代理技术\n\n```java\n//①Spring提供的代理工厂\nProxyFactory pf=new ProxyFactory();\n//②设置代理目标\npf.setInterfaces(target.getClass().getInterfaces());//指定接口进行代理\npf.setTarget(target);\n```\n\n如果指定启动代理优化，则ProxyFactory还将使用Cglib2AopProxy代理\n\n```java\n//①Spring提供的代理工厂\nProxyFactory pf=new ProxyFactory();\n//②设置代理目标\npf.setInterfaces(target.getClass().getInterfaces());//指定接口进行代理\npf.setTarget(target);\npf.setOpaque(true);   //启动优化\n```\n\nProxyFactory通过addAdvice(Advice)方法添加一个增强，可以使用该方法添加多个增强。多个增强形成一个增强链，它们的调用顺序和添加顺序一致，可以通过addAdvice(int ,Advice)方法将增强添加到增强链的具体位置(初始位置为0)\n\nProxyFactoryBean是FactoryBean接口的实现类，FactoryBean负责实例化一个Bean。ProxyFactoryBean负责为其他Bean创建代理实例，它在内部使用ProxyFactory来完成这项工作。\n\nProxyFactoryBean的几个常用的可配置属性 :\n\n- target：代理的目标对象 \n- proxyInterfaces：代理所要实现的接口，可以是多个接口 \n- interceptorNames：需要织入目标对象的Bean列表，采用Bean的名称指定。这些Bean必须是实现了org.aopalliance.intercept.MethodInterceptor或org.springframework.aop.Advisor的Bean，配置中的顺序对应调用的顺序。 \n- singleton：返回的代理是否单实例，默认为单实例。 \n- optimize：当设置为true时，强制使用CGLib动态代理。对于singleton的代理，推荐使用CGLib；对于其他作用域类型的代理，最好使用JDK动态代理 \n- proxyTargetClass：是否对类进行代理（而不是对接口进行代理）。当设置为true时，使用CGLib动态代理\n\n \n\n## 引介增强\n\n引介增强为目标类创建新的方法和属性，所以引介增强的连接点是类级别的，而非方法级别的。通过引介增强，可以为目标类添加一个接口的实现，可以为目标类创建实现某接口的代理。\n\nSpring定义了引介增强接口IntroductionInterceptor，该接口没有定义任何方法，Spring为其提供了DelagatingIntroductionInterceptor实现类。一般情况下，通过扩展该实现类定义自己的引介增强类。\n\n前面性能监视的例子，我们对所有的业务类都织入了性能监视的增强。由于性能监视会影响业务系统的性能，所以是否启动性能监视应该是可控的。现在通过引介增强来实现。\n\n首先定义一个用于标识目标类是否支持性能监视的接口：\n\n```java\npublic interface Monitorable {\n    void setMonitorActive(boolean active);\n}\n```\n\n通过setMonitorActive(boolean active)接口方法控制业务类性能监视功能的激活和关闭状态\n\n下面通过扩展DelegatingIntroductionInterceptor为目标类引入性能监视的可控功能\n\n```java\npublic class ControllablePerformanceMonitor extends DelegatingIntroductionInterceptor implements Monitorable{\n   private ThreadLocal<Boolean> MonitorStatusMap=new ThreadLocal<Boolean>(); //①\n\n   public void setMonitorActive(boolean active){   //②\n       MonitorStatusMap.set(active);\n   }\n\n   //③拦截方法\n    public Object invoke(MethodInvocation mi) throws Throwable {\n        Object obj=null;\n        //④对于支持性能监视可控代理，通过判断其状态决定是否开启性能监视功能\n        if(MonitorStatusMap.get()!=null&&MonitorStatusMap.get()){\n            PerformanceMonitor.begin(mi.getClass().getName()+\".\"+mi.getMethod().getName());\n            obj=super.invoke(mi);\n            PerformanceMonitor.end();\n        }else{\n            obj=super.invoke(mi);\n        }\n        return obj;\n    }\n}\n```\n\n\n\n扩展DelegatingIntroductionInterceptor的同时还实现了Monitorable接口，提供接口方法的实现。 \n在①定义了一个ThreadLocal类型的变量，用于保存性能监视开关状态，为了解决单实例singleton线程安全的问题，通过ThreadLocal让每个线程单独使用一个状态。\n\n在③中覆盖了父类中的invoke()方法，该方法用于拦截目标类方法的调用，根据开关状态有条件地对目标实例方法进行性能监视。 \n\n在④处，MonitorStatusMap.get()方法返回的Boolean被自动拆包为boolean类型的值\n\n通过Spring配置，将这个引介增强织入业务类ForumService中 \n\n```xml\n<bean id=\"pmonitor\" class=\"com.smart.introduce.ControllablePerformaceMonitor\" />\n<bean id=\"forumServiceTarget\" class=\"com.smart.introduce.ForumService\" />\n<bean id=\"forumService\" class=\"org.springframework.aop.framework.ProxyFactoryBean\"\n\tp:interfaces=\"com.smart.introduce.Monitorable\"\n\tp:target-ref=\"forumServiceTarget\"\n\tp:interceptorNames=\"pmonitor\" \n\tp:proxyTargetClass=\"true\" />\n```\n\n首先，需要指定引介增强所实现的接口，如①。其次，由于只能通过为目标创建子类的方法生成引介增强的代理，所以必须将proxyTargetClass设置为true\n\n如果没对ControllablePerformanceMonitor进行线程安全的特殊处理，就必须将singleton属性设置为true，让ProxyFactoryBean产生prototype作用域类型的代码。当CGLib动态创建代理的性能很低，而每次通过getBean()方法中从容器中获取作用域类型为prototype的Bean时都将返回一个新的代理实例，这种性能影响是巨大的，这就是为什么通过ThreadLocal对ControllablePerformanceMonitor的开关状态进行线程安全化处理的原因。 \n\n通过线程安全化处理后，就可以使用默认的singleton Bean作用域，这样创建代理的动作仅发生一次。\n\n```java\npublic class IntroduceTest {\n    @Test\n    public void introduce(){\n        String configPath=\"com/smart/introduce/beans.xml\";\n        ApplicationContext ctx=new ClassPathXmlApplicationContext(configPath);\n        ForumService forumService=(ForumService)ctx.getBean(\"forumService\");\n\n        forumService.removeForum(10);    //默认情况下未开启性能监视功能\n        forumService.removeTopic(1024);\n        Monitorable monitorable=(Monitorable)forumService;  //开启性能监视，实现了Monitorable接口\n        monitorable.setMonitorActive(true);\n        forumService.removeForum(10);\n        forumService.removeTopic(1024);\n    }\n}\n```\n\n ②处，强制性地将forumService转换为Monitorable类型，代码的成功执行表示从Spring容器中返回的代理确实引入了Monitorable接口方法的实现。\n\n\n\n# 以XML方式配置切面\n\n## 简介\n\n除了使用AspectJ注解声明切面，Spring也支持在bean配置文件中声明切面。这种声明是通过aop名称空间中的XML元素完成的。\n\n正常情况下，基于注解的声明要优先于基于XML的声明。通过AspectJ注解，切面可以与AspectJ兼容，而基于XML的配置则是Spring专有的。由于AspectJ得到\n\n越来越多的 AOP框架支持，所以以注解风格编写的切面将会有更多重用的机会。\n\n## 配置细节\n\n在bean配置文件中，所有的Spring AOP配置都必须定义在<aop:config>元素内部。对于每个切面而言，都要创建一个<aop:aspect>元素来为具体的切面实现\n\n引用后端bean实例。切面bean必须有一个标识符，供<aop:aspect>元素引用。\n\n```xml\n&lt;bean id=\"logAspect\" class=\"com.atguigu.aspect.LogAspect\"&gt;&lt;/bean&gt;\n&lt;bean id=\"validatorAspect\" class=\"com.atguigu.aspect.ValidatorAspect\"&gt;&lt;/bean&gt;\n&lt;bean id=\"mathCalulator\" class=\"com.atguigu.calulator.MathCalulator\"&gt;&lt;/bean&gt;\n&lt;aop:config&gt;\n\t&lt;aop:aspect ref=\"logAspect\"&gt;&lt;/aop:aspect&gt;\n\t&lt;aop:aspect ref=\"validatorAspect\"&gt;&lt;/aop:aspect&gt;\n&lt;/aop:config&gt;\n\n```\n\n## 声明切入点\n\n切入点使用<aop:pointcut>元素声明。 \n\n切入点必须定义在<aop:aspect>元素下，或者直接定义在<aop:config>元素下。 \n\n定义在<aop:aspect>元素下：只对当前切面有效 \n\n定义在<aop:config>元素下：对所有切面都有效 \n\n基于XML的AOP配置不允许在切入点表达式中用名称引用其他切入点。\n\n```xml\n&lt;aop:pointcut expression=\"execution(* *.*(..))\" id=\"mypoint\"/&gt;\n```\n\n\n\n## 声明通知\n\n在aop名称空间中，每种通知类型都对应一个特定的XML元素。 通知元素需要使用<pointcut-ref>来引用切入点，或用<pointcut>直接嵌入切入点表达式。 method属性指定切面类中通知方法的名称\n\n```xml\n&lt;aop:before method=\"logStart\" pointcut=\"execution(* *.*(..))\"/\n```\n\n\n# 最后\n\n编程的意义是解决和简化手工劳动，而AOP的意义则是简化代码开发。\n\n>参考：《Spring技术内幕》、《精通Spring 4.x 企业应用开发实战》","slug":"2017-11-9-spring-aop","published":1,"updated":"2018-07-14T07:38:40.982Z","comments":1,"photos":[],"link":"","_id":"cjvayvwgp002bm46a825bgmph","content":"<h1 id=\"AOP是什么\"><a href=\"#AOP是什么\" class=\"headerlink\" title=\"AOP是什么\"></a>AOP是什么</h1><p>在简单的了解过AOP之后，被“面向方面编程”、“面向切面编程”、“切点”、“切面”这些术语搞的糊里糊涂，简单来说AOP是Aspect Origented Programing的简称，根据字面意思确实是面向切面编程，那么这个词到底又是什么意思？</p>\n<p>按照软件重构的思想，如果一个类在多个方法或者类中出现相同的代码，我们就认为可以将这些代码提取到父类，但是有些代码例如在代码执行前得到执行开始时间，执行后获得结束时间，这样用来统计执行时间的代码可能隐藏在一堆杂乱的代码之中，这样的话通过父类继承的方式是无法实现的，这也就是AOP将要解决的问题。</p>\n<blockquote>\n<p>我的通俗理解就是：<strong>在某个方法执行前后动态的为其插入想要执行的方法或者代码。</strong></p>\n</blockquote>\n<h1 id=\"AOP术语\"><a href=\"#AOP术语\" class=\"headerlink\" title=\"AOP术语\"></a>AOP术语</h1><p><strong>连接点（Joinpoint）:</strong>特定点是程序执行的某个特定位置，如类开始初始化前，类初始化后，类的某个方法调用前/后，方法抛出异常后。一个类或一段代码拥有一些具有边界性质的特定点，这些代码中的特定点就被称为“连接点”。 </p>\n<p>Spring仅支持方法的连接点，即仅能在方法调用前，方法调用后，方法抛出异常时及方法调用前后这些程序执行点织入增强。 </p>\n<p>连接点由两个信息确定：一是用方法表示的程序执行点，二是用相对位置表示的方位。如在Test.foo()方法执行前的连接点，执行点为Test.foo(),方法为该方法执行前的位置。Spring使用切点对执行点进行定位，而方位则在增强类型中增强</p>\n<p><strong>切点(Pointcut）:</strong>每个程序类都有多个连接点，如一个拥有两个方法的类，这两个方法就是连接点，即连接点是程序类中客观存在的事物。AOP通过“切点”定位特定的连接点。连接点相当于数据库中的记录，而切点相当于查询条件，一个切点可以匹配多个连接点。</p>\n<p>在Spring中，切点通过org.springframework.aop.Pointcut接口进行描述，它使用类和方法作为连接点的查询条件。Spring AOP的规则解析引擎负责解析切点所设定的查询条件，找到对应的连接点。确切地说，应该是执行点而非连接点，因为连接点是方法执行前/后等包括方位信息的具体程序执行点，而切点只定位到某个方法上，所以如果希望定位到具体的连接点上，需要提供方位信息</p>\n<p><strong>增强（Advice）:</strong>增强是织入目标类连接点上的一段程序代码。在Spring中，增强除用于描述一段程序代码外，还拥有另一个和连接点相关的信息，就是执行点的方位。结合执行点的方位信息和切点信息，就可以找到特定的连接。 </p>\n<p>正因为增强即包含由于添加到目标连接点上的一段执行逻辑，又包含用于定位连接点的方位信息，所以Spring所提供的增强接口都是带方位名的，如BeforeAdivce，AfterReturningAdvice和ThrowsAdvice等。BeforeAdvice表示方法调用前的位置，而AfterReturningAdvice表示访问后的位置。 所以只有结合切点和增强，才能确定特定的连接点并实施逻辑增强。</p>\n<p><strong>目标对象(Target)  :</strong>增强逻辑的织入目标类。如果没有AOP，那么目标业务类需要自己实现所有的逻辑.</p>\n<p>在AOP的帮助下，ForumService只实现那些非横切逻辑的程序逻辑，而性能监视和事务管理等这些横切逻辑就可以使用AOP动态织入特定的连接点上</p>\n<p><strong>引介（Introduction）:</strong> 引介是一种特殊的增强，为类添加一些属性和方法。这样，即使一个业务类原本没有实现某个接口，通过AOP的引介功能，也可以动态地为该业务类添加接口的实现逻辑，使业务类成为这个接口的实现类</p>\n<p><strong>织入(Weaving)  :</strong> 织入是将增强添加到目标类的具体连接点上的过程.AOP就像一台织布机，将目标类，增强或引介编织到一切。 </p>\n<p><strong>AOP有三种织入方式：</strong> </p>\n<ul>\n<li>编译期织入，这要求使用特殊的Java编译器 </li>\n<li>类装载期织入，这要求使用特殊的类装载器 </li>\n<li>动态代理织入，在运行期为目标类添加增强生成子类的方式，Spring采用动态代理织入</li>\n</ul>\n<p><strong>代理（Proxy)  :</strong> 一个类被AOP织入增强后，就产生一个结果类，它是融合了原类和增强逻辑的代理类。根据不同的代理方式，代理类既可能是和原类具有相同接口的类，也可能就是原类的子类，所以可以采用与调用原类相同的方式调用代理类。</p>\n<p><strong>切面（Aspect)  :</strong>切面由切点和增强（引介）组成，既包括横切逻辑的定义，也包括连接点的定义。Spring AOP就是负责实施切面的框架，它将切面所定义的横切逻辑织入切面所指定的连接点中</p>\n<h1 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h1><p>Spring AOP使用了两种代理机制：一种是基于JDK的动态代理；另一种是基于CGLib的动态代理。<br>之所以需要两种代理机制，是因为JDK本身只提供接口的代理，而不支持类的代理。</p>\n<p>CGLib所创建的动态代理对象的性能比JDK所创建的动态代理对象的性能高很多，但CGLib在创建代理对象时所花费的时间比JDK动态代理多。  对于singleton的代理对象或者具有实例池的代理，因为无需频繁地创建代理对象，所以比较适合采用CGLib动态代理技术；反之适合采用JDK动态代理技术。</p>\n<h1 id=\"实现者\"><a href=\"#实现者\" class=\"headerlink\" title=\"实现者\"></a>实现者</h1><p>按照增强在目标类方法中的连接点位置，可以分为5类：</p>\n<ul>\n<li><p>前置增强：org.springframework.aop.BeforeAdvice代表前置增强，因为Spring只支持方法级的增强，所以MethodBeforeAdvice是目前可用的前置增强，表示在目标方法执行前实施增强，而BeforeAdvice是为了将来版本扩展需要而定义的。</p>\n</li>\n<li><p>后置增强：org.springframework.aop.AfterReturningAdvice代表后置增强，表示在目标方法执行后实施增强。</p>\n</li>\n<li><p>环绕增强：org.aopalliance.intercept.MethodInterceptor代表环绕增强，表示在目标方法执行前后实施增强。</p>\n</li>\n<li><p>异常抛出增强：org.springframework.aop.ThrowsAdvice代表抛出异常增强，表示在目标方法抛出异常后实施增强。</p>\n</li>\n<li><p>引介增强：org.springframework.aop.IntroductionInterceptor代表引介增强，表示在目标类中添加一些新的方法和属性</p>\n</li>\n</ul>\n<h2 id=\"BeforeAdvice\"><a href=\"#BeforeAdvice\" class=\"headerlink\" title=\"BeforeAdvice\"></a>BeforeAdvice</h2><p>person接口：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">speak</span><span class=\"params\">(String name)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">(String time)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p> 具体实现类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Man</span> <span class=\"keyword\">implements</span> <span class=\"title\">Person</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">speak</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"speak to \"</span>+name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">(String time)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"runing \"</span>+time);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>增强类：执行Speak或者run方法之前执行</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PersonBeforeAdvice</span> <span class=\"keyword\">implements</span> <span class=\"title\">MethodBeforeAdvice</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">before</span><span class=\"params\">(Method method, Object[] objects, Object obj)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">        String name=(String)objects[<span class=\"number\">0</span>];</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Hi! Mr \"</span>+name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>PersonBeforeAdvice接口仅定义了唯一的方法：before(Method method,Object[] args,Object obj)throws Throwable,其中method为目标类的方法；objects为目标类方法的入参，而obj为目标类实例。当方法发生异常时，将阻止目标类方法的执行。</p>\n<p>xml文件配置：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"manBefore\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.aop.advice.ManBeforeAdvice\"</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"target\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.aop.advice.Man\"</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"manman\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.aop.framework.ProxyFactoryBean\"</span></span></span><br><span class=\"line\"><span class=\"tag\">\t  <span class=\"attr\">p:interceptorNames</span>=<span class=\"string\">\"manBefore\"</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">p:proxyInterfaces</span>=<span class=\"string\">\"com.aop.advice.Person\"</span> </span></span><br><span class=\"line\"><span class=\"tag\">\t  <span class=\"attr\">p:target-ref</span>=<span class=\"string\">\"target\"</span></span></span><br><span class=\"line\"><span class=\"tag\">\t  <span class=\"attr\">p:proxyTargetClass</span>=<span class=\"string\">\"true\"</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n<p>测试类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BeforeAdviceTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">before</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        Person target=<span class=\"keyword\">new</span> Man();</span><br><span class=\"line\">        BeforeAdvice advice=<span class=\"keyword\">new</span> ManBeforeAdvice();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//①Spring提供的代理工厂</span></span><br><span class=\"line\">        ProxyFactory pf=<span class=\"keyword\">new</span> ProxyFactory();</span><br><span class=\"line\">        <span class=\"comment\">//②设置代理目标</span></span><br><span class=\"line\">        pf.setTarget(target);</span><br><span class=\"line\">        <span class=\"comment\">//③为代理目标添加增强</span></span><br><span class=\"line\">        pf.addAdvice(advice);</span><br><span class=\"line\">        <span class=\"comment\">//④生成代理实例</span></span><br><span class=\"line\">        Person proxy=(Person) pf.getProxy();</span><br><span class=\"line\">        proxy.speak(<span class=\"string\">\"gubaidan\"</span>);</span><br><span class=\"line\">        proxy.run(<span class=\"string\">\"2017-11-09\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">Hi Mr gubaidan        //增强效果</span><br><span class=\"line\">speak to gubaidan</span><br><span class=\"line\">Hi mr gubaidan        //增强效果</span><br><span class=\"line\">running 2017-11-09</span><br></pre></td></tr></table></figure>\n<h2 id=\"解析ProxyFactory\"><a href=\"#解析ProxyFactory\" class=\"headerlink\" title=\"解析ProxyFactory\"></a>解析ProxyFactory</h2><p>在BeforeAdviceTest中，使用org.springframework.aop.framework.ProxyFactory代理工厂将GreetingBeforeAdvice的增强织入目标类NaiveWaiter中。ProxyFactory内部就是使用JDK或CGLib动态代理技术将增强应用到目标类中的。</p>\n<p>Cglib2AopProxy使用CGLib动态代理技术创建代理，而JdkDynamicAopProxy使用JDK动态代理技术创建代理。 如果通过ProxyFactory的setInterfaces(Class[] interfaces)方法指定目标接口进行代理，则ProxyFactory使JdkDynamicAopProxy。</p>\n<blockquote>\n<p>如果是针对类的代理，则使用Cglib2AopProxy。 </p>\n</blockquote>\n<p>还可以通过ProxyFactory的setOptimize(true)方法让ProxyFactory启动优化代理方式，这样，针对接口的代理也会使用Cglib2AopProxy。</p>\n<p>BeforeAdviceTest使用的是CGLib动态代理技术，当我们指定接口进行代理时，将使用JDK动态代理技术</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//①Spring提供的代理工厂</span></span><br><span class=\"line\">ProxyFactory pf=<span class=\"keyword\">new</span> ProxyFactory();</span><br><span class=\"line\"><span class=\"comment\">//②设置代理目标</span></span><br><span class=\"line\">pf.setInterfaces(target.getClass().getInterfaces());<span class=\"comment\">//指定接口进行代理</span></span><br><span class=\"line\">pf.setTarget(target);</span><br></pre></td></tr></table></figure>\n<p>如果指定启动代理优化，则ProxyFactory还将使用Cglib2AopProxy代理</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//①Spring提供的代理工厂</span></span><br><span class=\"line\">ProxyFactory pf=<span class=\"keyword\">new</span> ProxyFactory();</span><br><span class=\"line\"><span class=\"comment\">//②设置代理目标</span></span><br><span class=\"line\">pf.setInterfaces(target.getClass().getInterfaces());<span class=\"comment\">//指定接口进行代理</span></span><br><span class=\"line\">pf.setTarget(target);</span><br><span class=\"line\">pf.setOpaque(<span class=\"keyword\">true</span>);   <span class=\"comment\">//启动优化</span></span><br></pre></td></tr></table></figure>\n<p>ProxyFactory通过addAdvice(Advice)方法添加一个增强，可以使用该方法添加多个增强。多个增强形成一个增强链，它们的调用顺序和添加顺序一致，可以通过addAdvice(int ,Advice)方法将增强添加到增强链的具体位置(初始位置为0)</p>\n<p>ProxyFactoryBean是FactoryBean接口的实现类，FactoryBean负责实例化一个Bean。ProxyFactoryBean负责为其他Bean创建代理实例，它在内部使用ProxyFactory来完成这项工作。</p>\n<p>ProxyFactoryBean的几个常用的可配置属性 :</p>\n<ul>\n<li>target：代理的目标对象 </li>\n<li>proxyInterfaces：代理所要实现的接口，可以是多个接口 </li>\n<li>interceptorNames：需要织入目标对象的Bean列表，采用Bean的名称指定。这些Bean必须是实现了org.aopalliance.intercept.MethodInterceptor或org.springframework.aop.Advisor的Bean，配置中的顺序对应调用的顺序。 </li>\n<li>singleton：返回的代理是否单实例，默认为单实例。 </li>\n<li>optimize：当设置为true时，强制使用CGLib动态代理。对于singleton的代理，推荐使用CGLib；对于其他作用域类型的代理，最好使用JDK动态代理 </li>\n<li>proxyTargetClass：是否对类进行代理（而不是对接口进行代理）。当设置为true时，使用CGLib动态代理</li>\n</ul>\n<h2 id=\"引介增强\"><a href=\"#引介增强\" class=\"headerlink\" title=\"引介增强\"></a>引介增强</h2><p>引介增强为目标类创建新的方法和属性，所以引介增强的连接点是类级别的，而非方法级别的。通过引介增强，可以为目标类添加一个接口的实现，可以为目标类创建实现某接口的代理。</p>\n<p>Spring定义了引介增强接口IntroductionInterceptor，该接口没有定义任何方法，Spring为其提供了DelagatingIntroductionInterceptor实现类。一般情况下，通过扩展该实现类定义自己的引介增强类。</p>\n<p>前面性能监视的例子，我们对所有的业务类都织入了性能监视的增强。由于性能监视会影响业务系统的性能，所以是否启动性能监视应该是可控的。现在通过引介增强来实现。</p>\n<p>首先定义一个用于标识目标类是否支持性能监视的接口：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Monitorable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setMonitorActive</span><span class=\"params\">(<span class=\"keyword\">boolean</span> active)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过setMonitorActive(boolean active)接口方法控制业务类性能监视功能的激活和关闭状态</p>\n<p>下面通过扩展DelegatingIntroductionInterceptor为目标类引入性能监视的可控功能</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ControllablePerformanceMonitor</span> <span class=\"keyword\">extends</span> <span class=\"title\">DelegatingIntroductionInterceptor</span> <span class=\"keyword\">implements</span> <span class=\"title\">Monitorable</span></span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">private</span> ThreadLocal&lt;Boolean&gt; MonitorStatusMap=<span class=\"keyword\">new</span> ThreadLocal&lt;Boolean&gt;(); <span class=\"comment\">//①</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setMonitorActive</span><span class=\"params\">(<span class=\"keyword\">boolean</span> active)</span></span>&#123;   <span class=\"comment\">//②</span></span><br><span class=\"line\">       MonitorStatusMap.set(active);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">//③拦截方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span><span class=\"params\">(MethodInvocation mi)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">        Object obj=<span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"comment\">//④对于支持性能监视可控代理，通过判断其状态决定是否开启性能监视功能</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(MonitorStatusMap.get()!=<span class=\"keyword\">null</span>&amp;&amp;MonitorStatusMap.get())&#123;</span><br><span class=\"line\">            PerformanceMonitor.begin(mi.getClass().getName()+<span class=\"string\">\".\"</span>+mi.getMethod().getName());</span><br><span class=\"line\">            obj=<span class=\"keyword\">super</span>.invoke(mi);</span><br><span class=\"line\">            PerformanceMonitor.end();</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            obj=<span class=\"keyword\">super</span>.invoke(mi);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>扩展DelegatingIntroductionInterceptor的同时还实现了Monitorable接口，提供接口方法的实现。<br>在①定义了一个ThreadLocal类型的变量，用于保存性能监视开关状态，为了解决单实例singleton线程安全的问题，通过ThreadLocal让每个线程单独使用一个状态。</p>\n<p>在③中覆盖了父类中的invoke()方法，该方法用于拦截目标类方法的调用，根据开关状态有条件地对目标实例方法进行性能监视。 </p>\n<p>在④处，MonitorStatusMap.get()方法返回的Boolean被自动拆包为boolean类型的值</p>\n<p>通过Spring配置，将这个引介增强织入业务类ForumService中 </p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"pmonitor\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.smart.introduce.ControllablePerformaceMonitor\"</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"forumServiceTarget\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.smart.introduce.ForumService\"</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"forumService\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.aop.framework.ProxyFactoryBean\"</span></span></span><br><span class=\"line\"><span class=\"tag\">\t<span class=\"attr\">p:interfaces</span>=<span class=\"string\">\"com.smart.introduce.Monitorable\"</span></span></span><br><span class=\"line\"><span class=\"tag\">\t<span class=\"attr\">p:target-ref</span>=<span class=\"string\">\"forumServiceTarget\"</span></span></span><br><span class=\"line\"><span class=\"tag\">\t<span class=\"attr\">p:interceptorNames</span>=<span class=\"string\">\"pmonitor\"</span> </span></span><br><span class=\"line\"><span class=\"tag\">\t<span class=\"attr\">p:proxyTargetClass</span>=<span class=\"string\">\"true\"</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n<p>首先，需要指定引介增强所实现的接口，如①。其次，由于只能通过为目标创建子类的方法生成引介增强的代理，所以必须将proxyTargetClass设置为true</p>\n<p>如果没对ControllablePerformanceMonitor进行线程安全的特殊处理，就必须将singleton属性设置为true，让ProxyFactoryBean产生prototype作用域类型的代码。当CGLib动态创建代理的性能很低，而每次通过getBean()方法中从容器中获取作用域类型为prototype的Bean时都将返回一个新的代理实例，这种性能影响是巨大的，这就是为什么通过ThreadLocal对ControllablePerformanceMonitor的开关状态进行线程安全化处理的原因。 </p>\n<p>通过线程安全化处理后，就可以使用默认的singleton Bean作用域，这样创建代理的动作仅发生一次。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IntroduceTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">introduce</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        String configPath=<span class=\"string\">\"com/smart/introduce/beans.xml\"</span>;</span><br><span class=\"line\">        ApplicationContext ctx=<span class=\"keyword\">new</span> ClassPathXmlApplicationContext(configPath);</span><br><span class=\"line\">        ForumService forumService=(ForumService)ctx.getBean(<span class=\"string\">\"forumService\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        forumService.removeForum(<span class=\"number\">10</span>);    <span class=\"comment\">//默认情况下未开启性能监视功能</span></span><br><span class=\"line\">        forumService.removeTopic(<span class=\"number\">1024</span>);</span><br><span class=\"line\">        Monitorable monitorable=(Monitorable)forumService;  <span class=\"comment\">//开启性能监视，实现了Monitorable接口</span></span><br><span class=\"line\">        monitorable.setMonitorActive(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        forumService.removeForum(<span class=\"number\">10</span>);</span><br><span class=\"line\">        forumService.removeTopic(<span class=\"number\">1024</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p> ②处，强制性地将forumService转换为Monitorable类型，代码的成功执行表示从Spring容器中返回的代理确实引入了Monitorable接口方法的实现。</p>\n<h1 id=\"以XML方式配置切面\"><a href=\"#以XML方式配置切面\" class=\"headerlink\" title=\"以XML方式配置切面\"></a>以XML方式配置切面</h1><h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>除了使用AspectJ注解声明切面，Spring也支持在bean配置文件中声明切面。这种声明是通过aop名称空间中的XML元素完成的。</p>\n<p>正常情况下，基于注解的声明要优先于基于XML的声明。通过AspectJ注解，切面可以与AspectJ兼容，而基于XML的配置则是Spring专有的。由于AspectJ得到</p>\n<p>越来越多的 AOP框架支持，所以以注解风格编写的切面将会有更多重用的机会。</p>\n<h2 id=\"配置细节\"><a href=\"#配置细节\" class=\"headerlink\" title=\"配置细节\"></a>配置细节</h2><p>在bean配置文件中，所有的Spring AOP配置都必须定义在<a href=\"aop:config\" target=\"_blank\" rel=\"noopener\">aop:config</a>元素内部。对于每个切面而言，都要创建一个<a href=\"aop:aspect\" target=\"_blank\" rel=\"noopener\">aop:aspect</a>元素来为具体的切面实现</p>\n<p>引用后端bean实例。切面bean必须有一个标识符，供<a href=\"aop:aspect\" target=\"_blank\" rel=\"noopener\">aop:aspect</a>元素引用。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\">&amp;lt;bean id=\"logAspect\" class=\"com.atguigu.aspect.LogAspect\"&amp;gt;&amp;lt;/bean&amp;gt;</span><br><span class=\"line\">&amp;lt;bean id=\"validatorAspect\" class=\"com.atguigu.aspect.ValidatorAspect\"&amp;gt;&amp;lt;/bean&amp;gt;</span><br><span class=\"line\">&amp;lt;bean id=\"mathCalulator\" class=\"com.atguigu.calulator.MathCalulator\"&amp;gt;&amp;lt;/bean&amp;gt;</span><br><span class=\"line\">&amp;lt;aop:config&amp;gt;</span><br><span class=\"line\">\t&amp;lt;aop:aspect ref=\"logAspect\"&amp;gt;&amp;lt;/aop:aspect&amp;gt;</span><br><span class=\"line\">\t&amp;lt;aop:aspect ref=\"validatorAspect\"&amp;gt;&amp;lt;/aop:aspect&amp;gt;</span><br><span class=\"line\">&amp;lt;/aop:config&amp;gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"声明切入点\"><a href=\"#声明切入点\" class=\"headerlink\" title=\"声明切入点\"></a>声明切入点</h2><p>切入点使用<a href=\"aop:pointcut\" target=\"_blank\" rel=\"noopener\">aop:pointcut</a>元素声明。 </p>\n<p>切入点必须定义在<a href=\"aop:aspect\" target=\"_blank\" rel=\"noopener\">aop:aspect</a>元素下，或者直接定义在<a href=\"aop:config\" target=\"_blank\" rel=\"noopener\">aop:config</a>元素下。 </p>\n<p>定义在<a href=\"aop:aspect\" target=\"_blank\" rel=\"noopener\">aop:aspect</a>元素下：只对当前切面有效 </p>\n<p>定义在<a href=\"aop:config\" target=\"_blank\" rel=\"noopener\">aop:config</a>元素下：对所有切面都有效 </p>\n<p>基于XML的AOP配置不允许在切入点表达式中用名称引用其他切入点。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\">&amp;lt;aop:pointcut expression=\"execution(* *.*(..))\" id=\"mypoint\"/&amp;gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"声明通知\"><a href=\"#声明通知\" class=\"headerlink\" title=\"声明通知\"></a>声明通知</h2><p>在aop名称空间中，每种通知类型都对应一个特定的XML元素。 通知元素需要使用<pointcut-ref>来引用切入点，或用<pointcut>直接嵌入切入点表达式。 method属性指定切面类中通知方法的名称</pointcut></pointcut-ref></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\">&amp;lt;aop:before method=\"logStart\" pointcut=\"execution(* *.*(..))\"/</span><br></pre></td></tr></table></figure>\n<h1 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h1><p>编程的意义是解决和简化手工劳动，而AOP的意义则是简化代码开发。</p>\n<blockquote>\n<p>参考：《Spring技术内幕》、《精通Spring 4.x 企业应用开发实战》</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"AOP是什么\"><a href=\"#AOP是什么\" class=\"headerlink\" title=\"AOP是什么\"></a>AOP是什么</h1><p>在简单的了解过AOP之后，被“面向方面编程”、“面向切面编程”、“切点”、“切面”这些术语搞的糊里糊涂，简单来说AOP是Aspect Origented Programing的简称，根据字面意思确实是面向切面编程，那么这个词到底又是什么意思？</p>\n<p>按照软件重构的思想，如果一个类在多个方法或者类中出现相同的代码，我们就认为可以将这些代码提取到父类，但是有些代码例如在代码执行前得到执行开始时间，执行后获得结束时间，这样用来统计执行时间的代码可能隐藏在一堆杂乱的代码之中，这样的话通过父类继承的方式是无法实现的，这也就是AOP将要解决的问题。</p>\n<blockquote>\n<p>我的通俗理解就是：<strong>在某个方法执行前后动态的为其插入想要执行的方法或者代码。</strong></p>\n</blockquote>\n<h1 id=\"AOP术语\"><a href=\"#AOP术语\" class=\"headerlink\" title=\"AOP术语\"></a>AOP术语</h1><p><strong>连接点（Joinpoint）:</strong>特定点是程序执行的某个特定位置，如类开始初始化前，类初始化后，类的某个方法调用前/后，方法抛出异常后。一个类或一段代码拥有一些具有边界性质的特定点，这些代码中的特定点就被称为“连接点”。 </p>\n<p>Spring仅支持方法的连接点，即仅能在方法调用前，方法调用后，方法抛出异常时及方法调用前后这些程序执行点织入增强。 </p>\n<p>连接点由两个信息确定：一是用方法表示的程序执行点，二是用相对位置表示的方位。如在Test.foo()方法执行前的连接点，执行点为Test.foo(),方法为该方法执行前的位置。Spring使用切点对执行点进行定位，而方位则在增强类型中增强</p>\n<p><strong>切点(Pointcut）:</strong>每个程序类都有多个连接点，如一个拥有两个方法的类，这两个方法就是连接点，即连接点是程序类中客观存在的事物。AOP通过“切点”定位特定的连接点。连接点相当于数据库中的记录，而切点相当于查询条件，一个切点可以匹配多个连接点。</p>\n<p>在Spring中，切点通过org.springframework.aop.Pointcut接口进行描述，它使用类和方法作为连接点的查询条件。Spring AOP的规则解析引擎负责解析切点所设定的查询条件，找到对应的连接点。确切地说，应该是执行点而非连接点，因为连接点是方法执行前/后等包括方位信息的具体程序执行点，而切点只定位到某个方法上，所以如果希望定位到具体的连接点上，需要提供方位信息</p>\n<p><strong>增强（Advice）:</strong>增强是织入目标类连接点上的一段程序代码。在Spring中，增强除用于描述一段程序代码外，还拥有另一个和连接点相关的信息，就是执行点的方位。结合执行点的方位信息和切点信息，就可以找到特定的连接。 </p>\n<p>正因为增强即包含由于添加到目标连接点上的一段执行逻辑，又包含用于定位连接点的方位信息，所以Spring所提供的增强接口都是带方位名的，如BeforeAdivce，AfterReturningAdvice和ThrowsAdvice等。BeforeAdvice表示方法调用前的位置，而AfterReturningAdvice表示访问后的位置。 所以只有结合切点和增强，才能确定特定的连接点并实施逻辑增强。</p>\n<p><strong>目标对象(Target)  :</strong>增强逻辑的织入目标类。如果没有AOP，那么目标业务类需要自己实现所有的逻辑.</p>\n<p>在AOP的帮助下，ForumService只实现那些非横切逻辑的程序逻辑，而性能监视和事务管理等这些横切逻辑就可以使用AOP动态织入特定的连接点上</p>\n<p><strong>引介（Introduction）:</strong> 引介是一种特殊的增强，为类添加一些属性和方法。这样，即使一个业务类原本没有实现某个接口，通过AOP的引介功能，也可以动态地为该业务类添加接口的实现逻辑，使业务类成为这个接口的实现类</p>\n<p><strong>织入(Weaving)  :</strong> 织入是将增强添加到目标类的具体连接点上的过程.AOP就像一台织布机，将目标类，增强或引介编织到一切。 </p>\n<p><strong>AOP有三种织入方式：</strong> </p>\n<ul>\n<li>编译期织入，这要求使用特殊的Java编译器 </li>\n<li>类装载期织入，这要求使用特殊的类装载器 </li>\n<li>动态代理织入，在运行期为目标类添加增强生成子类的方式，Spring采用动态代理织入</li>\n</ul>\n<p><strong>代理（Proxy)  :</strong> 一个类被AOP织入增强后，就产生一个结果类，它是融合了原类和增强逻辑的代理类。根据不同的代理方式，代理类既可能是和原类具有相同接口的类，也可能就是原类的子类，所以可以采用与调用原类相同的方式调用代理类。</p>\n<p><strong>切面（Aspect)  :</strong>切面由切点和增强（引介）组成，既包括横切逻辑的定义，也包括连接点的定义。Spring AOP就是负责实施切面的框架，它将切面所定义的横切逻辑织入切面所指定的连接点中</p>\n<h1 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h1><p>Spring AOP使用了两种代理机制：一种是基于JDK的动态代理；另一种是基于CGLib的动态代理。<br>之所以需要两种代理机制，是因为JDK本身只提供接口的代理，而不支持类的代理。</p>\n<p>CGLib所创建的动态代理对象的性能比JDK所创建的动态代理对象的性能高很多，但CGLib在创建代理对象时所花费的时间比JDK动态代理多。  对于singleton的代理对象或者具有实例池的代理，因为无需频繁地创建代理对象，所以比较适合采用CGLib动态代理技术；反之适合采用JDK动态代理技术。</p>\n<h1 id=\"实现者\"><a href=\"#实现者\" class=\"headerlink\" title=\"实现者\"></a>实现者</h1><p>按照增强在目标类方法中的连接点位置，可以分为5类：</p>\n<ul>\n<li><p>前置增强：org.springframework.aop.BeforeAdvice代表前置增强，因为Spring只支持方法级的增强，所以MethodBeforeAdvice是目前可用的前置增强，表示在目标方法执行前实施增强，而BeforeAdvice是为了将来版本扩展需要而定义的。</p>\n</li>\n<li><p>后置增强：org.springframework.aop.AfterReturningAdvice代表后置增强，表示在目标方法执行后实施增强。</p>\n</li>\n<li><p>环绕增强：org.aopalliance.intercept.MethodInterceptor代表环绕增强，表示在目标方法执行前后实施增强。</p>\n</li>\n<li><p>异常抛出增强：org.springframework.aop.ThrowsAdvice代表抛出异常增强，表示在目标方法抛出异常后实施增强。</p>\n</li>\n<li><p>引介增强：org.springframework.aop.IntroductionInterceptor代表引介增强，表示在目标类中添加一些新的方法和属性</p>\n</li>\n</ul>\n<h2 id=\"BeforeAdvice\"><a href=\"#BeforeAdvice\" class=\"headerlink\" title=\"BeforeAdvice\"></a>BeforeAdvice</h2><p>person接口：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">speak</span><span class=\"params\">(String name)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">(String time)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p> 具体实现类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Man</span> <span class=\"keyword\">implements</span> <span class=\"title\">Person</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">speak</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"speak to \"</span>+name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">(String time)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"runing \"</span>+time);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>增强类：执行Speak或者run方法之前执行</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PersonBeforeAdvice</span> <span class=\"keyword\">implements</span> <span class=\"title\">MethodBeforeAdvice</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">before</span><span class=\"params\">(Method method, Object[] objects, Object obj)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">        String name=(String)objects[<span class=\"number\">0</span>];</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"Hi! Mr \"</span>+name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>PersonBeforeAdvice接口仅定义了唯一的方法：before(Method method,Object[] args,Object obj)throws Throwable,其中method为目标类的方法；objects为目标类方法的入参，而obj为目标类实例。当方法发生异常时，将阻止目标类方法的执行。</p>\n<p>xml文件配置：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"manBefore\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.aop.advice.ManBeforeAdvice\"</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"target\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.aop.advice.Man\"</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"manman\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.aop.framework.ProxyFactoryBean\"</span></span></span><br><span class=\"line\"><span class=\"tag\">\t  <span class=\"attr\">p:interceptorNames</span>=<span class=\"string\">\"manBefore\"</span></span></span><br><span class=\"line\"><span class=\"tag\">      <span class=\"attr\">p:proxyInterfaces</span>=<span class=\"string\">\"com.aop.advice.Person\"</span> </span></span><br><span class=\"line\"><span class=\"tag\">\t  <span class=\"attr\">p:target-ref</span>=<span class=\"string\">\"target\"</span></span></span><br><span class=\"line\"><span class=\"tag\">\t  <span class=\"attr\">p:proxyTargetClass</span>=<span class=\"string\">\"true\"</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n<p>测试类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BeforeAdviceTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">before</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        Person target=<span class=\"keyword\">new</span> Man();</span><br><span class=\"line\">        BeforeAdvice advice=<span class=\"keyword\">new</span> ManBeforeAdvice();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//①Spring提供的代理工厂</span></span><br><span class=\"line\">        ProxyFactory pf=<span class=\"keyword\">new</span> ProxyFactory();</span><br><span class=\"line\">        <span class=\"comment\">//②设置代理目标</span></span><br><span class=\"line\">        pf.setTarget(target);</span><br><span class=\"line\">        <span class=\"comment\">//③为代理目标添加增强</span></span><br><span class=\"line\">        pf.addAdvice(advice);</span><br><span class=\"line\">        <span class=\"comment\">//④生成代理实例</span></span><br><span class=\"line\">        Person proxy=(Person) pf.getProxy();</span><br><span class=\"line\">        proxy.speak(<span class=\"string\">\"gubaidan\"</span>);</span><br><span class=\"line\">        proxy.run(<span class=\"string\">\"2017-11-09\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">Hi Mr gubaidan        //增强效果</span><br><span class=\"line\">speak to gubaidan</span><br><span class=\"line\">Hi mr gubaidan        //增强效果</span><br><span class=\"line\">running 2017-11-09</span><br></pre></td></tr></table></figure>\n<h2 id=\"解析ProxyFactory\"><a href=\"#解析ProxyFactory\" class=\"headerlink\" title=\"解析ProxyFactory\"></a>解析ProxyFactory</h2><p>在BeforeAdviceTest中，使用org.springframework.aop.framework.ProxyFactory代理工厂将GreetingBeforeAdvice的增强织入目标类NaiveWaiter中。ProxyFactory内部就是使用JDK或CGLib动态代理技术将增强应用到目标类中的。</p>\n<p>Cglib2AopProxy使用CGLib动态代理技术创建代理，而JdkDynamicAopProxy使用JDK动态代理技术创建代理。 如果通过ProxyFactory的setInterfaces(Class[] interfaces)方法指定目标接口进行代理，则ProxyFactory使JdkDynamicAopProxy。</p>\n<blockquote>\n<p>如果是针对类的代理，则使用Cglib2AopProxy。 </p>\n</blockquote>\n<p>还可以通过ProxyFactory的setOptimize(true)方法让ProxyFactory启动优化代理方式，这样，针对接口的代理也会使用Cglib2AopProxy。</p>\n<p>BeforeAdviceTest使用的是CGLib动态代理技术，当我们指定接口进行代理时，将使用JDK动态代理技术</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//①Spring提供的代理工厂</span></span><br><span class=\"line\">ProxyFactory pf=<span class=\"keyword\">new</span> ProxyFactory();</span><br><span class=\"line\"><span class=\"comment\">//②设置代理目标</span></span><br><span class=\"line\">pf.setInterfaces(target.getClass().getInterfaces());<span class=\"comment\">//指定接口进行代理</span></span><br><span class=\"line\">pf.setTarget(target);</span><br></pre></td></tr></table></figure>\n<p>如果指定启动代理优化，则ProxyFactory还将使用Cglib2AopProxy代理</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//①Spring提供的代理工厂</span></span><br><span class=\"line\">ProxyFactory pf=<span class=\"keyword\">new</span> ProxyFactory();</span><br><span class=\"line\"><span class=\"comment\">//②设置代理目标</span></span><br><span class=\"line\">pf.setInterfaces(target.getClass().getInterfaces());<span class=\"comment\">//指定接口进行代理</span></span><br><span class=\"line\">pf.setTarget(target);</span><br><span class=\"line\">pf.setOpaque(<span class=\"keyword\">true</span>);   <span class=\"comment\">//启动优化</span></span><br></pre></td></tr></table></figure>\n<p>ProxyFactory通过addAdvice(Advice)方法添加一个增强，可以使用该方法添加多个增强。多个增强形成一个增强链，它们的调用顺序和添加顺序一致，可以通过addAdvice(int ,Advice)方法将增强添加到增强链的具体位置(初始位置为0)</p>\n<p>ProxyFactoryBean是FactoryBean接口的实现类，FactoryBean负责实例化一个Bean。ProxyFactoryBean负责为其他Bean创建代理实例，它在内部使用ProxyFactory来完成这项工作。</p>\n<p>ProxyFactoryBean的几个常用的可配置属性 :</p>\n<ul>\n<li>target：代理的目标对象 </li>\n<li>proxyInterfaces：代理所要实现的接口，可以是多个接口 </li>\n<li>interceptorNames：需要织入目标对象的Bean列表，采用Bean的名称指定。这些Bean必须是实现了org.aopalliance.intercept.MethodInterceptor或org.springframework.aop.Advisor的Bean，配置中的顺序对应调用的顺序。 </li>\n<li>singleton：返回的代理是否单实例，默认为单实例。 </li>\n<li>optimize：当设置为true时，强制使用CGLib动态代理。对于singleton的代理，推荐使用CGLib；对于其他作用域类型的代理，最好使用JDK动态代理 </li>\n<li>proxyTargetClass：是否对类进行代理（而不是对接口进行代理）。当设置为true时，使用CGLib动态代理</li>\n</ul>\n<h2 id=\"引介增强\"><a href=\"#引介增强\" class=\"headerlink\" title=\"引介增强\"></a>引介增强</h2><p>引介增强为目标类创建新的方法和属性，所以引介增强的连接点是类级别的，而非方法级别的。通过引介增强，可以为目标类添加一个接口的实现，可以为目标类创建实现某接口的代理。</p>\n<p>Spring定义了引介增强接口IntroductionInterceptor，该接口没有定义任何方法，Spring为其提供了DelagatingIntroductionInterceptor实现类。一般情况下，通过扩展该实现类定义自己的引介增强类。</p>\n<p>前面性能监视的例子，我们对所有的业务类都织入了性能监视的增强。由于性能监视会影响业务系统的性能，所以是否启动性能监视应该是可控的。现在通过引介增强来实现。</p>\n<p>首先定义一个用于标识目标类是否支持性能监视的接口：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Monitorable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setMonitorActive</span><span class=\"params\">(<span class=\"keyword\">boolean</span> active)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过setMonitorActive(boolean active)接口方法控制业务类性能监视功能的激活和关闭状态</p>\n<p>下面通过扩展DelegatingIntroductionInterceptor为目标类引入性能监视的可控功能</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ControllablePerformanceMonitor</span> <span class=\"keyword\">extends</span> <span class=\"title\">DelegatingIntroductionInterceptor</span> <span class=\"keyword\">implements</span> <span class=\"title\">Monitorable</span></span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">private</span> ThreadLocal&lt;Boolean&gt; MonitorStatusMap=<span class=\"keyword\">new</span> ThreadLocal&lt;Boolean&gt;(); <span class=\"comment\">//①</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setMonitorActive</span><span class=\"params\">(<span class=\"keyword\">boolean</span> active)</span></span>&#123;   <span class=\"comment\">//②</span></span><br><span class=\"line\">       MonitorStatusMap.set(active);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">//③拦截方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span><span class=\"params\">(MethodInvocation mi)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">        Object obj=<span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"comment\">//④对于支持性能监视可控代理，通过判断其状态决定是否开启性能监视功能</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(MonitorStatusMap.get()!=<span class=\"keyword\">null</span>&amp;&amp;MonitorStatusMap.get())&#123;</span><br><span class=\"line\">            PerformanceMonitor.begin(mi.getClass().getName()+<span class=\"string\">\".\"</span>+mi.getMethod().getName());</span><br><span class=\"line\">            obj=<span class=\"keyword\">super</span>.invoke(mi);</span><br><span class=\"line\">            PerformanceMonitor.end();</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            obj=<span class=\"keyword\">super</span>.invoke(mi);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>扩展DelegatingIntroductionInterceptor的同时还实现了Monitorable接口，提供接口方法的实现。<br>在①定义了一个ThreadLocal类型的变量，用于保存性能监视开关状态，为了解决单实例singleton线程安全的问题，通过ThreadLocal让每个线程单独使用一个状态。</p>\n<p>在③中覆盖了父类中的invoke()方法，该方法用于拦截目标类方法的调用，根据开关状态有条件地对目标实例方法进行性能监视。 </p>\n<p>在④处，MonitorStatusMap.get()方法返回的Boolean被自动拆包为boolean类型的值</p>\n<p>通过Spring配置，将这个引介增强织入业务类ForumService中 </p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"pmonitor\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.smart.introduce.ControllablePerformaceMonitor\"</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"forumServiceTarget\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"com.smart.introduce.ForumService\"</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"forumService\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.aop.framework.ProxyFactoryBean\"</span></span></span><br><span class=\"line\"><span class=\"tag\">\t<span class=\"attr\">p:interfaces</span>=<span class=\"string\">\"com.smart.introduce.Monitorable\"</span></span></span><br><span class=\"line\"><span class=\"tag\">\t<span class=\"attr\">p:target-ref</span>=<span class=\"string\">\"forumServiceTarget\"</span></span></span><br><span class=\"line\"><span class=\"tag\">\t<span class=\"attr\">p:interceptorNames</span>=<span class=\"string\">\"pmonitor\"</span> </span></span><br><span class=\"line\"><span class=\"tag\">\t<span class=\"attr\">p:proxyTargetClass</span>=<span class=\"string\">\"true\"</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n<p>首先，需要指定引介增强所实现的接口，如①。其次，由于只能通过为目标创建子类的方法生成引介增强的代理，所以必须将proxyTargetClass设置为true</p>\n<p>如果没对ControllablePerformanceMonitor进行线程安全的特殊处理，就必须将singleton属性设置为true，让ProxyFactoryBean产生prototype作用域类型的代码。当CGLib动态创建代理的性能很低，而每次通过getBean()方法中从容器中获取作用域类型为prototype的Bean时都将返回一个新的代理实例，这种性能影响是巨大的，这就是为什么通过ThreadLocal对ControllablePerformanceMonitor的开关状态进行线程安全化处理的原因。 </p>\n<p>通过线程安全化处理后，就可以使用默认的singleton Bean作用域，这样创建代理的动作仅发生一次。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IntroduceTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">introduce</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        String configPath=<span class=\"string\">\"com/smart/introduce/beans.xml\"</span>;</span><br><span class=\"line\">        ApplicationContext ctx=<span class=\"keyword\">new</span> ClassPathXmlApplicationContext(configPath);</span><br><span class=\"line\">        ForumService forumService=(ForumService)ctx.getBean(<span class=\"string\">\"forumService\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        forumService.removeForum(<span class=\"number\">10</span>);    <span class=\"comment\">//默认情况下未开启性能监视功能</span></span><br><span class=\"line\">        forumService.removeTopic(<span class=\"number\">1024</span>);</span><br><span class=\"line\">        Monitorable monitorable=(Monitorable)forumService;  <span class=\"comment\">//开启性能监视，实现了Monitorable接口</span></span><br><span class=\"line\">        monitorable.setMonitorActive(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        forumService.removeForum(<span class=\"number\">10</span>);</span><br><span class=\"line\">        forumService.removeTopic(<span class=\"number\">1024</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p> ②处，强制性地将forumService转换为Monitorable类型，代码的成功执行表示从Spring容器中返回的代理确实引入了Monitorable接口方法的实现。</p>\n<h1 id=\"以XML方式配置切面\"><a href=\"#以XML方式配置切面\" class=\"headerlink\" title=\"以XML方式配置切面\"></a>以XML方式配置切面</h1><h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>除了使用AspectJ注解声明切面，Spring也支持在bean配置文件中声明切面。这种声明是通过aop名称空间中的XML元素完成的。</p>\n<p>正常情况下，基于注解的声明要优先于基于XML的声明。通过AspectJ注解，切面可以与AspectJ兼容，而基于XML的配置则是Spring专有的。由于AspectJ得到</p>\n<p>越来越多的 AOP框架支持，所以以注解风格编写的切面将会有更多重用的机会。</p>\n<h2 id=\"配置细节\"><a href=\"#配置细节\" class=\"headerlink\" title=\"配置细节\"></a>配置细节</h2><p>在bean配置文件中，所有的Spring AOP配置都必须定义在<a href=\"aop:config\" target=\"_blank\" rel=\"noopener\">aop:config</a>元素内部。对于每个切面而言，都要创建一个<a href=\"aop:aspect\" target=\"_blank\" rel=\"noopener\">aop:aspect</a>元素来为具体的切面实现</p>\n<p>引用后端bean实例。切面bean必须有一个标识符，供<a href=\"aop:aspect\" target=\"_blank\" rel=\"noopener\">aop:aspect</a>元素引用。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\">&amp;lt;bean id=\"logAspect\" class=\"com.atguigu.aspect.LogAspect\"&amp;gt;&amp;lt;/bean&amp;gt;</span><br><span class=\"line\">&amp;lt;bean id=\"validatorAspect\" class=\"com.atguigu.aspect.ValidatorAspect\"&amp;gt;&amp;lt;/bean&amp;gt;</span><br><span class=\"line\">&amp;lt;bean id=\"mathCalulator\" class=\"com.atguigu.calulator.MathCalulator\"&amp;gt;&amp;lt;/bean&amp;gt;</span><br><span class=\"line\">&amp;lt;aop:config&amp;gt;</span><br><span class=\"line\">\t&amp;lt;aop:aspect ref=\"logAspect\"&amp;gt;&amp;lt;/aop:aspect&amp;gt;</span><br><span class=\"line\">\t&amp;lt;aop:aspect ref=\"validatorAspect\"&amp;gt;&amp;lt;/aop:aspect&amp;gt;</span><br><span class=\"line\">&amp;lt;/aop:config&amp;gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"声明切入点\"><a href=\"#声明切入点\" class=\"headerlink\" title=\"声明切入点\"></a>声明切入点</h2><p>切入点使用<a href=\"aop:pointcut\" target=\"_blank\" rel=\"noopener\">aop:pointcut</a>元素声明。 </p>\n<p>切入点必须定义在<a href=\"aop:aspect\" target=\"_blank\" rel=\"noopener\">aop:aspect</a>元素下，或者直接定义在<a href=\"aop:config\" target=\"_blank\" rel=\"noopener\">aop:config</a>元素下。 </p>\n<p>定义在<a href=\"aop:aspect\" target=\"_blank\" rel=\"noopener\">aop:aspect</a>元素下：只对当前切面有效 </p>\n<p>定义在<a href=\"aop:config\" target=\"_blank\" rel=\"noopener\">aop:config</a>元素下：对所有切面都有效 </p>\n<p>基于XML的AOP配置不允许在切入点表达式中用名称引用其他切入点。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\">&amp;lt;aop:pointcut expression=\"execution(* *.*(..))\" id=\"mypoint\"/&amp;gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"声明通知\"><a href=\"#声明通知\" class=\"headerlink\" title=\"声明通知\"></a>声明通知</h2><p>在aop名称空间中，每种通知类型都对应一个特定的XML元素。 通知元素需要使用<pointcut-ref>来引用切入点，或用<pointcut>直接嵌入切入点表达式。 method属性指定切面类中通知方法的名称</pointcut></pointcut-ref></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\">&amp;lt;aop:before method=\"logStart\" pointcut=\"execution(* *.*(..))\"/</span><br></pre></td></tr></table></figure>\n<h1 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h1><p>编程的意义是解决和简化手工劳动，而AOP的意义则是简化代码开发。</p>\n<blockquote>\n<p>参考：《Spring技术内幕》、《精通Spring 4.x 企业应用开发实战》</p>\n</blockquote>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cjvayvwez0001m46ajk5cbox5","tag_id":"cjvayvwf40004m46ap8hu5q6o","_id":"cjvayvwfb0009m46acfjldqlk"},{"post_id":"cjvayvwf30003m46a8dvi8c2e","tag_id":"cjvayvwfa0008m46anwbjp7mp","_id":"cjvayvwff000em46anez7wena"},{"post_id":"cjvayvwf60005m46aaeibyhr3","tag_id":"cjvayvwfc000cm46a8oorxa4n","_id":"cjvayvwfi000im46aqjay8j7r"},{"post_id":"cjvayvwf80006m46avlsaa34p","tag_id":"cjvayvwfh000gm46ampnqkgq1","_id":"cjvayvwfk000mm46aplbmoya4"},{"post_id":"cjvayvwf90007m46addg4g06t","tag_id":"cjvayvwfj000km46as27s08xi","_id":"cjvayvwfm000qm46aamjihu1y"},{"post_id":"cjvayvwfb000am46agyjew6rd","tag_id":"cjvayvwfl000pm46aq0neq70q","_id":"cjvayvwfo000vm46axuiq9364"},{"post_id":"cjvayvwfc000bm46a95gmp7lw","tag_id":"cjvayvwfo000tm46awx9ju17t","_id":"cjvayvwfq000zm46apfan8fxz"},{"post_id":"cjvayvwfe000dm46af152pi92","tag_id":"cjvayvwfp000xm46ar7blzg9d","_id":"cjvayvwfq0011m46avap50qwk"},{"post_id":"cjvayvwfg000fm46aen2gsm4m","tag_id":"cjvayvwfq0010m46ae3qmj8du","_id":"cjvayvwfr0014m46ayffwdulo"},{"post_id":"cjvayvwfg000fm46aen2gsm4m","tag_id":"cjvayvwfq0012m46ag1czwtlk","_id":"cjvayvwfr0015m46apxhufmko"},{"post_id":"cjvayvwfi000hm46aoqqb2z01","tag_id":"cjvayvwfq0013m46a2z2bd20k","_id":"cjvayvwfr0017m46asv8atd0x"},{"post_id":"cjvayvwfi000jm46al8ez3fz2","tag_id":"cjvayvwfr0016m46a48eily61","_id":"cjvayvwfs0019m46axt3irsn1"},{"post_id":"cjvayvwfj000lm46apfr3lffa","tag_id":"cjvayvwfr0016m46a48eily61","_id":"cjvayvwft001bm46ag1bwr4sb"},{"post_id":"cjvayvwfk000nm46afjt6qpii","tag_id":"cjvayvwfr0016m46a48eily61","_id":"cjvayvwft001dm46abezcuahi"},{"post_id":"cjvayvwfl000om46a6wlzaxhu","tag_id":"cjvayvwfr0016m46a48eily61","_id":"cjvayvwft001fm46a821ovagb"},{"post_id":"cjvayvwfm000rm46ajkkvw1ex","tag_id":"cjvayvwft001em46as35jc4zj","_id":"cjvayvwfu001hm46a4u6ayyn4"},{"post_id":"cjvayvwfn000sm46a77h1w4vt","tag_id":"cjvayvwft001gm46apsuxcxn6","_id":"cjvayvwfu001jm46ay1vx61rz"},{"post_id":"cjvayvwfo000um46abz3qzb2c","tag_id":"cjvayvwfq0010m46ae3qmj8du","_id":"cjvayvwfu001lm46a07l4vmna"},{"post_id":"cjvayvwfp000wm46aexp4rmey","tag_id":"cjvayvwfu001km46ada48ijjf","_id":"cjvayvwfv001nm46aickc7sox"},{"post_id":"cjvayvwfp000ym46aadbs8236","tag_id":"cjvayvwfu001mm46aampndsv8","_id":"cjvayvwfv001pm46ajvf9e1vx"},{"post_id":"cjvayvwfp000ym46aadbs8236","tag_id":"cjvayvwfv001om46ao4u3io5m","_id":"cjvayvwfv001qm46astkhs4h9"},{"post_id":"cjvayvwg6001rm46akdb8jx4c","tag_id":"cjvayvwfl000pm46aq0neq70q","_id":"cjvayvwg8001tm46agczzi8fd"},{"post_id":"cjvayvwg7001sm46aj5y7ilbl","tag_id":"cjvayvwfl000pm46aq0neq70q","_id":"cjvayvwg9001vm46al51fut13"},{"post_id":"cjvayvwg8001um46a0rz4htw8","tag_id":"cjvayvwfj000km46as27s08xi","_id":"cjvayvwg9001xm46ah2qor65a"},{"post_id":"cjvayvwg9001wm46aad8si4pa","tag_id":"cjvayvwfj000km46as27s08xi","_id":"cjvayvwga001zm46a3583w0ob"},{"post_id":"cjvayvwga001ym46a0euzvfqo","tag_id":"cjvayvwfj000km46as27s08xi","_id":"cjvayvwgb0021m46ac43nl80d"},{"post_id":"cjvayvwgb0020m46axkqod06r","tag_id":"cjvayvwfj000km46as27s08xi","_id":"cjvayvwgc0023m46a0ckkqpl2"},{"post_id":"cjvayvwgc0022m46a0l8g8ipy","tag_id":"cjvayvwfj000km46as27s08xi","_id":"cjvayvwgd0025m46aqryngybx"},{"post_id":"cjvayvwgc0024m46a2mffzagx","tag_id":"cjvayvwfl000pm46aq0neq70q","_id":"cjvayvwge0027m46a56bz5olc"},{"post_id":"cjvayvwgd0026m46aacrrs2ii","tag_id":"cjvayvwge0028m46a290r3l1n","_id":"cjvayvwgf0029m46abkavxu1y"},{"post_id":"cjvayvwgo002am46a819kcpdy","tag_id":"cjvayvwfj000km46as27s08xi","_id":"cjvayvwgq002cm46anummpbqd"},{"post_id":"cjvayvwgp002bm46a825bgmph","tag_id":"cjvayvwfj000km46as27s08xi","_id":"cjvayvwgq002dm46abrdawjtr"}],"Tag":[{"name":"Life","_id":"cjvayvwf40004m46ap8hu5q6o"},{"name":"git","_id":"cjvayvwfa0008m46anwbjp7mp"},{"name":"shell","_id":"cjvayvwfc000cm46a8oorxa4n"},{"name":"css3","_id":"cjvayvwfh000gm46ampnqkgq1"},{"name":"Spring","_id":"cjvayvwfj000km46as27s08xi"},{"name":"算法","_id":"cjvayvwfl000pm46aq0neq70q"},{"name":"mysql","_id":"cjvayvwfo000tm46awx9ju17t"},{"name":"Oracle","_id":"cjvayvwfp000xm46ar7blzg9d"},{"name":"js","_id":"cjvayvwfq0010m46ae3qmj8du"},{"name":"html5","_id":"cjvayvwfq0012m46ag1czwtlk"},{"name":"旅行","_id":"cjvayvwfq0013m46a2z2bd20k"},{"name":"旧事","_id":"cjvayvwfr0016m46a48eily61"},{"name":"工具","_id":"cjvayvwft001em46as35jc4zj"},{"name":"杂谈","_id":"cjvayvwft001gm46apsuxcxn6"},{"name":"主题","_id":"cjvayvwfu001km46ada48ijjf"},{"name":"前端","_id":"cjvayvwfu001mm46aampndsv8"},{"name":"爬虫","_id":"cjvayvwfv001om46ao4u3io5m"},{"name":"web","_id":"cjvayvwge0028m46a290r3l1n"}]}}